(self["webpackChunkcompute_mesh_client"] = self["webpackChunkcompute_mesh_client"] || []).push([["vendors"],{

/***/ 4537:
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ 7419:
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ 9211:
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ 945:
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ 7199:
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ 6662:
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ 4997:
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ 8599:
/*!**************************************************!*\
  !*** ./node_modules/abort-controller/browser.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
/*globals self, window */


/*eslint-disable @mysticatea/prettier */
const { AbortController, AbortSignal } =
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    /* otherwise */ undefined
/*eslint-enable @mysticatea/prettier */

module.exports = AbortController
module.exports.AbortSignal = AbortSignal
module.exports["default"] = AbortController


/***/ }),

/***/ 2044:
/*!******************************************!*\
  !*** ./node_modules/any-signal/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { AbortController } = __webpack_require__(/*! native-abort-controller */ 5353)

/**
 * Takes an array of AbortSignals and returns a single signal.
 * If any signals are aborted, the returned signal will be aborted.
 * @param {Array<AbortSignal>} signals
 * @returns {AbortSignal}
 */
function anySignal (signals) {
  const controller = new AbortController()

  function onAbort () {
    controller.abort()

    for (const signal of signals) {
      if (!signal || !signal.removeEventListener) continue
      signal.removeEventListener('abort', onAbort)
    }
  }

  for (const signal of signals) {
    if (!signal || !signal.addEventListener) continue
    if (signal.aborted) {
      onAbort()
      break
    }
    signal.addEventListener('abort', onAbort)
  }

  return controller.signal
}

module.exports = anySignal
module.exports.anySignal = anySignal


/***/ }),

/***/ 9669:
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ 1609);

/***/ }),

/***/ 5448:
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ 4867);
var settle = __webpack_require__(/*! ./../core/settle */ 6026);
var cookies = __webpack_require__(/*! ./../helpers/cookies */ 4372);
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ 5327);
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ 4097);
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ 4109);
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ 7985);
var createError = __webpack_require__(/*! ../core/createError */ 5061);
var defaults = __webpack_require__(/*! ../defaults */ 5655);
var Cancel = __webpack_require__(/*! ../cancel/Cancel */ 5263);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || defaults.transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ 1609:
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ 4867);
var bind = __webpack_require__(/*! ./helpers/bind */ 1849);
var Axios = __webpack_require__(/*! ./core/Axios */ 321);
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ 7185);
var defaults = __webpack_require__(/*! ./defaults */ 5655);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ 5263);
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ 4972);
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ 6502);
axios.VERSION = __webpack_require__(/*! ./env/data */ 7288).version;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ 8713);

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ 6268);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ 5263:
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ 4972:
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ 5263);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ 6502:
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ 321:
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ 4867);
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ 5327);
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ 782);
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ 3572);
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ 7185);
var validator = __webpack_require__(/*! ../helpers/validator */ 4875);

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ 782:
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ 4867);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ 4097:
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ 1793);
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ 7303);

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ 5061:
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ 481);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ 3572:
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ 4867);
var transformData = __webpack_require__(/*! ./transformData */ 8527);
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ 6502);
var defaults = __webpack_require__(/*! ../defaults */ 5655);
var Cancel = __webpack_require__(/*! ../cancel/Cancel */ 5263);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new Cancel('canceled');
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ 481:
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};


/***/ }),

/***/ 7185:
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ 4867);

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};


/***/ }),

/***/ 6026:
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(/*! ./createError */ 5061);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ 8527:
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ 4867);
var defaults = __webpack_require__(/*! ./../defaults */ 5655);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ 5655:
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ 4867);
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ 6016);
var enhanceError = __webpack_require__(/*! ./core/enhanceError */ 481);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ 5448);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ 5448);
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ 7288:
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ ((module) => {

module.exports = {
  "version": "0.23.0"
};

/***/ }),

/***/ 1849:
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ 5327:
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ 4867);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ 7303:
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ 4372:
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ 4867);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ 1793:
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ 6268:
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ 7985:
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ 4867);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ 6016:
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ 4867);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ 4109:
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ 4867);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ 8713:
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ 4875:
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var VERSION = __webpack_require__(/*! ../env/data */ 7288).version;

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ 4867:
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ 1849);

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ 6154:
/*!************************************************************!*\
  !*** ./node_modules/browser-readablestream-to-it/index.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


/**
 * Turns a browser readable stream into an async iterable. Async iteration over
 * returned iterable will lock give stream, preventing any other consumer from
 * acquiring a reader. The lock will be released if iteration loop is broken. To
 * prevent stream cancelling optional `{ preventCancel: true }` could be passed
 * as a second argument.
 * @template T
 * @param {ReadableStream<T>} stream
 * @param {Object} [options]
 * @param {boolean} [options.preventCancel=boolean]
 * @returns {AsyncIterable<T>}
 */
async function * browserReadableStreamToIt (stream, options = {}) {
  const reader = stream.getReader()

  try {
    while (true) {
      const result = await reader.read()

      if (result.done) {
        return
      }

      yield result.value
    }
  } finally {
    if (options.preventCancel !== true) {
      reader.cancel()
    }

    reader.releaseLock()
  }
}

module.exports = browserReadableStreamToIt


/***/ }),

/***/ 1227:
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ 2447)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 2447:
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ 7824);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 2114:
/*!****************************************!*\
  !*** ./node_modules/err-code/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/**
 * @typedef {{ [key: string]: any }} Extensions
 * @typedef {Error} Err
 * @property {string} message
 */

/**
 *
 * @param {Error} obj
 * @param {Extensions} props
 * @returns {Error & Extensions}
 */
function assign(obj, props) {
    for (const key in props) {
        Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true,
        });
    }

    return obj;
}

/**
 *
 * @param {any} err - An Error
 * @param {string|Extensions} code - A string code or props to set on the error
 * @param {Extensions} [props] - Props to set on the error
 * @returns {Error & Extensions}
 */
function createError(err, code, props) {
    if (!err || typeof err === 'string') {
        throw new TypeError('Please pass an Error to err-code');
    }

    if (!props) {
        props = {};
    }

    if (typeof code === 'object') {
        props = code;
        code = '';
    }

    if (code) {
        props.code = code;
    }

    try {
        return assign(err, props);
    } catch (_) {
        props.message = err.message;
        props.stack = err.stack;

        const ErrClass = function () {};

        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));

        // @ts-ignore
        const output = assign(new ErrClass(), props);

        return output;
    }
}

module.exports = createError;


/***/ }),

/***/ 1476:
/*!****************************************!*\
  !*** ./node_modules/ip-regex/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


const word = '[a-fA-F\\d:]';
const b = options => options && options.includeBoundaries ?
	`(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` :
	'';

const v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';

const v6seg = '[a-fA-F\\d]{1,4}';
const v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();

// Pre-compile only the exact regexes because adding a global flag make regexes stateful
const v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
const v4exact = new RegExp(`^${v4}$`);
const v6exact = new RegExp(`^${v6}$`);

const ip = options => options && options.exact ?
	v46Exact :
	new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, 'g');

ip.v4 = options => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, 'g');
ip.v6 = options => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, 'g');

module.exports = ip;


/***/ }),

/***/ 106:
/*!********************************************!*\
  !*** ./node_modules/ipfs-utils/src/env.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isElectron = __webpack_require__(/*! is-electron */ 9134)

const IS_ENV_WITH_DOM = typeof window === 'object' && typeof document === 'object' && document.nodeType === 9
// @ts-ignore
const IS_ELECTRON = isElectron()
const IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON
const IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM
const IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM
const IS_NODE =  true && typeof process !== 'undefined' && typeof process.release !== 'undefined' && process.release.name === 'node' && !IS_ELECTRON
// @ts-ignore - we either ignore worker scope or dom scope
const IS_WEBWORKER = typeof importScripts === 'function' && typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope
const IS_TEST = typeof process !== 'undefined' && typeof process.env !== 'undefined' && "development" === 'test'
const IS_REACT_NATIVE = typeof navigator !== 'undefined' && navigator.product === 'ReactNative'

module.exports = {
  isTest: IS_TEST,
  isElectron: IS_ELECTRON,
  isElectronMain: IS_ELECTRON_MAIN,
  isElectronRenderer: IS_ELECTRON_RENDERER,
  isNode: IS_NODE,
  /**
   * Detects browser main thread  **NOT** web worker or service worker
   */
  isBrowser: IS_BROWSER,
  isWebWorker: IS_WEBWORKER,
  isEnvWithDom: IS_ENV_WITH_DOM,
  isReactNative: IS_REACT_NATIVE
}


/***/ }),

/***/ 1180:
/*!**********************************************!*\
  !*** ./node_modules/ipfs-utils/src/fetch.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isElectronMain } = __webpack_require__(/*! ./env */ 106)

if (isElectronMain) {
  module.exports = __webpack_require__(/*! electron-fetch */ 8795)
} else {
// use window.fetch if it is available, fall back to node-fetch if not
  module.exports = __webpack_require__(/*! native-fetch */ 700)
}


/***/ }),

/***/ 6953:
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-utils/src/files/url-source.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const HTTP = __webpack_require__(/*! ../http */ 7137)

/**
 *
 * @param {string} url
 * @param {import("../types").HTTPOptions} [options]
 * @returns {{ path: string; content?: AsyncIterable<Uint8Array> }}
 */
const urlSource = (url, options) => {
  return {
    path: decodeURIComponent(new URL(url).pathname.split('/').pop() || ''),
    content: readURLContent(url, options)
  }
}

/**
 *
 * @param {string} url
 * @param {import("../types").HTTPOptions} [options]
 * @returns {AsyncIterable<Uint8Array>}
 */
async function * readURLContent (url, options) {
  const http = new HTTP()
  const response = await http.get(url, options)

  yield * response.iterator()
}

module.exports = urlSource


/***/ }),

/***/ 7137:
/*!*********************************************!*\
  !*** ./node_modules/ipfs-utils/src/http.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable no-undef */


const { fetch, Request, Headers } = __webpack_require__(/*! ./http/fetch */ 730)
const { TimeoutError, HTTPError } = __webpack_require__(/*! ./http/error */ 4171)
const merge = __webpack_require__(/*! merge-options */ 942).bind({ ignoreUndefined: true })
const { URL, URLSearchParams } = __webpack_require__(/*! iso-url */ 7745)
const { AbortController } = __webpack_require__(/*! native-abort-controller */ 5353)
const anySignal = __webpack_require__(/*! any-signal */ 2044)

/**
 * @typedef {import('stream').Readable} NodeReadableStream
 * @typedef {import('./types').HTTPOptions} HTTPOptions
 * @typedef {import('./types').ExtendedResponse} ExtendedResponse
 */

/**
 * @template TResponse
 * @param {Promise<TResponse>} promise
 * @param {number | undefined} ms
 * @param {AbortController} abortController
 * @returns {Promise<TResponse>}
 */
const timeout = (promise, ms, abortController) => {
  if (ms === undefined) {
    return promise
  }

  const start = Date.now()

  const timedOut = () => {
    const time = Date.now() - start

    return time >= ms
  }

  return new Promise((resolve, reject) => {
    const timeoutID = setTimeout(() => {
      if (timedOut()) {
        reject(new TimeoutError())
        abortController.abort()
      }
    }, ms)

    /**
     * @param {(value: any) => void } next
     */
    const after = (next) => {
      /**
       * @param {any} res
       */
      const fn = (res) => {
        clearTimeout(timeoutID)

        if (timedOut()) {
          reject(new TimeoutError())
          return
        }

        next(res)
      }
      return fn
    }

    promise
      .then(after(resolve), after(reject))
  })
}

const defaults = {
  throwHttpErrors: true,
  credentials: 'same-origin'
}

class HTTP {
  /**
   *
   * @param {HTTPOptions} options
   */
  constructor (options = {}) {
    /** @type {HTTPOptions} */
    this.opts = merge(defaults, options)
  }

  /**
   * Fetch
   *
   * @param {string | Request} resource
   * @param {HTTPOptions} options
   * @returns {Promise<ExtendedResponse>}
   */
  async fetch (resource, options = {}) {
    /** @type {HTTPOptions} */
    const opts = merge(this.opts, options)
    const headers = new Headers(opts.headers)

    // validate resource type
    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {
      throw new TypeError('`resource` must be a string, URL, or Request')
    }

    const url = new URL(resource.toString(), opts.base)

    const {
      searchParams,
      transformSearchParams,
      json
    } = opts

    if (searchParams) {
      if (typeof transformSearchParams === 'function') {
        // @ts-ignore
        url.search = transformSearchParams(new URLSearchParams(opts.searchParams))
      } else {
        // @ts-ignore
        url.search = new URLSearchParams(opts.searchParams)
      }
    }

    if (json) {
      opts.body = JSON.stringify(opts.json)
      headers.set('content-type', 'application/json')
    }

    const abortController = new AbortController()
    // @ts-ignore
    const signal = anySignal([abortController.signal, opts.signal])

    const response = await timeout(
      fetch(
        url.toString(),
        {
          ...opts,
          signal,
          timeout: undefined,
          headers
        }
      ),
      opts.timeout,
      abortController
    )

    if (!response.ok && opts.throwHttpErrors) {
      if (opts.handleError) {
        await opts.handleError(response)
      }
      throw new HTTPError(response)
    }

    response.iterator = function () {
      return fromStream(response.body)
    }

    response.ndjson = async function * () {
      for await (const chunk of ndjson(response.iterator())) {
        if (options.transform) {
          yield options.transform(chunk)
        } else {
          yield chunk
        }
      }
    }

    return response
  }

  /**
   * @param {string | Request} resource
   * @param {HTTPOptions} options
   */
  post (resource, options = {}) {
    return this.fetch(resource, { ...options, method: 'POST' })
  }

  /**
   * @param {string | Request} resource
   * @param {HTTPOptions} options
   */
  get (resource, options = {}) {
    return this.fetch(resource, { ...options, method: 'GET' })
  }

  /**
   * @param {string | Request} resource
   * @param {HTTPOptions} options
   */
  put (resource, options = {}) {
    return this.fetch(resource, { ...options, method: 'PUT' })
  }

  /**
   * @param {string | Request} resource
   * @param {HTTPOptions} options
   */
  delete (resource, options = {}) {
    return this.fetch(resource, { ...options, method: 'DELETE' })
  }

  /**
   * @param {string | Request} resource
   * @param {HTTPOptions} options
   */
  options (resource, options = {}) {
    return this.fetch(resource, { ...options, method: 'OPTIONS' })
  }
}

/**
 * Parses NDJSON chunks from an iterator
 *
 * @param {AsyncIterable<Uint8Array>} source
 * @returns {AsyncIterable<any>}
 */
const ndjson = async function * (source) {
  const decoder = new TextDecoder()
  let buf = ''

  for await (const chunk of source) {
    buf += decoder.decode(chunk, { stream: true })
    const lines = buf.split(/\r?\n/)

    for (let i = 0; i < lines.length - 1; i++) {
      const l = lines[i].trim()
      if (l.length > 0) {
        yield JSON.parse(l)
      }
    }
    buf = lines[lines.length - 1]
  }
  buf += decoder.decode()
  buf = buf.trim()
  if (buf.length !== 0) {
    yield JSON.parse(buf)
  }
}

/**
 * Stream to AsyncIterable
 *
 * @template TChunk
 * @param {ReadableStream<TChunk> | NodeReadableStream | null} source
 * @returns {AsyncIterable<TChunk>}
 */
const fromStream = (source) => {
  // Workaround for https://github.com/node-fetch/node-fetch/issues/766
  if (isNodeReadableStream(source)) {
    const iter = source[Symbol.asyncIterator]()
    return {
      [Symbol.asyncIterator] () {
        return {
          next: iter.next.bind(iter),
          return (value) {
            source.destroy()
            if (typeof iter.return === 'function') {
              return iter.return()
            }
            return Promise.resolve({ done: true, value })
          }
        }
      }
    }
  }

  if (isWebReadableStream(source)) {
    const reader = source.getReader()
    return (async function * () {
      try {
        while (true) {
          // Read from the stream
          const { done, value } = await reader.read()
          // Exit if we're done
          if (done) return
          // Else yield the chunk
          if (value) {
            yield value
          }
        }
      } finally {
        reader.releaseLock()
      }
    })()
  }

  if (isAsyncIterable(source)) {
    return source
  }

  throw new TypeError('Body can\'t be converted to AsyncIterable')
}

/**
 * Check if it's an AsyncIterable
 *
 * @template {unknown} TChunk
 * @template {any} Other
 * @param {Other|AsyncIterable<TChunk>} value
 * @returns {value is AsyncIterable<TChunk>}
 */
const isAsyncIterable = (value) => {
  return typeof value === 'object' &&
  value !== null &&
  typeof /** @type {any} */(value)[Symbol.asyncIterator] === 'function'
}

/**
 * Check for web readable stream
 *
 * @template {unknown} TChunk
 * @template {any} Other
 * @param {Other|ReadableStream<TChunk>} value
 * @returns {value is ReadableStream<TChunk>}
 */
const isWebReadableStream = (value) => {
  return value && typeof /** @type {any} */(value).getReader === 'function'
}

/**
 * @param {any} value
 * @returns {value is NodeReadableStream}
 */
const isNodeReadableStream = (value) =>
  Object.prototype.hasOwnProperty.call(value, 'readable') &&
  Object.prototype.hasOwnProperty.call(value, 'writable')

HTTP.HTTPError = HTTPError
HTTP.TimeoutError = TimeoutError
HTTP.streamToAsyncIterator = fromStream

/**
 * @param {string | Request} resource
 * @param {HTTPOptions} [options]
 */
HTTP.post = (resource, options) => new HTTP(options).post(resource, options)

/**
 * @param {string | Request} resource
 * @param {HTTPOptions} [options]
 */
HTTP.get = (resource, options) => new HTTP(options).get(resource, options)

/**
 * @param {string | Request} resource
 * @param {HTTPOptions} [options]
 */
HTTP.put = (resource, options) => new HTTP(options).put(resource, options)

/**
 * @param {string | Request} resource
 * @param {HTTPOptions} [options]
 */
HTTP.delete = (resource, options) => new HTTP(options).delete(resource, options)

/**
 * @param {string | Request} resource
 * @param {HTTPOptions} [options]
 */
HTTP.options = (resource, options) => new HTTP(options).options(resource, options)

module.exports = HTTP


/***/ }),

/***/ 4171:
/*!***************************************************!*\
  !*** ./node_modules/ipfs-utils/src/http/error.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class TimeoutError extends Error {
  constructor (message = 'Request timed out') {
    super(message)
    this.name = 'TimeoutError'
  }
}
exports.TimeoutError = TimeoutError

class AbortError extends Error {
  constructor (message = 'The operation was aborted.') {
    super(message)
    this.name = 'AbortError'
  }
}
exports.AbortError = AbortError

class HTTPError extends Error {
  /**
   * @param {Response} response
   */
  constructor (response) {
    super(response.statusText)
    this.name = 'HTTPError'
    this.response = response
  }
}
exports.HTTPError = HTTPError


/***/ }),

/***/ 730:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-utils/src/http/fetch.browser.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { TimeoutError, AbortError } = __webpack_require__(/*! ./error */ 4171)
const { Response, Request, Headers, default: fetch } = __webpack_require__(/*! ../fetch */ 1180)

/**
 * @typedef {import('../types').FetchOptions} FetchOptions
 * @typedef {import('../types').ProgressFn} ProgressFn
 */

/**
 * Fetch with progress
 *
 * @param {string | Request} url
 * @param {FetchOptions} [options]
 * @returns {Promise<ResponseWithURL>}
 */
const fetchWithProgress = (url, options = {}) => {
  const request = new XMLHttpRequest()
  request.open(options.method || 'GET', url.toString(), true)

  const { timeout, headers } = options

  if (timeout && timeout > 0 && timeout < Infinity) {
    request.timeout = timeout
  }

  if (options.overrideMimeType != null) {
    request.overrideMimeType(options.overrideMimeType)
  }

  if (headers) {
    for (const [name, value] of new Headers(headers)) {
      request.setRequestHeader(name, value)
    }
  }

  if (options.signal) {
    options.signal.onabort = () => request.abort()
  }

  if (options.onUploadProgress) {
    request.upload.onprogress = options.onUploadProgress
  }

  // Note: Need to use `arraybuffer` here instead of `blob` because `Blob`
  // instances coming from JSDOM are not compatible with `Response` from
  // node-fetch (which is the setup we get when testing with jest because
  // it uses JSDOM which does not provide a global fetch
  // https://github.com/jsdom/jsdom/issues/1724)
  request.responseType = 'arraybuffer'

  return new Promise((resolve, reject) => {
    /**
     * @param {Event} event
     */
    const handleEvent = (event) => {
      switch (event.type) {
        case 'error': {
          resolve(Response.error())
          break
        }
        case 'load': {
          resolve(
            new ResponseWithURL(request.responseURL, request.response, {
              status: request.status,
              statusText: request.statusText,
              headers: parseHeaders(request.getAllResponseHeaders())
            })
          )
          break
        }
        case 'timeout': {
          reject(new TimeoutError())
          break
        }
        case 'abort': {
          reject(new AbortError())
          break
        }
        default: {
          break
        }
      }
    }
    request.onerror = handleEvent
    request.onload = handleEvent
    request.ontimeout = handleEvent
    request.onabort = handleEvent

    // @ts-expect-error options.body can be a node readable stream, which isn't compatible with XHR, but this
    // file is a browser override so you won't get a node readable stream so ignore the error
    request.send(options.body)
  })
}

const fetchWithStreaming = fetch

/**
 * @param {string | Request} url
 * @param {FetchOptions} options
 */
const fetchWith = (url, options = {}) =>
  (options.onUploadProgress != null)
    ? fetchWithProgress(url, options)
    : fetchWithStreaming(url, options)

/**
 * Parse Headers from a XMLHttpRequest
 *
 * @param {string} input
 * @returns {Headers}
 */
const parseHeaders = (input) => {
  const headers = new Headers()
  for (const line of input.trim().split(/[\r\n]+/)) {
    const index = line.indexOf(': ')
    if (index > 0) {
      headers.set(line.slice(0, index), line.slice(index + 1))
    }
  }

  return headers
}

class ResponseWithURL extends Response {
  /**
   * @param {string} url
   * @param {BodyInit} body
   * @param {ResponseInit} options
   */
  constructor (url, body, options) {
    super(body, options)
    Object.defineProperty(this, 'url', { value: url })
  }
}

module.exports = {
  fetch: fetchWith,
  Request,
  Headers
}


/***/ }),

/***/ 9134:
/*!*******************************************!*\
  !*** ./node_modules/is-electron/index.js ***!
  \*******************************************/
/***/ ((module) => {

// https://github.com/electron/electron/issues/2288
function isElectron() {
    // Renderer process
    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
        return true;
    }

    // Main process
    if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {
        return true;
    }

    // Detect the user agent when the `nodeIntegration` option is set to true
    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {
        return true;
    }

    return false;
}

module.exports = isElectron;


/***/ }),

/***/ 5003:
/*!*************************************!*\
  !*** ./node_modules/is-ip/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ipRegex = __webpack_require__(/*! ip-regex */ 1476);

const isIp = string => ipRegex({exact: true}).test(string);
isIp.v4 = string => ipRegex.v4({exact: true}).test(string);
isIp.v6 = string => ipRegex.v6({exact: true}).test(string);
isIp.version = string => isIp(string) ? (isIp.v4(string) ? 4 : 6) : undefined;

module.exports = isIp;


/***/ }),

/***/ 3310:
/*!********************************************!*\
  !*** ./node_modules/is-plain-obj/index.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


module.exports = value => {
	if (Object.prototype.toString.call(value) !== '[object Object]') {
		return false;
	}

	const prototype = Object.getPrototypeOf(value);
	return prototype === null || prototype === Object.prototype;
};


/***/ }),

/***/ 7745:
/*!***************************************!*\
  !*** ./node_modules/iso-url/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  URLWithLegacySupport,
  format,
  URLSearchParams,
  defaultBase
} = __webpack_require__(/*! ./src/url */ 2049)
const relative = __webpack_require__(/*! ./src/relative */ 5939)

module.exports = {
  URL: URLWithLegacySupport,
  URLSearchParams,
  format,
  relative,
  defaultBase
}


/***/ }),

/***/ 5939:
/*!**********************************************!*\
  !*** ./node_modules/iso-url/src/relative.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { URLWithLegacySupport, format } = __webpack_require__(/*! ./url */ 2049)

/**
 * @param {string | undefined} url
 * @param {any} [location]
 * @param {any} [protocolMap]
 * @param {any} [defaultProtocol]
 */
module.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {
  let protocol = location.protocol
    ? location.protocol.replace(':', '')
    : 'http'

  // Check protocol map
  protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':'
  let urlParsed

  try {
    urlParsed = new URLWithLegacySupport(url)
  } catch (err) {
    urlParsed = {}
  }

  const base = Object.assign({}, location, {
    protocol: protocol || urlParsed.protocol,
    host: location.host || urlParsed.host
  })

  return new URLWithLegacySupport(url, format(base)).toString()
}


/***/ }),

/***/ 2049:
/*!*************************************************!*\
  !*** ./node_modules/iso-url/src/url-browser.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


const isReactNative =
    typeof navigator !== 'undefined' &&
    navigator.product === 'ReactNative'

function getDefaultBase () {
  if (isReactNative) {
    return 'http://localhost'
  }
  // in some environments i.e. cloudflare workers location is not available
  if (!self.location) {
    return ''
  }

  return self.location.protocol + '//' + self.location.host
}

const URL = self.URL
const defaultBase = getDefaultBase()

class URLWithLegacySupport {
  constructor (url = '', base = defaultBase) {
    this.super = new URL(url, base)
    this.path = this.pathname + this.search
    this.auth =
            this.username && this.password
              ? this.username + ':' + this.password
              : null

    this.query =
            this.search && this.search.startsWith('?')
              ? this.search.slice(1)
              : null
  }

  get hash () {
    return this.super.hash
  }

  get host () {
    return this.super.host
  }

  get hostname () {
    return this.super.hostname
  }

  get href () {
    return this.super.href
  }

  get origin () {
    return this.super.origin
  }

  get password () {
    return this.super.password
  }

  get pathname () {
    return this.super.pathname
  }

  get port () {
    return this.super.port
  }

  get protocol () {
    return this.super.protocol
  }

  get search () {
    return this.super.search
  }

  get searchParams () {
    return this.super.searchParams
  }

  get username () {
    return this.super.username
  }

  set hash (hash) {
    this.super.hash = hash
  }

  set host (host) {
    this.super.host = host
  }

  set hostname (hostname) {
    this.super.hostname = hostname
  }

  set href (href) {
    this.super.href = href
  }

  set password (password) {
    this.super.password = password
  }

  set pathname (pathname) {
    this.super.pathname = pathname
  }

  set port (port) {
    this.super.port = port
  }

  set protocol (protocol) {
    this.super.protocol = protocol
  }

  set search (search) {
    this.super.search = search
  }

  set username (username) {
    this.super.username = username
  }

  /**
   * @param {any} o
   */
  static createObjectURL (o) {
    return URL.createObjectURL(o)
  }

  /**
   * @param {string} o
   */
  static revokeObjectURL (o) {
    URL.revokeObjectURL(o)
  }

  toJSON () {
    return this.super.toJSON()
  }

  toString () {
    return this.super.toString()
  }

  format () {
    return this.toString()
  }
}

/**
 * @param {string | import('url').UrlObject} obj
 */
function format (obj) {
  if (typeof obj === 'string') {
    const url = new URL(obj)

    return url.toString()
  }

  if (!(obj instanceof URL)) {
    const userPass =
            // @ts-ignore its not supported in node but we normalise
            obj.username && obj.password
              // @ts-ignore its not supported in node but we normalise
              ? `${obj.username}:${obj.password}@`
              : ''
    const auth = obj.auth ? obj.auth + '@' : ''
    const port = obj.port ? ':' + obj.port : ''
    const protocol = obj.protocol ? obj.protocol + '//' : ''
    const host = obj.host || ''
    const hostname = obj.hostname || ''
    const search = obj.search || (obj.query ? '?' + obj.query : '')
    const hash = obj.hash || ''
    const pathname = obj.pathname || ''
    // @ts-ignore - path is not supported in node but we normalise
    const path = obj.path || pathname + search

    return `${protocol}${userPass || auth}${
            host || hostname + port
        }${path}${hash}`
  }
}

module.exports = {
  URLWithLegacySupport,
  URLSearchParams: self.URLSearchParams,
  defaultBase,
  format
}


/***/ }),

/***/ 1303:
/*!**************************************!*\
  !*** ./node_modules/it-all/index.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";


/**
 * Collects all values from an (async) iterable into an array and returns it.
 *
 * @template T
 * @param {AsyncIterable<T>|Iterable<T>} source
 */
const all = async (source) => {
  const arr = []

  for await (const entry of source) {
    arr.push(entry)
  }

  return arr
}

module.exports = all


/***/ }),

/***/ 2262:
/*!****************************************!*\
  !*** ./node_modules/it-first/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/**
 * Returns the first result from an (async) iterable, unless empty, in which
 * case returns `undefined`.
 *
 * @template T
 * @param {AsyncIterable<T>|Iterable<T>} source
 */
const first = async (source) => {
  for await (const entry of source) { // eslint-disable-line no-unreachable-loop
    return entry
  }

  return undefined
}

module.exports = first


/***/ }),

/***/ 3093:
/*!***************************************!*\
  !*** ./node_modules/it-last/index.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/**
 * Returns the last item of an (async) iterable, unless empty, in which case
 * return `undefined`.
 *
 * @template T
 * @param {AsyncIterable<T>|Iterable<T>} source
 */
const last = async (source) => {
  let res

  for await (const entry of source) {
    res = entry
  }

  return res
}

module.exports = last


/***/ }),

/***/ 2121:
/*!**************************************!*\
  !*** ./node_modules/it-map/index.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";


/**
 * Takes an (async) iterable and returns one with each item mapped by the passed
 * function.
 *
 * @template I,O
 * @param {AsyncIterable<I>|Iterable<I>} source
 * @param {function(I):O|Promise<O>} func
 * @returns {AsyncIterable<O>}
 */
const map = async function * (source, func) {
  for await (const val of source) {
    yield func(val)
  }
}

module.exports = map


/***/ }),

/***/ 8132:
/*!*******************************************!*\
  !*** ./node_modules/it-peekable/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/**
 * @template T
 * @typedef {Object} Peek
 * @property {() => IteratorResult<T, void>} peek
 */

/**
 * @template T
 * @typedef {Object} AsyncPeek
 * @property {() => Promise<IteratorResult<T, void>>} peek
 */

/**
 * @template T
 * @typedef {Object} Push
 * @property {(value:T) => void} push
 */

/**
 * @template T
 * @typedef {Iterable<T> & Peek<T> & Push<T> & Iterator<T>} Peekable<T>
 */

/**
 * @template T
 * @typedef {AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>} AsyncPeekable<T>
 */

/**
 * @template {Iterable<any> | AsyncIterable<any>} I
 * @param {I} iterable
 * @returns {I extends Iterable<infer T>
 *  ? Peekable<T>
 *  : I extends AsyncIterable<infer T>
 *  ? AsyncPeekable<T>
 *  : never
 * }
 */
function peekableIterator (iterable) {
  // @ts-ignore
  const [iterator, symbol] = iterable[Symbol.asyncIterator]
    // @ts-ignore
    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]
    // @ts-ignore
    : [iterable[Symbol.iterator](), Symbol.iterator]

  /** @type {any[]} */
  const queue = []

  // @ts-ignore
  return {
    peek: () => {
      return iterator.next()
    },
    push: (value) => {
      queue.push(value)
    },
    next: () => {
      if (queue.length) {
        return {
          done: false,
          value: queue.shift()
        }
      }

      return iterator.next()
    },
    [symbol] () {
      return this
    }
  }
}

module.exports = peekableIterator


/***/ }),

/***/ 942:
/*!*********************************************!*\
  !*** ./node_modules/merge-options/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

const isOptionObject = __webpack_require__(/*! is-plain-obj */ 3310);

const {hasOwnProperty} = Object.prototype;
const {propertyIsEnumerable} = Object;
const defineProperty = (object, name, value) => Object.defineProperty(object, name, {
	value,
	writable: true,
	enumerable: true,
	configurable: true
});

const globalThis = this;
const defaultMergeOptions = {
	concatArrays: false,
	ignoreUndefined: false
};

const getEnumerableOwnPropertyKeys = value => {
	const keys = [];

	for (const key in value) {
		if (hasOwnProperty.call(value, key)) {
			keys.push(key);
		}
	}

	/* istanbul ignore else  */
	if (Object.getOwnPropertySymbols) {
		const symbols = Object.getOwnPropertySymbols(value);

		for (const symbol of symbols) {
			if (propertyIsEnumerable.call(value, symbol)) {
				keys.push(symbol);
			}
		}
	}

	return keys;
};

function clone(value) {
	if (Array.isArray(value)) {
		return cloneArray(value);
	}

	if (isOptionObject(value)) {
		return cloneOptionObject(value);
	}

	return value;
}

function cloneArray(array) {
	const result = array.slice(0, 0);

	getEnumerableOwnPropertyKeys(array).forEach(key => {
		defineProperty(result, key, clone(array[key]));
	});

	return result;
}

function cloneOptionObject(object) {
	const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};

	getEnumerableOwnPropertyKeys(object).forEach(key => {
		defineProperty(result, key, clone(object[key]));
	});

	return result;
}

/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {string[]} keys keys to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 */
const mergeKeys = (merged, source, keys, config) => {
	keys.forEach(key => {
		if (typeof source[key] === 'undefined' && config.ignoreUndefined) {
			return;
		}

		// Do not recurse into prototype chain of merged
		if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
			defineProperty(merged, key, merge(merged[key], source[key], config));
		} else {
			defineProperty(merged, key, clone(source[key]));
		}
	});

	return merged;
};

/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 *
 * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)
 */
const concatArrays = (merged, source, config) => {
	let result = merged.slice(0, 0);
	let resultIndex = 0;

	[merged, source].forEach(array => {
		const indices = [];

		// `result.concat(array)` with cloning
		for (let k = 0; k < array.length; k++) {
			if (!hasOwnProperty.call(array, k)) {
				continue;
			}

			indices.push(String(k));

			if (array === merged) {
				// Already cloned
				defineProperty(result, resultIndex++, array[k]);
			} else {
				defineProperty(result, resultIndex++, clone(array[k]));
			}
		}

		// Merge non-index keys
		result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);
	});

	return result;
};

/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 */
function merge(merged, source, config) {
	if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
		return concatArrays(merged, source, config);
	}

	if (!isOptionObject(source) || !isOptionObject(merged)) {
		return clone(source);
	}

	return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
}

module.exports = function (...options) {
	const config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions);
	let merged = {_: {}};

	for (const option of options) {
		if (option === undefined) {
			continue;
		}

		if (!isOptionObject(option)) {
			throw new TypeError('`' + option + '` is not an Option Object');
		}

		merged = merge(merged, {_: option}, config);
	}

	return merged._;
};


/***/ }),

/***/ 7824:
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 5700:
/*!************************************************!*\
  !*** ./node_modules/multiaddr-to-uri/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Multiaddr } = __webpack_require__(/*! multiaddr */ 6584)

const reduceValue = (_, v) => v
const tcpUri = (str, port, parts, opts) => {
  // return tcp when explicitly requested
  if (opts && opts.assumeHttp === false) return `tcp://${str}:${port}`
  // check if tcp is the last protocol in multiaddr
  let protocol = 'tcp'
  let explicitPort = `:${port}`
  const last = parts[parts.length - 1]
  if (last.protocol === 'tcp') {
    // assume http and produce clean urls
    protocol = port === '443' ? 'https' : 'http'
    explicitPort = port === '443' || port === '80' ? '' : explicitPort
  }
  return `${protocol}://${str}${explicitPort}`
}

const Reducers = {
  ip4: reduceValue,
  ip6: (str, content, i, parts) => (
    parts.length === 1 && parts[0].protocol === 'ip6'
      ? content
      : `[${content}]`
  ),
  tcp: (str, content, i, parts, opts) => (
    parts.some(p => ['http', 'https', 'ws', 'wss'].includes(p.protocol))
      ? `${str}:${content}`
      : tcpUri(str, content, parts, opts)
  ),
  udp: (str, content) => `udp://${str}:${content}`,
  dnsaddr: reduceValue,
  dns4: reduceValue,
  dns6: reduceValue,
  ipfs: (str, content) => `${str}/ipfs/${content}`,
  p2p: (str, content) => `${str}/p2p/${content}`,
  http: str => `http://${str}`,
  https: str => `https://${str}`,
  ws: str => `ws://${str}`,
  wss: str => `wss://${str}`,
  'p2p-websocket-star': str => `${str}/p2p-websocket-star`,
  'p2p-webrtc-star': str => `${str}/p2p-webrtc-star`,
  'p2p-webrtc-direct': str => `${str}/p2p-webrtc-direct`
}

module.exports = (multiaddr, opts) => {
  const ma = new Multiaddr(multiaddr)
  const parts = multiaddr.toString().split('/').slice(1)
  return ma
    .tuples()
    .map(tuple => ({
      protocol: parts.shift(),
      content: tuple[1] ? parts.shift() : null
    }))
    .reduce((str, part, i, parts) => {
      const reduce = Reducers[part.protocol]
      if (!reduce) throw new Error(`Unsupported protocol ${part.protocol}`)
      return reduce(str, part.content, i, parts, opts)
    }, '')
}


/***/ }),

/***/ 8190:
/*!*********************************************!*\
  !*** ./node_modules/multiaddr/src/codec.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const convert = __webpack_require__(/*! ./convert */ 9918)
const protocols = __webpack_require__(/*! ./protocols-table */ 9768)
const varint = __webpack_require__(/*! varint */ 4676)
const { concat: uint8ArrayConcat } = __webpack_require__(/*! uint8arrays/concat */ 605)
const { toString: uint8ArrayToString } = __webpack_require__(/*! uint8arrays/to-string */ 2263)

// export codec
module.exports = {
  stringToStringTuples,
  stringTuplesToString,

  tuplesToStringTuples,
  stringTuplesToTuples,

  bytesToTuples,
  tuplesToBytes,

  bytesToString,
  stringToBytes,

  fromString,
  fromBytes,
  validateBytes,
  isValidBytes,
  cleanPath,

  ParseError,
  protoFromTuple,

  sizeForAddr
}

// string -> [[str name, str addr]... ]
/**
 * @param {string} str
 */
function stringToStringTuples (str) {
  const tuples = []
  const parts = str.split('/').slice(1) // skip first empty elem
  if (parts.length === 1 && parts[0] === '') {
    return []
  }

  for (let p = 0; p < parts.length; p++) {
    const part = parts[p]
    const proto = protocols(part)

    if (proto.size === 0) {
      tuples.push([part])
      continue
    }

    p++ // advance addr part
    if (p >= parts.length) {
      throw ParseError('invalid address: ' + str)
    }

    // if it's a path proto, take the rest
    if (proto.path) {
      tuples.push([
        part,
        // TODO: should we need to check each path part to see if it's a proto?
        // This would allow for other protocols to be added after a unix path,
        // however it would have issues if the path had a protocol name in the path
        cleanPath(parts.slice(p).join('/'))
      ])
      break
    }

    tuples.push([part, parts[p]])
  }

  return tuples
}

// [[str name, str addr]... ] -> string
/**
 * @param {[number, string?][]} tuples
 */
function stringTuplesToString (tuples) {
  /** @type {Array<string | undefined>} */
  const parts = []
  tuples.map((tup) => {
    const proto = protoFromTuple(tup)
    parts.push(proto.name)
    if (tup.length > 1) {
      parts.push(tup[1])
    }
    return null
  })

  return cleanPath(parts.join('/'))
}

// [[str name, str addr]... ] -> [[int code, Uint8Array]... ]
/**
 * @param {Array<string[] | string >} tuples
 * @returns {[number , Uint8Array?][]}
 */
function stringTuplesToTuples (tuples) {
  return tuples.map((tup) => {
    if (!Array.isArray(tup)) {
      tup = [tup]
    }
    const proto = protoFromTuple(tup)
    if (tup.length > 1) {
      return [proto.code, convert.toBytes(proto.code, tup[1])]
    }
    return [proto.code]
  })
}

/**
 * Convert tuples to string tuples
 *
 * [[int code, Uint8Array]... ] -> [[int code, str addr]... ]
 *
 * @param {Array<[number, Uint8Array?]>} tuples
 * @returns {Array<[number, string?]>}
 */

function tuplesToStringTuples (tuples) {
  return tuples.map(tup => {
    const proto = protoFromTuple(tup)
    if (tup[1]) {
      return [proto.code, convert.toString(proto.code, tup[1])]
    }
    return [proto.code]
  })
}

// [[int code, Uint8Array ]... ] -> Uint8Array
/**
 * @param {[number, Uint8Array?][]} tuples
 */
function tuplesToBytes (tuples) {
  return fromBytes(uint8ArrayConcat(tuples.map((/** @type {any[]} */ tup) => {
    const proto = protoFromTuple(tup)
    let buf = Uint8Array.from(varint.encode(proto.code))

    if (tup.length > 1) {
      buf = uint8ArrayConcat([buf, tup[1]]) // add address buffer
    }

    return buf
  })))
}

/**
 * @param {import("./types").Protocol} p
 * @param {Uint8Array | number[]} addr
 */
function sizeForAddr (p, addr) {
  if (p.size > 0) {
    return p.size / 8
  } else if (p.size === 0) {
    return 0
  } else {
    const size = varint.decode(addr)
    return size + varint.decode.bytes
  }
}

/**
 *
 * @param {Uint8Array} buf
 * @returns {Array<[number, Uint8Array?]>}
 */
function bytesToTuples (buf) {
  /** @type {Array<[number, Uint8Array?]>} */
  const tuples = []
  let i = 0
  while (i < buf.length) {
    const code = varint.decode(buf, i)
    const n = varint.decode.bytes

    const p = protocols(code)

    const size = sizeForAddr(p, buf.slice(i + n))

    if (size === 0) {
      tuples.push([code])
      i += n
      continue
    }

    const addr = buf.slice(i + n, i + n + size)

    i += (size + n)

    if (i > buf.length) { // did not end _exactly_ at buffer.length
      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(buf, 'base16'))
    }

    // ok, tuple seems good.
    tuples.push([code, addr])
  }

  return tuples
}

// Uint8Array -> String
/**
 * @param {Uint8Array} buf
 */
function bytesToString (buf) {
  const a = bytesToTuples(buf)
  const b = tuplesToStringTuples(a)
  return stringTuplesToString(b)
}

// String -> Uint8Array
/**
 * @param {string} str
 */
function stringToBytes (str) {
  str = cleanPath(str)
  const a = stringToStringTuples(str)
  const b = stringTuplesToTuples(a)

  return tuplesToBytes(b)
}

// String -> Uint8Array
/**
 * @param {string} str
 */
function fromString (str) {
  return stringToBytes(str)
}

// Uint8Array -> Uint8Array
/**
 * @param {Uint8Array} buf
 */
function fromBytes (buf) {
  const err = validateBytes(buf)
  if (err) throw err
  return Uint8Array.from(buf) // copy
}

/**
 * @param {Uint8Array} buf
 */
function validateBytes (buf) {
  try {
    bytesToTuples(buf) // try to parse. will throw if breaks
  } catch (err) {
    return err
  }
}

/**
 * @param {Uint8Array} buf
 */
function isValidBytes (buf) {
  return validateBytes(buf) === undefined
}

/**
 * @param {string} str
 */
function cleanPath (str) {
  return '/' + str.trim().split('/').filter((/** @type {any} */ a) => a).join('/')
}

/**
 * @param {string} str
 */
function ParseError (str) {
  return new Error('Error parsing address: ' + str)
}

/**
 * @param {any[]} tup
 */
function protoFromTuple (tup) {
  const proto = protocols(tup[0])
  return proto
}


/***/ }),

/***/ 9918:
/*!***********************************************!*\
  !*** ./node_modules/multiaddr/src/convert.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ip = __webpack_require__(/*! ./ip */ 3692)
const protocols = __webpack_require__(/*! ./protocols-table */ 9768)
const { CID } = __webpack_require__(/*! multiformats/cid */ 1362)
const { base32 } = __webpack_require__(/*! multiformats/bases/base32 */ 2817)
const { base58btc } = __webpack_require__(/*! multiformats/bases/base58 */ 9086)
const Digest = __webpack_require__(/*! multiformats/hashes/digest */ 8924)
const varint = __webpack_require__(/*! varint */ 4676)
const { toString: uint8ArrayToString } = __webpack_require__(/*! uint8arrays/to-string */ 2263)
const { fromString: uint8ArrayFromString } = __webpack_require__(/*! uint8arrays/from-string */ 2217)
const { concat: uint8ArrayConcat } = __webpack_require__(/*! uint8arrays/concat */ 605)

module.exports = Convert

// converts (serializes) addresses
/**
 * @param {string} proto
 * @param {string | Uint8Array} a
 */
function Convert (proto, a) {
  if (a instanceof Uint8Array) {
    return Convert.toString(proto, a)
  } else {
    return Convert.toBytes(proto, a)
  }
}

/**
 * Convert [code,Uint8Array] to string
 *
 * @param {number|string} proto
 * @param {Uint8Array} buf
 * @returns {string}
 */
Convert.toString = function convertToString (proto, buf) {
  const protocol = protocols(proto)
  switch (protocol.code) {
    case 4: // ipv4
    case 41: // ipv6
      return bytes2ip(buf)

    case 6: // tcp
    case 273: // udp
    case 33: // dccp
    case 132: // sctp
      return bytes2port(buf).toString()

    case 53: // dns
    case 54: // dns4
    case 55: // dns6
    case 56: // dnsaddr
    case 400: // unix
    case 777: // memory
      return bytes2str(buf)

    case 421: // ipfs
      return bytes2mh(buf)
    case 444: // onion
      return bytes2onion(buf)
    case 445: // onion3
      return bytes2onion(buf)
    default:
      return uint8ArrayToString(buf, 'base16') // no clue. convert to hex
  }
}

Convert.toBytes = function convertToBytes (/** @type {string | number } */ proto, /** @type {string} */ str) {
  const protocol = protocols(proto)
  switch (protocol.code) {
    case 4: // ipv4
      return ip2bytes(str)
    case 41: // ipv6
      return ip2bytes(str)

    case 6: // tcp
    case 273: // udp
    case 33: // dccp
    case 132: // sctp
      return port2bytes(parseInt(str, 10))

    case 53: // dns
    case 54: // dns4
    case 55: // dns6
    case 56: // dnsaddr
    case 400: // unix
    case 777: // memory
      return str2bytes(str)

    case 421: // ipfs
      return mh2bytes(str)
    case 444: // onion
      return onion2bytes(str)
    case 445: // onion3
      return onion32bytes(str)
    default:
      return uint8ArrayFromString(str, 'base16') // no clue. convert from hex
  }
}

/**
 * @param {string} ipString
 */
function ip2bytes (ipString) {
  if (!ip.isIP(ipString)) {
    throw new Error('invalid ip address')
  }
  return ip.toBytes(ipString)
}

/**
 * @param {Uint8Array} ipBuff
 */
function bytes2ip (ipBuff) {
  const ipString = ip.toString(ipBuff)
  if (!ipString || !ip.isIP(ipString)) {
    throw new Error('invalid ip address')
  }
  return ipString
}

/**
 * @param {number} port
 */
function port2bytes (port) {
  const buf = new ArrayBuffer(2)
  const view = new DataView(buf)
  view.setUint16(0, port)

  return new Uint8Array(buf)
}

/**
 * @param {Uint8Array} buf
 */
function bytes2port (buf) {
  const view = new DataView(buf.buffer)
  return view.getUint16(buf.byteOffset)
}

/**
 * @param {string} str
 */
function str2bytes (str) {
  const buf = uint8ArrayFromString(str)
  const size = Uint8Array.from(varint.encode(buf.length))
  return uint8ArrayConcat([size, buf], size.length + buf.length)
}

/**
 * @param {Uint8Array} buf
 */
function bytes2str (buf) {
  const size = varint.decode(buf)
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== size) {
    throw new Error('inconsistent lengths')
  }

  return uint8ArrayToString(buf)
}

/**
 * @param {string} hash - base58btc string
 */
function mh2bytes (hash) {
  let mh

  if (hash[0] === 'Q' || hash[0] === '1') {
    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes
  } else {
    mh = CID.parse(hash).multihash.bytes
  }

  // the address is a varint prefixed multihash string representation
  const size = Uint8Array.from(varint.encode(mh.length))
  return uint8ArrayConcat([size, mh], size.length + mh.length)
}

/**
 * Converts bytes to bas58btc string
 *
 * @param {Uint8Array} buf
 * @returns {string} base58btc string
 */
function bytes2mh (buf) {
  const size = varint.decode(buf)
  const address = buf.slice(varint.decode.bytes)

  if (address.length !== size) {
    throw new Error('inconsistent lengths')
  }

  return uint8ArrayToString(address, 'base58btc')
}

/**
 * @param {string} str
 */
function onion2bytes (str) {
  const addr = str.split(':')
  if (addr.length !== 2) {
    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number')
  }
  if (addr[0].length !== 16) {
    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion address.')
  }

  // onion addresses do not include the multibase prefix, add it before decoding
  const buf = base32.decode('b' + addr[0])

  // onion port number
  const port = parseInt(addr[1], 10)
  if (port < 1 || port > 65536) {
    throw new Error('Port number is not in range(1, 65536)')
  }
  const portBuf = port2bytes(port)
  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)
}

/**
 * @param {string} str
 */
function onion32bytes (str) {
  const addr = str.split(':')
  if (addr.length !== 2) {
    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number')
  }
  if (addr[0].length !== 56) {
    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion3 address.')
  }
  // onion addresses do not include the multibase prefix, add it before decoding
  const buf = base32.decode('b' + addr[0])

  // onion port number
  const port = parseInt(addr[1], 10)
  if (port < 1 || port > 65536) {
    throw new Error('Port number is not in range(1, 65536)')
  }
  const portBuf = port2bytes(port)
  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)
}

/**
 * @param {Uint8Array} buf
 */
function bytes2onion (buf) {
  const addrBytes = buf.slice(0, buf.length - 2)
  const portBytes = buf.slice(buf.length - 2)
  const addr = uint8ArrayToString(addrBytes, 'base32')
  const port = bytes2port(portBytes)
  return addr + ':' + port
}


/***/ }),

/***/ 6584:
/*!*********************************************!*\
  !*** ./node_modules/multiaddr/src/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const codec = __webpack_require__(/*! ./codec */ 8190)
const protocols = __webpack_require__(/*! ./protocols-table */ 9768)
const varint = __webpack_require__(/*! varint */ 4676)
const { CID } = __webpack_require__(/*! multiformats/cid */ 1362)
const { base58btc } = __webpack_require__(/*! multiformats/bases/base58 */ 9086)
const errCode = __webpack_require__(/*! err-code */ 2114)
const inspect = Symbol.for('nodejs.util.inspect.custom')
const { toString: uint8ArrayToString } = __webpack_require__(/*! uint8arrays/to-string */ 2263)
const { equals: uint8ArrayEquals } = __webpack_require__(/*! uint8arrays/equals */ 9588)

/**
 * @typedef {(addr: Multiaddr) => Promise<string[]>} Resolver
 * @typedef {string | Multiaddr | Uint8Array | null} MultiaddrInput
 * @typedef {import('./types').MultiaddrObject} MultiaddrObject
 * @typedef {import('./types').Protocol} Protocol
 */

/** @type {Map<string, Resolver>} */
const resolvers = new Map()
const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr')

/**
 * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from
 * a Uint8Array, String or another Multiaddr instance
 * public key.
 *
 */
class Multiaddr {
  /**
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001')
   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
   * ```
   *
   * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)
   */
  constructor (addr) {
    // default
    if (addr == null) {
      addr = ''
    }

    // Define symbol
    Object.defineProperty(this, symbol, { value: true })

    if (addr instanceof Uint8Array) {
      /** @type {Uint8Array} - The raw bytes representing this multiaddress */
      this.bytes = codec.fromBytes(addr)
    } else if (typeof addr === 'string') {
      if (addr.length > 0 && addr.charAt(0) !== '/') {
        throw new Error(`multiaddr "${addr}" must start with a "/"`)
      }
      this.bytes = codec.fromString(addr)
    } else if (Multiaddr.isMultiaddr(addr)) { // Multiaddr
      this.bytes = codec.fromBytes(addr.bytes) // validate + copy buffer
    } else {
      throw new Error('addr must be a string, Buffer, or another Multiaddr')
    }
  }

  /**
   * Returns Multiaddr as a String
   *
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()
   * // '/ip4/127.0.0.1/tcp/4001'
   * ```
   */
  toString () {
    return codec.bytesToString(this.bytes)
  }

  /**
   * Returns Multiaddr as a JSON encoded object
   *
   * @example
   * ```js
   * JSON.stringify(new Multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // '/ip4/127.0.0.1/tcp/4001'
   * ```
   */
  toJSON () {
    return this.toString()
  }

  /**
   * Returns Multiaddr as a convinient options object to be used with net.createConnection
   *
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()
   * // { family: 4, host: '127.0.0.1', transport: 'tcp', port: 4001 }
   * ```
   */
  toOptions () {
    /** @type {MultiaddrObject} */
    const opts = {}
    const parsed = this.toString().split('/')
    opts.family = parsed[1] === 'ip4' ? 4 : 6
    opts.host = parsed[2]
    opts.transport = parsed[3]
    opts.port = parseInt(parsed[4])
    return opts
  }

  /**
   * Returns the protocols the Multiaddr is defined with, as an array of objects, in
   * left-to-right order. Each object contains the protocol code, protocol name,
   * and the size of its address space in bits.
   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
   *
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()
   * // [ { code: 4, size: 32, name: 'ip4' },
   * //   { code: 6, size: 16, name: 'tcp' } ]
   * ```
   *
   * @returns {Protocol[]} protocols - All the protocols the address is composed of
   */
  protos () {
    return this.protoCodes().map(code => Object.assign({}, protocols(code)))
  }

  /**
   * Returns the codes of the protocols in left-to-right order.
   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
   *
   * @example
   * ```js
   * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()
   * // [ 4, 6 ]
   * ```
   *
   * @returns {number[]} protocol codes
   */
  protoCodes () {
    const codes = []
    const buf = this.bytes
    let i = 0
    while (i < buf.length) {
      const code = varint.decode(buf, i)
      const n = varint.decode.bytes

      const p = protocols(code)
      const size = codec.sizeForAddr(p, buf.slice(i + n))

      i += (size + n)
      codes.push(code)
    }

    return codes
  }

  /**
   * Returns the names of the protocols in left-to-right order.
   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
   *
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()
   * // [ 'ip4', 'tcp' ]
   * ```
   *
   * @returns {string[]} protocol names
   */
  protoNames () {
    return this.protos().map(proto => proto.name)
  }

  /**
   * Returns a tuple of parts
   *
   * @example
   * ```js
   * new Multiaddr("/ip4/127.0.0.1/tcp/4001").tuples()
   * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]
   * ```
   */
  tuples () {
    return codec.bytesToTuples(this.bytes)
  }

  /**
   * Returns a tuple of string/number parts
   * - tuples[][0] = code of protocol
   * - tuples[][1] = contents of address
   *
   * @example
   * ```js
   * new Multiaddr("/ip4/127.0.0.1/tcp/4001").stringTuples()
   * // [ [ 4, '127.0.0.1' ], [ 6, '4001' ] ]
   * ```
   */
  stringTuples () {
    const t = codec.bytesToTuples(this.bytes)
    return codec.tuplesToStringTuples(t)
  }

  /**
   * Encapsulates a Multiaddr in another Multiaddr
   *
   * @example
   * ```js
   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')
   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
   *
   * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
   *
   * const mh3 = mh1.encapsulate(mh2)
   * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>
   *
   * mh3.toString()
   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'
   * ```
   *
   * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr
   */
  encapsulate (addr) {
    addr = new Multiaddr(addr)
    return new Multiaddr(this.toString() + addr.toString())
  }

  /**
   * Decapsulates a Multiaddr from another Multiaddr
   *
   * @example
   * ```js
   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')
   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
   *
   * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
   *
   * const mh3 = mh1.encapsulate(mh2)
   * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>
   *
   * mh3.decapsulate(mh2).toString()
   * // '/ip4/8.8.8.8/tcp/1080'
   * ```
   *
   * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr
   * @returns {Multiaddr}
   */
  decapsulate (addr) {
    const addrString = addr.toString()
    const s = this.toString()
    const i = s.lastIndexOf(addrString)
    if (i < 0) {
      throw new Error('Address ' + this + ' does not contain subaddress: ' + addr)
    }
    return new Multiaddr(s.slice(0, i))
  }

  /**
   * A more reliable version of `decapsulate` if you are targeting a
   * specific code, such as 421 (the `p2p` protocol code). The last index of the code
   * will be removed from the `Multiaddr`, and a new instance will be returned.
   * If the code is not present, the original `Multiaddr` is returned.
   *
   * @example
   * ```js
   * const addr = new Multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')
   * // <Multiaddr 0400... - /ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC>
   *
   * addr.decapsulateCode(421).toString()
   * // '/ip4/0.0.0.0/tcp/8080'
   *
   * new Multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()
   * // '/ip4/127.0.0.1/tcp/8080'
   * ```
   *
   * @param {number} code - The code of the protocol to decapsulate from this Multiaddr
   * @returns {Multiaddr}
   */
  decapsulateCode (code) {
    const tuples = this.tuples()
    for (let i = tuples.length - 1; i >= 0; i--) {
      if (tuples[i][0] === code) {
        return new Multiaddr(codec.tuplesToBytes(tuples.slice(0, i)))
      }
    }
    return this
  }

  /**
   * Extract the peerId if the multiaddr contains one
   *
   * @example
   * ```js
   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')
   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>
   *
   * // should return QmValidBase58string or null if the id is missing or invalid
   * const peerId = mh1.getPeerId()
   * ```
   *
   * @returns {string | null} peerId - The id of the peer or null if invalid or missing from the ma
   */
  getPeerId () {
    try {
      const tuples = this.stringTuples().filter((tuple) => {
        if (tuple[0] === protocols.names.ipfs.code) {
          return true
        }
        return false
      })

      // Get the last ipfs tuple ['ipfs', 'peerid string']
      const tuple = tuples.pop()
      if (tuple && tuple[1]) {
        const peerIdStr = tuple[1]

        // peer id is base58btc encoded string but not multibase encoded so add the `z`
        // prefix so we can validate that it is correctly encoded
        if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {
          return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc')
        }

        // try to parse peer id as CID
        return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc')
      }

      return null
    } catch (e) {
      return null
    }
  }

  /**
   * Extract the path if the multiaddr contains one
   *
   * @example
   * ```js
   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')
   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>
   *
   * // should return utf8 string or null if the id is missing or invalid
   * const path = mh1.getPath()
   * ```js
   *
   * @returns {string | null} path - The path of the multiaddr, or null if no path protocol is present
   */
  getPath () {
    let path = null
    try {
      path = this.stringTuples().filter((tuple) => {
        const proto = protocols(tuple[0])
        if (proto.path) {
          return true
        }
        return false
      })[0][1]

      if (!path) {
        path = null
      }
    } catch (e) {
      path = null
    }
    return path
  }

  /**
   * Checks if two Multiaddrs are the same
   *
   * @example
   * ```js
   * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')
   * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
   *
   * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
   *
   * mh1.equals(mh1)
   * // true
   *
   * mh1.equals(mh2)
   * // false
   * ```
   *
   * @param {Multiaddr} addr
   * @returns {boolean}
   */
  equals (addr) {
    return uint8ArrayEquals(this.bytes, addr.bytes)
  }

  /**
   * Resolve multiaddr if containing resolvable hostname.
   *
   * @example
   * ```js
   * Multiaddr.resolvers.set('dnsaddr', resolverFunction)
   * const mh1 = new Multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')
   * const resolvedMultiaddrs = await mh1.resolve()
   * // [
   * //   <Multiaddr 04934b5353060fa1a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,
   * //   <Multiaddr 04934b53530601bbde03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,
   * //   <Multiaddr 04934b535391020fa1cc03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>
   * // ]
   * ```
   *
   * @returns {Promise<Array<Multiaddr>>}
   */
  async resolve () {
    const resolvableProto = this.protos().find((p) => p.resolvable)

    // Multiaddr is not resolvable?
    if (!resolvableProto) {
      return [this]
    }

    const resolver = resolvers.get(resolvableProto.name)
    if (!resolver) {
      throw errCode(new Error(`no available resolver for ${resolvableProto.name}`), 'ERR_NO_AVAILABLE_RESOLVER')
    }

    const addresses = await resolver(this)
    return addresses.map((a) => new Multiaddr(a))
  }

  /**
   * Gets a Multiaddrs node-friendly address object. Note that protocol information
   * is left out: in Node (and most network systems) the protocol is unknowable
   * given only the address.
   *
   * Has to be a ThinWaist Address, otherwise throws error
   *
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()
   * // {family: 4, address: '127.0.0.1', port: 4001}
   * ```
   *
   * @returns {{family: 4 | 6, address: string, port: number}}
   * @throws {Error} Throws error if Multiaddr is not a Thin Waist address
   */
  nodeAddress () {
    const codes = this.protoCodes()
    const names = this.protoNames()
    const parts = this.toString().split('/').slice(1)

    if (parts.length < 4) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".')
    } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {
      throw new Error(`no protocol with name: "'${names[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`)
    } else if (parts[2] !== 'tcp' && parts[2] !== 'udp') {
      throw new Error(`no protocol with name: "'${names[1]}'". Must have a valid transport protocol: "{tcp, udp}".`)
    }

    return {
      family: (codes[0] === 41 || codes[0] === 55) ? 6 : 4,
      address: parts[1],
      port: parseInt(parts[3]) // tcp or udp port
    }
  }

  /**
   * Returns if a Multiaddr is a Thin Waist address or not.
   *
   * Thin Waist is if a Multiaddr adheres to the standard combination of:
   *
   * `{IPv4, IPv6}/{TCP, UDP}`
   *
   * @example
   * ```js
   * const mh1 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
   * const mh2 = new Multiaddr('/ip4/192.168.2.1/tcp/5001')
   * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>
   * const mh3 = mh1.encapsulate(mh2)
   * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>
   * const mh4 = new Multiaddr('/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a')
   * // <Multiaddr 047f0000010607d0de039302a503221220d52ebb89d85b02a284948203a62ff28389c57c9f42beec4ec20db76a64835843 - /ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a>
   * mh1.isThinWaistAddress()
   * // true
   * mh2.isThinWaistAddress()
   * // true
   * mh3.isThinWaistAddress()
   * // false
   * mh4.isThinWaistAddress()
   * // false
   * ```
   *
   * @param {Multiaddr} [addr] - Defaults to using `this` instance
   */
  isThinWaistAddress (addr) {
    const protos = (addr || this).protos()

    if (protos.length !== 2) {
      return false
    }

    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false
    }
    return true
  }

  /**
   * Creates a Multiaddr from a node-friendly address object
   *
   * @example
   * ```js
   * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')
   * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
   * ```
   *
   * @param {{family: 4 | 6, address: string, port: number}} addr
   * @param {string} transport
   */
  static fromNodeAddress (addr, transport) {
    if (!addr) { throw new Error('requires node address object') }
    if (!transport) { throw new Error('requires transport protocol') }
    let ip
    switch (addr.family) {
      case 4:
        ip = 'ip4'
        break
      case 6:
        ip = 'ip6'
        break
      default:
        throw Error(`Invalid addr family. Got '${addr.family}' instead of 4 or 6`)
    }
    return new Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'))
  }

  /**
   * Returns if something is a Multiaddr that is a name
   *
   * @param {Multiaddr} addr
   * @returns {boolean} isName
   */
  static isName (addr) {
    if (!Multiaddr.isMultiaddr(addr)) {
      return false
    }

    // if a part of the multiaddr is resolvable, then return true
    return addr.protos().some((proto) => proto.resolvable)
  }

  /**
   * Check if object is a CID instance
   *
   * @param {any} value
   * @returns {value is Multiaddr}
   */
  static isMultiaddr (value) {
    return value instanceof Multiaddr || Boolean(value && value[symbol])
  }

  /**
   * Returns Multiaddr as a human-readable string.
   * For post Node.js v10.0.0.
   * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect
   *
   * @example
   * ```js
   * console.log(new Multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'
   * ```
   *
   * @returns {string}
   */
  [inspect] () {
    return '<Multiaddr ' +
    uint8ArrayToString(this.bytes, 'base16') + ' - ' +
    codec.bytesToString(this.bytes) + '>'
  }

  /**
   * Returns Multiaddr as a human-readable string.
   * Fallback for pre Node.js v10.0.0.
   * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect
   *
   * @example
   * ```js
   * new Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()
   * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'
   * ```
   *
   * @returns {string}
   */
  inspect () {
    return '<Multiaddr ' +
      uint8ArrayToString(this.bytes, 'base16') + ' - ' +
      codec.bytesToString(this.bytes) + '>'
  }
}

/**
 * Object containing table, names and codes of all supported protocols.
 * To get the protocol values from a Multiaddr, you can use
 * [`.protos()`](#multiaddrprotos),
 * [`.protoCodes()`](#multiaddrprotocodes) or
 * [`.protoNames()`](#multiaddrprotonames)
 *
 * @returns {{table: Array, names: Object, codes: Object}}
 */
Multiaddr.protocols = protocols

Multiaddr.resolvers = resolvers

/**
 * Static factory
 *
 * @param {MultiaddrInput} addr
 */
function multiaddr (addr) {
  return new Multiaddr(addr)
}

module.exports = { Multiaddr, multiaddr, protocols, resolvers }


/***/ }),

/***/ 3692:
/*!******************************************!*\
  !*** ./node_modules/multiaddr/src/ip.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const isIp = __webpack_require__(/*! is-ip */ 5003)
const { toString: uint8ArrayToString } = __webpack_require__(/*! uint8arrays/to-string */ 2263)

const isIP = isIp
const isV4 = isIp.v4
const isV6 = isIp.v6

// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7
// @ts-ignore - this is copied from the link above better to keep it the same
const toBytes = function (ip, buff, offset) {
  offset = ~~offset

  let result

  if (isV4(ip)) {
    result = buff || new Uint8Array(offset + 4)
    // @ts-ignore
    // eslint-disable-next-line array-callback-return
    ip.split(/\./g).map(function (byte) {
      result[offset++] = parseInt(byte, 10) & 0xff
    })
  } else if (isV6(ip)) {
    const sections = ip.split(':', 8)

    let i
    for (i = 0; i < sections.length; i++) {
      const isv4 = isV4(sections[i])
      let v4Buffer

      if (isv4) {
        v4Buffer = toBytes(sections[i])
        sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), 'base16')
      }

      if (v4Buffer && ++i < 8) {
        sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), 'base16'))
      }
    }

    if (sections[0] === '') {
      while (sections.length < 8) sections.unshift('0')
    } else if (sections[sections.length - 1] === '') {
      while (sections.length < 8) sections.push('0')
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ''; i++);
      const argv = [i, '1']
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push('0')
      }
      sections.splice.apply(sections, argv)
    }

    result = buff || new Uint8Array(offset + 16)
    for (i = 0; i < sections.length; i++) {
      const word = parseInt(sections[i], 16)
      result[offset++] = (word >> 8) & 0xff
      result[offset++] = word & 0xff
    }
  }

  if (!result) {
    throw Error('Invalid ip address: ' + ip)
  }

  return result
}

// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63
// @ts-ignore - this is copied from the link above better to keep it the same
const toString = function (buff, offset, length) {
  offset = ~~offset
  length = length || (buff.length - offset)

  const result = []
  let string
  const view = new DataView(buff.buffer)
  if (length === 4) {
    // IPv4
    for (let i = 0; i < length; i++) {
      result.push(buff[offset + i])
    }
    string = result.join('.')
  } else if (length === 16) {
    // IPv6
    for (let i = 0; i < length; i += 2) {
      result.push(view.getUint16(offset + i).toString(16))
    }
    string = result.join(':')
    string = string.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')
    string = string.replace(/:{3,4}/, '::')
  }

  return string
}

module.exports = {
  isIP,
  isV4,
  isV6,
  toBytes,
  toString
}


/***/ }),

/***/ 9768:
/*!*******************************************************!*\
  !*** ./node_modules/multiaddr/src/protocols-table.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";

/** @typedef {import("./types").Protocol} Protocol */

/**
 * Protocols
 *
 * @param {number | string} proto
 * @returns {Protocol}
 */
function Protocols (proto) {
  if (typeof (proto) === 'number') {
    if (Protocols.codes[proto]) {
      return Protocols.codes[proto]
    }

    throw new Error('no protocol with code: ' + proto)
  } else if (typeof (proto) === 'string') {
    if (Protocols.names[proto]) {
      return Protocols.names[proto]
    }

    throw new Error('no protocol with name: ' + proto)
  }

  throw new Error('invalid protocol id type: ' + proto)
}

const V = -1
Protocols.lengthPrefixedVarSize = V
Protocols.V = V

/** @type {Array<[number, number, string, (string|boolean)?, string?]>} */
Protocols.table = [
  [4, 32, 'ip4'],
  [6, 16, 'tcp'],
  [33, 16, 'dccp'],
  [41, 128, 'ip6'],
  [42, V, 'ip6zone'],
  [53, V, 'dns', 'resolvable'],
  [54, V, 'dns4', 'resolvable'],
  [55, V, 'dns6', 'resolvable'],
  [56, V, 'dnsaddr', 'resolvable'],
  [132, 16, 'sctp'],
  [273, 16, 'udp'],
  [275, 0, 'p2p-webrtc-star'],
  [276, 0, 'p2p-webrtc-direct'],
  [277, 0, 'p2p-stardust'],
  [290, 0, 'p2p-circuit'],
  [301, 0, 'udt'],
  [302, 0, 'utp'],
  [400, V, 'unix', false, 'path'],
  // `ipfs` is added before `p2p` for legacy support.
  // All text representations will default to `p2p`, but `ipfs` will
  // still be supported
  [421, V, 'ipfs'],
  // `p2p` is the preferred name for 421, and is now the default
  [421, V, 'p2p'],
  [443, 0, 'https'],
  [444, 96, 'onion'],
  [445, 296, 'onion3'],
  [446, V, 'garlic64'],
  [460, 0, 'quic'],
  [477, 0, 'ws'],
  [478, 0, 'wss'],
  [479, 0, 'p2p-websocket-star'],
  [480, 0, 'http'],
  [777, V, 'memory']
]
/** @type {Record<string,Protocol>} */
Protocols.names = {}
/** @type {Record<number,Protocol>} */
Protocols.codes = {}

// populate tables
Protocols.table.map(row => {
  const proto = p.apply(null, row)
  Protocols.codes[proto.code] = proto
  Protocols.names[proto.name] = proto
  return null
})

Protocols.object = p

/**
 *
 * Create a protocol
 *
 * @param {number} code
 * @param {number} size
 * @param {string} name
 * @param {any} [resolvable]
 * @param {any} [path]
 * @returns {Protocol}
 */
function p (code, size, name, resolvable, path) {
  return {
    code,
    size,
    name,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  }
}

module.exports = Protocols


/***/ }),

/***/ 5353:
/*!***********************************************************!*\
  !*** ./node_modules/native-abort-controller/src/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let impl

if (globalThis.AbortController && globalThis.AbortSignal) {
  impl = globalThis
} else {
  impl = __webpack_require__(/*! abort-controller */ 8599)
}

module.exports.AbortSignal = impl.AbortSignal
module.exports.AbortController = impl.AbortController


/***/ }),

/***/ 700:
/*!************************************************!*\
  !*** ./node_modules/native-fetch/src/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
  module.exports = {
    default: globalThis.fetch,
    Headers: globalThis.Headers,
    Request: globalThis.Request,
    Response: globalThis.Response
  }
} else {
  module.exports = {
    default: __webpack_require__(/*! node-fetch */ 3300)["default"],
    Headers: __webpack_require__(/*! node-fetch */ 3300).Headers,
    Request: __webpack_require__(/*! node-fetch */ 3300).Request,
    Response: __webpack_require__(/*! node-fetch */ 3300).Response
  }
}


/***/ }),

/***/ 3300:
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports) => {

"use strict";


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof global !== 'undefined') { return global; }
	throw new Error('unable to locate global object');
}

var global = getGlobal();

module.exports = exports = global.fetch;

// Needed for TypeScript and Webpack.
if (global.fetch) {
	exports["default"] = global.fetch.bind(global);
}

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

/***/ }),

/***/ 2100:
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(/*! ./src/index-minimal */ 9482);


/***/ }),

/***/ 9482:
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(/*! ./writer */ 1173);
protobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ 3155);
protobuf.Reader       = __webpack_require__(/*! ./reader */ 1408);
protobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ 593);

// Utility
protobuf.util         = __webpack_require__(/*! ./util/minimal */ 9693);
protobuf.rpc          = __webpack_require__(/*! ./rpc */ 5994);
protobuf.roots        = __webpack_require__(/*! ./roots */ 5054);
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ 1408:
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(/*! ./util/minimal */ 9693);

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ 593:
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(/*! ./reader */ 1408);
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(/*! ./util/minimal */ 9693);

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ 5054:
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ 5994:
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(/*! ./rpc/service */ 7948);


/***/ }),

/***/ 7948:
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Service;

var util = __webpack_require__(/*! ../util/minimal */ 9693);

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ 1945:
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(/*! ../util/minimal */ 9693);

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ 9693:
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ 4537);

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(/*! @protobufjs/base64 */ 7419);

// base class of rpc.Service
util.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ 9211);

// float handling accross browsers
util.float = __webpack_require__(/*! @protobufjs/float */ 945);

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(/*! @protobufjs/inquire */ 7199);

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ 4997);

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(/*! @protobufjs/pool */ 6662);

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(/*! ./longbits */ 1945);

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof __webpack_require__.g !== "undefined"
                   && __webpack_require__.g
                   && __webpack_require__.g.process
                   && __webpack_require__.g.process.versions
                   && __webpack_require__.g.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && __webpack_require__.g
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};


/***/ }),

/***/ 1173:
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(/*! ./util/minimal */ 9693);

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ 3155:
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(/*! ./writer */ 1173);
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(/*! ./util/minimal */ 9693);

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ 590:
/*!*********************************************!*\
  !*** ./node_modules/stream-to-it/source.js ***!
  \*********************************************/
/***/ ((module) => {

module.exports = readable => {
  // Node.js stream
  if (readable[Symbol.asyncIterator]) return readable

  // Browser ReadableStream
  if (readable.getReader) {
    return (async function * () {
      const reader = readable.getReader()

      try {
        while (true) {
          const { done, value } = await reader.read()
          if (done) return
          yield value
        }
      } finally {
        reader.releaseLock()
      }
    })()
  }

  throw new Error('unknown stream')
}


/***/ }),

/***/ 6988:
/*!***************************************!*\
  !*** ./node_modules/varint/decode.js ***!
  \***************************************/
/***/ ((module) => {

module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l || shift > 49) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}


/***/ }),

/***/ 1312:
/*!***************************************!*\
  !*** ./node_modules/varint/encode.js ***!
  \***************************************/
/***/ ((module) => {

module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode.bytes = 0
    throw new RangeError('Could not encode varint')
  }
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}


/***/ }),

/***/ 4676:
/*!**************************************!*\
  !*** ./node_modules/varint/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
    encode: __webpack_require__(/*! ./encode.js */ 1312)
  , decode: __webpack_require__(/*! ./decode.js */ 6988)
  , encodingLength: __webpack_require__(/*! ./length.js */ 82)
}


/***/ }),

/***/ 82:
/*!***************************************!*\
  !*** ./node_modules/varint/length.js ***!
  \***************************************/
/***/ ((module) => {


var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}


/***/ }),

/***/ 9101:
/*!**************************************************!*\
  !*** ./node_modules/@ipld/dag-cbor/esm/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => (/* binding */ name),
/* harmony export */   "code": () => (/* binding */ code),
/* harmony export */   "encode": () => (/* binding */ encode),
/* harmony export */   "decode": () => (/* binding */ decode)
/* harmony export */ });
/* harmony import */ var cborg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cborg */ 4936);
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ 1362);


const CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes = new Uint8Array(cid.bytes.byteLength + 1);
  bytes.set(cid.bytes, 1);
  return [
    new cborg__WEBPACK_IMPORTED_MODULE_0__.Token(cborg__WEBPACK_IMPORTED_MODULE_0__.Type.tag, CID_CBOR_TAG),
    new cborg__WEBPACK_IMPORTED_MODULE_0__.Token(cborg__WEBPACK_IMPORTED_MODULE_0__.Type.bytes, bytes)
  ];
}
function undefinedEncoder() {
  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');
  }
  return null;
}
const encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes) {
  if (bytes[0] !== 0) {
    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');
  }
  return multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.decode(bytes.subarray(1));
}
const decodeOptions = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
const name = 'dag-cbor';
const code = 113;
const encode = node => cborg__WEBPACK_IMPORTED_MODULE_0__.encode(node, encodeOptions);
const decode = data => cborg__WEBPACK_IMPORTED_MODULE_0__.decode(data, decodeOptions);

/***/ }),

/***/ 1864:
/*!****************************************************!*\
  !*** ./node_modules/@ipld/dag-pb/esm/src/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => (/* binding */ name),
/* harmony export */   "code": () => (/* binding */ code),
/* harmony export */   "encode": () => (/* binding */ encode),
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "prepare": () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_3__.prepare),
/* harmony export */   "validate": () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_3__.validate),
/* harmony export */   "createNode": () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_3__.createNode),
/* harmony export */   "createLink": () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_3__.createLink)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _pb_decode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pb-decode.js */ 73);
/* harmony import */ var _pb_encode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pb-encode.js */ 50);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ 8210);




const name = 'dag-pb';
const code = 112;
function encode(node) {
  (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.validate)(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map(l => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== undefined) {
        link.Name = l.Name;
      }
      if (l.Tsize !== undefined) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return (0,_pb_encode_js__WEBPACK_IMPORTED_MODULE_2__.encodeNode)(pbn);
}
function decode(bytes) {
  const pbn = (0,_pb_decode_js__WEBPACK_IMPORTED_MODULE_1__.decodeNode)(bytes);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map(l => {
      const link = {};
      try {
        link.Hash = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error('Invalid Hash field found in link, expected CID');
      }
      if (l.Name !== undefined) {
        link.Name = l.Name;
      }
      if (l.Tsize !== undefined) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}


/***/ }),

/***/ 73:
/*!********************************************************!*\
  !*** ./node_modules/@ipld/dag-pb/esm/src/pb-decode.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeNode": () => (/* binding */ decodeNode)
/* harmony export */ });
const textDecoder = new TextDecoder();
function decodeVarint(bytes, offset) {
  let v = 0;
  for (let shift = 0;; shift += 7) {
    if (shift >= 64) {
      throw new Error('protobuf: varint overflow');
    }
    if (offset >= bytes.length) {
      throw new Error('protobuf: unexpected end of data');
    }
    const b = bytes[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [
    v,
    offset
  ];
}
function decodeBytes(bytes, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error('protobuf: invalid length');
  }
  if (postOffset > bytes.length) {
    throw new Error('protobuf: unexpected end of data');
  }
  return [
    bytes.subarray(offset, postOffset),
    postOffset
  ];
}
function decodeKey(bytes, index) {
  let wire;
  [wire, index] = decodeVarint(bytes, index);
  return [
    wire & 7,
    wire >> 3,
    index
  ];
}
function decodeLink(bytes) {
  const link = {};
  const l = bytes.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error('protobuf: (PBLink) duplicate Hash section');
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${ wireType }) for Hash`);
      }
      if (link.Name !== undefined) {
        throw new Error('protobuf: (PBLink) invalid order, found Name before Hash');
      }
      if (link.Tsize !== undefined) {
        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash');
      }
      ;
      [link.Hash, index] = decodeBytes(bytes, index);
    } else if (fieldNum === 2) {
      if (link.Name !== undefined) {
        throw new Error('protobuf: (PBLink) duplicate Name section');
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${ wireType }) for Name`);
      }
      if (link.Tsize !== undefined) {
        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name');
      }
      let byts;
      [byts, index] = decodeBytes(bytes, index);
      link.Name = textDecoder.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== undefined) {
        throw new Error('protobuf: (PBLink) duplicate Tsize section');
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${ wireType }) for Tsize`);
      }
      ;
      [link.Tsize, index] = decodeVarint(bytes, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${ fieldNum }`);
    }
  }
  if (index > l) {
    throw new Error('protobuf: (PBLink) unexpected end of data');
  }
  return link;
}
function decodeNode(bytes) {
  const l = bytes.length;
  let index = 0;
  let links;
  let linksBeforeData = false;
  let data;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${ wireType }`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error('protobuf: (PBNode) duplicate Data section');
      }
      ;
      [data, index] = decodeBytes(bytes, index);
      if (links) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error('protobuf: (PBNode) duplicate Links section');
      } else if (!links) {
        links = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes, index);
      links.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${ fieldNum }`);
    }
  }
  if (index > l) {
    throw new Error('protobuf: (PBNode) unexpected end of data');
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links || [];
  return node;
}

/***/ }),

/***/ 50:
/*!********************************************************!*\
  !*** ./node_modules/@ipld/dag-pb/esm/src/pb-encode.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "encodeNode": () => (/* binding */ encodeNode)
/* harmony export */ });
const textEncoder = new TextEncoder();
const maxInt32 = 2 ** 32;
const maxUInt32 = 2 ** 31;
function encodeLink(link, bytes) {
  let i = bytes.length;
  if (typeof link.Tsize === 'number') {
    if (link.Tsize < 0) {
      throw new Error('Tsize cannot be negative');
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error('Tsize too large for encoding');
    }
    i = encodeVarint(bytes, i, link.Tsize) - 1;
    bytes[i] = 24;
  }
  if (typeof link.Name === 'string') {
    const nameBytes = textEncoder.encode(link.Name);
    i -= nameBytes.length;
    bytes.set(nameBytes, i);
    i = encodeVarint(bytes, i, nameBytes.length) - 1;
    bytes[i] = 18;
  }
  if (link.Hash) {
    i -= link.Hash.length;
    bytes.set(link.Hash, i);
    i = encodeVarint(bytes, i, link.Hash.length) - 1;
    bytes[i] = 10;
  }
  return bytes.length - i;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes = new Uint8Array(size);
  let i = size;
  if (node.Data) {
    i -= node.Data.length;
    bytes.set(node.Data, i);
    i = encodeVarint(bytes, i, node.Data.length) - 1;
    bytes[i] = 10;
  }
  if (node.Links) {
    for (let index = node.Links.length - 1; index >= 0; index--) {
      const size = encodeLink(node.Links[index], bytes.subarray(0, i));
      i -= size;
      i = encodeVarint(bytes, i, size) - 1;
      bytes[i] = 18;
    }
  }
  return bytes;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Name === 'string') {
    const l = textEncoder.encode(link.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Tsize === 'number') {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes, offset, v) {
  offset -= sov(v);
  const base = offset;
  while (v >= maxUInt32) {
    bytes[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes[offset] = v;
  return base;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab[x];
}
const len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];

/***/ }),

/***/ 8210:
/*!***************************************************!*\
  !*** ./node_modules/@ipld/dag-pb/esm/src/util.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "prepare": () => (/* binding */ prepare),
/* harmony export */   "validate": () => (/* binding */ validate),
/* harmony export */   "createNode": () => (/* binding */ createNode),
/* harmony export */   "createLink": () => (/* binding */ createLink)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);

const pbNodeProperties = [
  'Data',
  'Links'
];
const pbLinkProperties = [
  'Hash',
  'Name',
  'Tsize'
];
const textEncoder = new TextEncoder();
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some(p => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === 'object') {
    const Hash = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.asCID(link);
    if (!Hash) {
      throw new TypeError('Invalid DAG-PB form');
    }
    return { Hash };
  }
  if (typeof link !== 'object' || Array.isArray(link)) {
    throw new TypeError('Invalid DAG-PB form');
  }
  const pbl = {};
  if (link.Hash) {
    let cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === 'string') {
          cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${ e.message }`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError('Invalid DAG-PB form');
  }
  if (typeof link.Name === 'string') {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === 'number') {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === 'string') {
    node = { Data: node };
  }
  if (typeof node !== 'object' || Array.isArray(node)) {
    throw new TypeError('Invalid DAG-PB form');
  }
  const pbn = {};
  if (node.Data !== undefined) {
    if (typeof node.Data === 'string') {
      pbn.Data = textEncoder.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError('Invalid DAG-PB form');
    }
  }
  if (node.Links !== undefined) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError('Invalid DAG-PB form');
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== 'object' || Array.isArray(node)) {
    throw new TypeError('Invalid DAG-PB form');
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError('Invalid DAG-PB form (extraneous properties)');
  }
  if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {
    throw new TypeError('Invalid DAG-PB form (Data must be a Uint8Array)');
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError('Invalid DAG-PB form (Links must be an array)');
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link = node.Links[i];
    if (!link || typeof link !== 'object' || Array.isArray(link)) {
      throw new TypeError('Invalid DAG-PB form (bad link object)');
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError('Invalid DAG-PB form (extraneous properties on link object)');
    }
    if (!link.Hash) {
      throw new TypeError('Invalid DAG-PB form (link must have a Hash)');
    }
    if (link.Hash.asCID !== link.Hash) {
      throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)');
    }
    if (link.Name !== undefined && typeof link.Name !== 'string') {
      throw new TypeError('Invalid DAG-PB form (link Name must be a string)');
    }
    if (link.Tsize !== undefined && (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0)) {
      throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)');
    }
    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
      throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)');
    }
  }
}
function createNode(data, links = []) {
  return prepare({
    Data: data,
    Links: links
  });
}
function createLink(name, size, cid) {
  return asLink({
    Hash: cid,
    Name: name,
    Tsize: size
  });
}

/***/ }),

/***/ 4936:
/*!*****************************************!*\
  !*** ./node_modules/cborg/esm/cborg.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": () => (/* reexport safe */ _lib_decode_js__WEBPACK_IMPORTED_MODULE_1__.decode),
/* harmony export */   "encode": () => (/* reexport safe */ _lib_encode_js__WEBPACK_IMPORTED_MODULE_0__.encode),
/* harmony export */   "Token": () => (/* reexport safe */ _lib_token_js__WEBPACK_IMPORTED_MODULE_2__.Token),
/* harmony export */   "Type": () => (/* reexport safe */ _lib_token_js__WEBPACK_IMPORTED_MODULE_2__.Type)
/* harmony export */ });
/* harmony import */ var _lib_encode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/encode.js */ 7463);
/* harmony import */ var _lib_decode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/decode.js */ 1287);
/* harmony import */ var _lib_token_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/token.js */ 9787);





/***/ }),

/***/ 5580:
/*!*********************************************!*\
  !*** ./node_modules/cborg/esm/lib/0uint.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "uintBoundaries": () => (/* binding */ uintBoundaries),
/* harmony export */   "readUint8": () => (/* binding */ readUint8),
/* harmony export */   "readUint16": () => (/* binding */ readUint16),
/* harmony export */   "readUint32": () => (/* binding */ readUint32),
/* harmony export */   "readUint64": () => (/* binding */ readUint64),
/* harmony export */   "decodeUint8": () => (/* binding */ decodeUint8),
/* harmony export */   "decodeUint16": () => (/* binding */ decodeUint16),
/* harmony export */   "decodeUint32": () => (/* binding */ decodeUint32),
/* harmony export */   "decodeUint64": () => (/* binding */ decodeUint64),
/* harmony export */   "encodeUint": () => (/* binding */ encodeUint),
/* harmony export */   "encodeUintValue": () => (/* binding */ encodeUintValue)
/* harmony export */ });
/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ 9787);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ 5590);


const uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt('18446744073709551616')
];
function readUint8(data, offset, options) {
  (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.assertEnoughData)(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.assertEnoughData)(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.assertEnoughData)(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.assertEnoughData)(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf, token) {
  return encodeUintValue(buf, 0, token.value);
}
function encodeUintValue(buf, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf.push(set);
    } else {
      throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};

/***/ }),

/***/ 3929:
/*!***********************************************!*\
  !*** ./node_modules/cborg/esm/lib/1negint.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeNegint8": () => (/* binding */ decodeNegint8),
/* harmony export */   "decodeNegint16": () => (/* binding */ decodeNegint16),
/* harmony export */   "decodeNegint32": () => (/* binding */ decodeNegint32),
/* harmony export */   "decodeNegint64": () => (/* binding */ decodeNegint64),
/* harmony export */   "encodeNegint": () => (/* binding */ encodeNegint)
/* harmony export */ });
/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ 9787);
/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./0uint.js */ 5580);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ 5590);



function decodeNegint8(data, pos, _minor, options) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint, -1 - _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint, -1 - _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint, -1 - _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint32(data, pos + 1, options), 5);
}
const neg1b = BigInt(-1);
const pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint64(data, pos + 1, options);
  if (typeof int !== 'bigint') {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_2__.decodeErrPrefix } integers outside of the safe integer range are not supported`);
  }
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf, token) {
  const negint = token.value;
  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;
  _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUintValue(buf, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize(token) {
  const negint = token.value;
  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < _0uint_js__WEBPACK_IMPORTED_MODULE_1__.uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < _0uint_js__WEBPACK_IMPORTED_MODULE_1__.uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < _0uint_js__WEBPACK_IMPORTED_MODULE_1__.uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < _0uint_js__WEBPACK_IMPORTED_MODULE_1__.uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};

/***/ }),

/***/ 2887:
/*!**********************************************!*\
  !*** ./node_modules/cborg/esm/lib/2bytes.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeBytesCompact": () => (/* binding */ decodeBytesCompact),
/* harmony export */   "decodeBytes8": () => (/* binding */ decodeBytes8),
/* harmony export */   "decodeBytes16": () => (/* binding */ decodeBytes16),
/* harmony export */   "decodeBytes32": () => (/* binding */ decodeBytes32),
/* harmony export */   "decodeBytes64": () => (/* binding */ decodeBytes64),
/* harmony export */   "encodeBytes": () => (/* binding */ encodeBytes),
/* harmony export */   "compareBytes": () => (/* binding */ compareBytes)
/* harmony export */ });
/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ 9787);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ 5590);
/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./0uint.js */ 5580);
/* harmony import */ var _byte_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./byte-utils.js */ 2042);




function toToken(data, pos, prefix, length) {
  (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.assertEnoughData)(data, pos, prefix + length);
  const buf = (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_3__.slice)(data, pos + prefix, pos + prefix + length);
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.bytes, buf, prefix + length);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint64(data, pos + 1, options);
  if (typeof l === 'bigint') {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === undefined) {
    token.encodedBytes = token.type === _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.string ? (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_3__.fromString)(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf, token) {
  const bytes = tokenBytes(token);
  _0uint_js__WEBPACK_IMPORTED_MODULE_2__.encodeUintValue(buf, token.type.majorEncoded, bytes.length);
  buf.push(bytes);
}
encodeBytes.encodedSize = function encodedSize(token) {
  const bytes = tokenBytes(token);
  return _0uint_js__WEBPACK_IMPORTED_MODULE_2__.encodeUintValue.encodedSize(bytes.length) + bytes.length;
};
encodeBytes.compareTokens = function compareTokens(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_3__.compare)(b1, b2);
}

/***/ }),

/***/ 768:
/*!***********************************************!*\
  !*** ./node_modules/cborg/esm/lib/3string.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeStringCompact": () => (/* binding */ decodeStringCompact),
/* harmony export */   "decodeString8": () => (/* binding */ decodeString8),
/* harmony export */   "decodeString16": () => (/* binding */ decodeString16),
/* harmony export */   "decodeString32": () => (/* binding */ decodeString32),
/* harmony export */   "decodeString64": () => (/* binding */ decodeString64),
/* harmony export */   "encodeString": () => (/* binding */ encodeString)
/* harmony export */ });
/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ 9787);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ 5590);
/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./0uint.js */ 5580);
/* harmony import */ var _2bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./2bytes.js */ 2887);
/* harmony import */ var _byte_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./byte-utils.js */ 2042);





function toToken(data, pos, prefix, length) {
  const totLength = prefix + length;
  (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.assertEnoughData)(data, pos, totLength);
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.string, (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_4__.toString)(data, pos + prefix, pos + totLength), totLength);
}
function decodeStringCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeString8(data, pos, _minor, options) {
  return toToken(data, pos, 2, _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint8(data, pos + 1, options));
}
function decodeString16(data, pos, _minor, options) {
  return toToken(data, pos, 3, _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint16(data, pos + 1, options));
}
function decodeString32(data, pos, _minor, options) {
  return toToken(data, pos, 5, _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint32(data, pos + 1, options));
}
function decodeString64(data, pos, _minor, options) {
  const l = _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint64(data, pos + 1, options);
  if (typeof l === 'bigint') {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } 64-bit integer string lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
const encodeString = _2bytes_js__WEBPACK_IMPORTED_MODULE_3__.encodeBytes;

/***/ }),

/***/ 8278:
/*!**********************************************!*\
  !*** ./node_modules/cborg/esm/lib/4array.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeArrayCompact": () => (/* binding */ decodeArrayCompact),
/* harmony export */   "decodeArray8": () => (/* binding */ decodeArray8),
/* harmony export */   "decodeArray16": () => (/* binding */ decodeArray16),
/* harmony export */   "decodeArray32": () => (/* binding */ decodeArray32),
/* harmony export */   "decodeArray64": () => (/* binding */ decodeArray64),
/* harmony export */   "decodeArrayIndefinite": () => (/* binding */ decodeArrayIndefinite),
/* harmony export */   "encodeArray": () => (/* binding */ encodeArray)
/* harmony export */ });
/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ 9787);
/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./0uint.js */ 5580);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ 5590);



function toToken(_data, _pos, prefix, length) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.array, length, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken(data, pos, 2, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken(data, pos, 3, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken(data, pos, 5, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint64(data, pos + 1, options);
  if (typeof l === 'bigint') {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_2__.decodeErrPrefix } 64-bit integer array lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_2__.decodeErrPrefix } indefinite length items not allowed`);
  }
  return toToken(data, pos, 1, Infinity);
}
function encodeArray(buf, token) {
  _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUintValue(buf, _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUint.compareTokens;

/***/ }),

/***/ 9283:
/*!********************************************!*\
  !*** ./node_modules/cborg/esm/lib/5map.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeMapCompact": () => (/* binding */ decodeMapCompact),
/* harmony export */   "decodeMap8": () => (/* binding */ decodeMap8),
/* harmony export */   "decodeMap16": () => (/* binding */ decodeMap16),
/* harmony export */   "decodeMap32": () => (/* binding */ decodeMap32),
/* harmony export */   "decodeMap64": () => (/* binding */ decodeMap64),
/* harmony export */   "decodeMapIndefinite": () => (/* binding */ decodeMapIndefinite),
/* harmony export */   "encodeMap": () => (/* binding */ encodeMap)
/* harmony export */ });
/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ 9787);
/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./0uint.js */ 5580);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ 5590);



function toToken(_data, _pos, prefix, length) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.map, length, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken(data, pos, 2, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken(data, pos, 3, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken(data, pos, 5, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint64(data, pos + 1, options);
  if (typeof l === 'bigint') {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_2__.decodeErrPrefix } 64-bit integer map lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_2__.decodeErrPrefix } indefinite length items not allowed`);
  }
  return toToken(data, pos, 1, Infinity);
}
function encodeMap(buf, token) {
  _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUintValue(buf, _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUint.compareTokens;

/***/ }),

/***/ 2428:
/*!********************************************!*\
  !*** ./node_modules/cborg/esm/lib/6tag.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeTagCompact": () => (/* binding */ decodeTagCompact),
/* harmony export */   "decodeTag8": () => (/* binding */ decodeTag8),
/* harmony export */   "decodeTag16": () => (/* binding */ decodeTag16),
/* harmony export */   "decodeTag32": () => (/* binding */ decodeTag32),
/* harmony export */   "decodeTag64": () => (/* binding */ decodeTag64),
/* harmony export */   "encodeTag": () => (/* binding */ encodeTag)
/* harmony export */ });
/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ 9787);
/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./0uint.js */ 5580);


function decodeTagCompact(_data, _pos, minor, _options) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.tag, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.tag, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.tag, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.tag, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf, token) {
  _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUintValue(buf, _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUint.compareTokens;

/***/ }),

/***/ 3851:
/*!**********************************************!*\
  !*** ./node_modules/cborg/esm/lib/7float.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeUndefined": () => (/* binding */ decodeUndefined),
/* harmony export */   "decodeBreak": () => (/* binding */ decodeBreak),
/* harmony export */   "decodeFloat16": () => (/* binding */ decodeFloat16),
/* harmony export */   "decodeFloat32": () => (/* binding */ decodeFloat32),
/* harmony export */   "decodeFloat64": () => (/* binding */ decodeFloat64),
/* harmony export */   "encodeFloat": () => (/* binding */ encodeFloat)
/* harmony export */ });
/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ 9787);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ 5590);
/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./0uint.js */ 5580);



const MINOR_FALSE = 20;
const MINOR_TRUE = 21;
const MINOR_NULL = 22;
const MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } undefined values are not supported`);
  }
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.undefined, undefined, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } indefinite length items not allowed`);
  }
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type["break"], undefined, 1);
}
function createToken(value, bytes, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } Infinity values are not supported`);
    }
  }
  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.float, value, bytes);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf, token, options) {
  const float = token.value;
  if (float === false) {
    buf.push([_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf.push([_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf.push([_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === undefined) {
    buf.push([_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === undefined) {
    return 1;
  }
  let decoded;
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
const buffer = new ArrayBuffer(9);
const dataView = new DataView(buffer, 1);
const ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a, pos) {
  if (ui8a.length - pos < 2) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } not enough data for float16`);
  }
  const half = (ui8a[pos] << 8) + ui8a[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a, pos) {
  if (ui8a.length - pos < 4) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } not enough data for float32`);
  }
  const offset = (ui8a.byteOffset || 0) + pos;
  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a, pos) {
  if (ui8a.length - pos < 8) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix } not enough data for float64`);
  }
  const offset = (ui8a.byteOffset || 0) + pos;
  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = _0uint_js__WEBPACK_IMPORTED_MODULE_2__.encodeUint.compareTokens;

/***/ }),

/***/ 1796:
/*!******************************************!*\
  !*** ./node_modules/cborg/esm/lib/bl.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bl": () => (/* binding */ Bl)
/* harmony export */ });
/* harmony import */ var _byte_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-utils.js */ 2042);

const defaultChunkSize = 256;
class Bl {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.chunks = [];
    this.cursor = 0;
    this.maxCursor = -1;
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes.length < 64 && bytes.length < this.chunkSize) {
        topChunk = (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_0__.alloc)(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes, 0);
      } else {
        this.chunks.push(bytes);
        this.maxCursor += bytes.length;
      }
    }
    this.cursor += bytes.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_0__.slice)(chunk, 0, this.cursor);
      }
    } else {
      byts = (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_0__.concat)(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
}

/***/ }),

/***/ 2042:
/*!**************************************************!*\
  !*** ./node_modules/cborg/esm/lib/byte-utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useBuffer": () => (/* binding */ useBuffer),
/* harmony export */   "asU8A": () => (/* binding */ asU8A),
/* harmony export */   "toString": () => (/* binding */ toString),
/* harmony export */   "fromString": () => (/* binding */ fromString),
/* harmony export */   "fromArray": () => (/* binding */ fromArray),
/* harmony export */   "slice": () => (/* binding */ slice),
/* harmony export */   "concat": () => (/* binding */ concat),
/* harmony export */   "alloc": () => (/* binding */ alloc),
/* harmony export */   "toHex": () => (/* binding */ toHex),
/* harmony export */   "fromHex": () => (/* binding */ fromHex),
/* harmony export */   "compare": () => (/* binding */ compare),
/* harmony export */   "decodeCodePointsArray": () => (/* binding */ decodeCodePointsArray)
/* harmony export */ });
const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === 'function';
const textDecoder = new TextDecoder();
const textEncoder = new TextEncoder();
function isBuffer(buf) {
  return useBuffer && globalThis.Buffer.isBuffer(buf);
}
function asU8A(buf) {
  if (!(buf instanceof Uint8Array)) {
    return Uint8Array.from(buf);
  }
  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;
}
const toString = useBuffer ? (bytes, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);
} : (bytes, start, end) => {
  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
};
const fromString = useBuffer ? string => {
  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);
} : string => {
  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);
};
const fromArray = arr => {
  return Uint8Array.from(arr);
};
const slice = useBuffer ? (bytes, start, end) => {
  if (isBuffer(bytes)) {
    return new Uint8Array(bytes.subarray(start, end));
  }
  return bytes.slice(start, end);
} : (bytes, start, end) => {
  return bytes.slice(start, end);
};
const concat = useBuffer ? (chunks, length) => {
  chunks = chunks.map(c => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length));
} : (chunks, length) => {
  const out = new Uint8Array(length);
  let off = 0;
  for (let b of chunks) {
    if (off + b.length > out.length) {
      b = b.subarray(0, out.length - off);
    }
    out.set(b, off);
    off += b.length;
  }
  return out;
};
const alloc = useBuffer ? size => {
  return globalThis.Buffer.allocUnsafe(size);
} : size => {
  return new Uint8Array(size);
};
const toHex = useBuffer ? d => {
  if (typeof d === 'string') {
    return d;
  }
  return globalThis.Buffer.from(toBytes(d)).toString('hex');
} : d => {
  if (typeof d === 'string') {
    return d;
  }
  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${ p }${ c.toString(16).padStart(2, '0') }`, '');
};
const fromHex = useBuffer ? hex => {
  if (hex instanceof Uint8Array) {
    return hex;
  }
  return globalThis.Buffer.from(hex, 'hex');
} : hex => {
  if (hex instanceof Uint8Array) {
    return hex;
  }
  if (!hex.length) {
    return new Uint8Array(0);
  }
  return new Uint8Array(hex.split('').map((c, i, d) => i % 2 === 0 ? `0x${ c }${ d[i + 1] }` : '').filter(Boolean).map(e => parseInt(e, 16)));
};
function toBytes(obj) {
  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {
    return obj;
  }
  if (obj instanceof ArrayBuffer) {
    return new Uint8Array(obj);
  }
  if (ArrayBuffer.isView(obj)) {
    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);
  }
  throw new Error('Unknown type, must be binary type');
}
function compare(b1, b2) {
  if (isBuffer(b1) && isBuffer(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string, units = Infinity) {
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function utf8Slice(buf, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
      case 1:
        if (firstByte < 128) {
          codePoint = firstByte;
        }
        break;
      case 2:
        secondByte = buf[offset + 1];
        if ((secondByte & 192) === 128) {
          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
          if (tempCodePoint > 127) {
            codePoint = tempCodePoint;
          }
        }
        break;
      case 3:
        secondByte = buf[offset + 1];
        thirdByte = buf[offset + 2];
        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
            codePoint = tempCodePoint;
          }
        }
        break;
      case 4:
        secondByte = buf[offset + 1];
        thirdByte = buf[offset + 2];
        fourthByte = buf[offset + 3];
        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
            codePoint = tempCodePoint;
          }
        }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = '';
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

/***/ }),

/***/ 5590:
/*!**********************************************!*\
  !*** ./node_modules/cborg/esm/lib/common.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeErrPrefix": () => (/* binding */ decodeErrPrefix),
/* harmony export */   "encodeErrPrefix": () => (/* binding */ encodeErrPrefix),
/* harmony export */   "uintMinorPrefixBytes": () => (/* binding */ uintMinorPrefixBytes),
/* harmony export */   "assertEnoughData": () => (/* binding */ assertEnoughData)
/* harmony export */ });
const decodeErrPrefix = 'CBOR decode error:';
const encodeErrPrefix = 'CBOR encode error:';
const uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${ decodeErrPrefix } not enough data for type`);
  }
}


/***/ }),

/***/ 1287:
/*!**********************************************!*\
  !*** ./node_modules/cborg/esm/lib/decode.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tokeniser": () => (/* binding */ Tokeniser),
/* harmony export */   "tokensToObject": () => (/* binding */ tokensToObject),
/* harmony export */   "decode": () => (/* binding */ decode)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ 5590);
/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./token.js */ 9787);
/* harmony import */ var _jump_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jump.js */ 3741);



const defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
class Tokeniser {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = _jump_js__WEBPACK_IMPORTED_MODULE_2__.quick[byt];
    if (token === undefined) {
      const decoder = _jump_js__WEBPACK_IMPORTED_MODULE_2__.jump[byt];
      if (!decoder) {
        throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix } no decoder for major type ${ byt >>> 5 } (byte 0x${ byt.toString(16).padStart(2, '0') })`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
}
const DONE = Symbol.for('DONE');
const BREAK = Symbol.for('BREAK');
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix } got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix } found array but not enough entries (got ${ i }, expected ${ token.value })`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? undefined : {};
  const m = useMaps ? new Map() : undefined;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix } got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix } found map but not enough entries (got ${ i } [no key], expected ${ token.value })`);
    }
    if (useMaps !== true && typeof key !== 'string') {
      throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix } non-string keys not supported (got ${ typeof key })`);
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix } found map but not enough entries (got ${ i } [no value], expected ${ token.value })`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === _token_js__WEBPACK_IMPORTED_MODULE_1__.Type["break"]) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === _token_js__WEBPACK_IMPORTED_MODULE_1__.Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === _token_js__WEBPACK_IMPORTED_MODULE_1__.Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === _token_js__WEBPACK_IMPORTED_MODULE_1__.Type.tag) {
    if (options.tags && typeof options.tags[token.value] === 'function') {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix } tag not supported (${ token.value })`);
  }
  throw new Error('unsupported');
}
function decode(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix } data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix } did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix } got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix } too many terminals, data makes no sense`);
  }
  return decoded;
}


/***/ }),

/***/ 7463:
/*!**********************************************!*\
  !*** ./node_modules/cborg/esm/lib/encode.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "objectToTokens": () => (/* binding */ objectToTokens),
/* harmony export */   "encode": () => (/* binding */ encode),
/* harmony export */   "encodeCustom": () => (/* binding */ encodeCustom),
/* harmony export */   "Ref": () => (/* binding */ Ref)
/* harmony export */ });
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ 579);
/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./token.js */ 9787);
/* harmony import */ var _bl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bl.js */ 1796);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common.js */ 5590);
/* harmony import */ var _jump_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jump.js */ 3741);
/* harmony import */ var _byte_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./byte-utils.js */ 2042);
/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./0uint.js */ 5580);
/* harmony import */ var _1negint_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./1negint.js */ 3929);
/* harmony import */ var _2bytes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./2bytes.js */ 2887);
/* harmony import */ var _3string_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./3string.js */ 768);
/* harmony import */ var _4array_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./4array.js */ 8278);
/* harmony import */ var _5map_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./5map.js */ 9283);
/* harmony import */ var _6tag_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./6tag.js */ 2428);
/* harmony import */ var _7float_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./7float.js */ 3851);














const defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken: _jump_js__WEBPACK_IMPORTED_MODULE_4__.quickEncodeToken
};
const cborEncoders = [];
cborEncoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.uint.major] = _0uint_js__WEBPACK_IMPORTED_MODULE_6__.encodeUint;
cborEncoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.negint.major] = _1negint_js__WEBPACK_IMPORTED_MODULE_7__.encodeNegint;
cborEncoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.bytes.major] = _2bytes_js__WEBPACK_IMPORTED_MODULE_8__.encodeBytes;
cborEncoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.string.major] = _3string_js__WEBPACK_IMPORTED_MODULE_9__.encodeString;
cborEncoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.array.major] = _4array_js__WEBPACK_IMPORTED_MODULE_10__.encodeArray;
cborEncoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.map.major] = _5map_js__WEBPACK_IMPORTED_MODULE_11__.encodeMap;
cborEncoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.tag.major] = _6tag_js__WEBPACK_IMPORTED_MODULE_12__.encodeTag;
cborEncoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.float.major] = _7float_js__WEBPACK_IMPORTED_MODULE_13__.encodeFloat;
const buf = new _bl_js__WEBPACK_IMPORTED_MODULE_2__.Bl();
class Ref {
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_3__.encodeErrPrefix } object contains circular references`);
    }
    return new Ref(obj, stack);
  }
}
const simpleTokens = {
  null: new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type["null"], null),
  undefined: new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.undefined, undefined),
  true: new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type["true"], true),
  false: new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type["false"], false),
  emptyArray: new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.array, 0),
  emptyMap: new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.map, 0)
};
const typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.float, obj);
    } else if (obj >= 0) {
      return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.uint, obj);
    } else {
      return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.uint, obj);
    } else {
      return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type["break"])
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.array, obj.length),
        entries,
        new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type["break"])
      ];
    }
    return [
      new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== 'Object';
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length = isMap ? obj.size : keys.length;
    if (!length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type["break"])
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.map, length),
        entries,
        new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type["break"])
      ];
    }
    return [
      new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.map, length),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {
  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.is)(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === 'function') {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_3__.encodeErrPrefix } unsupported type: ${ typ }`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');
  }
  return tcmp;
}
function tokensToEncoded(buf, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options);
      const buf = new _bl_js__WEBPACK_IMPORTED_MODULE_2__.Bl(size);
      encoder(buf, tokens, options);
      if (buf.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);
      }
      return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_5__.asU8A)(buf.chunks[0]);
    }
  }
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}


/***/ }),

/***/ 579:
/*!******************************************!*\
  !*** ./node_modules/cborg/esm/lib/is.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "is": () => (/* binding */ is)
/* harmony export */ });
const typeofs = [
  'string',
  'number',
  'bigint',
  'symbol'
];
const objectTypeNames = [
  'Function',
  'Generator',
  'AsyncGenerator',
  'GeneratorFunction',
  'AsyncGeneratorFunction',
  'AsyncFunction',
  'Observable',
  'Array',
  'Buffer',
  'Object',
  'RegExp',
  'Date',
  'Error',
  'Map',
  'Set',
  'WeakMap',
  'WeakSet',
  'ArrayBuffer',
  'SharedArrayBuffer',
  'DataView',
  'Promise',
  'URL',
  'HTMLElement',
  'Int8Array',
  'Uint8Array',
  'Uint8ClampedArray',
  'Int16Array',
  'Uint16Array',
  'Int32Array',
  'Uint32Array',
  'Float32Array',
  'Float64Array',
  'BigInt64Array',
  'BigUint64Array'
];
function is(value) {
  if (value === null) {
    return 'null';
  }
  if (value === undefined) {
    return 'undefined';
  }
  if (value === true || value === false) {
    return 'boolean';
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === 'function') {
    return 'Function';
  }
  if (Array.isArray(value)) {
    return 'Array';
  }
  if (isBuffer(value)) {
    return 'Buffer';
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return 'Object';
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return undefined;
}

/***/ }),

/***/ 3741:
/*!********************************************!*\
  !*** ./node_modules/cborg/esm/lib/jump.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "jump": () => (/* binding */ jump),
/* harmony export */   "quick": () => (/* binding */ quick),
/* harmony export */   "quickEncodeToken": () => (/* binding */ quickEncodeToken)
/* harmony export */ });
/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ 9787);
/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./0uint.js */ 5580);
/* harmony import */ var _1negint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./1negint.js */ 3929);
/* harmony import */ var _2bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./2bytes.js */ 2887);
/* harmony import */ var _3string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./3string.js */ 768);
/* harmony import */ var _4array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./4array.js */ 8278);
/* harmony import */ var _5map_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./5map.js */ 9283);
/* harmony import */ var _6tag_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./6tag.js */ 2428);
/* harmony import */ var _7float_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./7float.js */ 3851);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./common.js */ 5590);
/* harmony import */ var _byte_utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./byte-utils.js */ 2042);











function invalidMinor(data, pos, minor) {
  throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_9__.decodeErrPrefix } encountered invalid minor (${ minor }) for major ${ data[pos] >>> 5 }`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${ _common_js__WEBPACK_IMPORTED_MODULE_9__.decodeErrPrefix } ${ msg }`);
  };
}
const jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.decodeUint8;
jump[25] = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.decodeUint16;
jump[26] = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.decodeUint32;
jump[27] = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = _1negint_js__WEBPACK_IMPORTED_MODULE_2__.decodeNegint8;
jump[57] = _1negint_js__WEBPACK_IMPORTED_MODULE_2__.decodeNegint16;
jump[58] = _1negint_js__WEBPACK_IMPORTED_MODULE_2__.decodeNegint32;
jump[59] = _1negint_js__WEBPACK_IMPORTED_MODULE_2__.decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = _2bytes_js__WEBPACK_IMPORTED_MODULE_3__.decodeBytesCompact;
}
jump[88] = _2bytes_js__WEBPACK_IMPORTED_MODULE_3__.decodeBytes8;
jump[89] = _2bytes_js__WEBPACK_IMPORTED_MODULE_3__.decodeBytes16;
jump[90] = _2bytes_js__WEBPACK_IMPORTED_MODULE_3__.decodeBytes32;
jump[91] = _2bytes_js__WEBPACK_IMPORTED_MODULE_3__.decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer('indefinite length bytes/strings are not supported');
for (let i = 96; i <= 119; i++) {
  jump[i] = _3string_js__WEBPACK_IMPORTED_MODULE_4__.decodeStringCompact;
}
jump[120] = _3string_js__WEBPACK_IMPORTED_MODULE_4__.decodeString8;
jump[121] = _3string_js__WEBPACK_IMPORTED_MODULE_4__.decodeString16;
jump[122] = _3string_js__WEBPACK_IMPORTED_MODULE_4__.decodeString32;
jump[123] = _3string_js__WEBPACK_IMPORTED_MODULE_4__.decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer('indefinite length bytes/strings are not supported');
for (let i = 128; i <= 151; i++) {
  jump[i] = _4array_js__WEBPACK_IMPORTED_MODULE_5__.decodeArrayCompact;
}
jump[152] = _4array_js__WEBPACK_IMPORTED_MODULE_5__.decodeArray8;
jump[153] = _4array_js__WEBPACK_IMPORTED_MODULE_5__.decodeArray16;
jump[154] = _4array_js__WEBPACK_IMPORTED_MODULE_5__.decodeArray32;
jump[155] = _4array_js__WEBPACK_IMPORTED_MODULE_5__.decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = _4array_js__WEBPACK_IMPORTED_MODULE_5__.decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = _5map_js__WEBPACK_IMPORTED_MODULE_6__.decodeMapCompact;
}
jump[184] = _5map_js__WEBPACK_IMPORTED_MODULE_6__.decodeMap8;
jump[185] = _5map_js__WEBPACK_IMPORTED_MODULE_6__.decodeMap16;
jump[186] = _5map_js__WEBPACK_IMPORTED_MODULE_6__.decodeMap32;
jump[187] = _5map_js__WEBPACK_IMPORTED_MODULE_6__.decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = _5map_js__WEBPACK_IMPORTED_MODULE_6__.decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = _6tag_js__WEBPACK_IMPORTED_MODULE_7__.decodeTagCompact;
}
jump[216] = _6tag_js__WEBPACK_IMPORTED_MODULE_7__.decodeTag8;
jump[217] = _6tag_js__WEBPACK_IMPORTED_MODULE_7__.decodeTag16;
jump[218] = _6tag_js__WEBPACK_IMPORTED_MODULE_7__.decodeTag32;
jump[219] = _6tag_js__WEBPACK_IMPORTED_MODULE_7__.decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer('simple values are not supported');
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = _7float_js__WEBPACK_IMPORTED_MODULE_8__.decodeUndefined;
jump[248] = errorer('simple values are not supported');
jump[249] = _7float_js__WEBPACK_IMPORTED_MODULE_8__.decodeFloat16;
jump[250] = _7float_js__WEBPACK_IMPORTED_MODULE_8__.decodeFloat32;
jump[251] = _7float_js__WEBPACK_IMPORTED_MODULE_8__.decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = _7float_js__WEBPACK_IMPORTED_MODULE_8__.decodeBreak;
const quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint, i, 1);
}
quick[64] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.bytes, new Uint8Array(0), 1);
quick[96] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.string, '', 1);
quick[128] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.array, 0, 1);
quick[160] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.map, 0, 1);
quick[244] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type["false"], false, 1);
quick[245] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type["true"], true, 1);
quick[246] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type["null"], null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
  case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type["false"]:
    return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([244]);
  case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type["true"]:
    return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([245]);
  case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type["null"]:
    return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([246]);
  case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.bytes:
    if (!token.value.length) {
      return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([64]);
    }
    return;
  case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.string:
    if (token.value === '') {
      return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([96]);
    }
    return;
  case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.array:
    if (token.value === 0) {
      return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([128]);
    }
    return;
  case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.map:
    if (token.value === 0) {
      return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([160]);
    }
    return;
  case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.uint:
    if (token.value < 24) {
      return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([Number(token.value)]);
    }
    return;
  case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint:
    if (token.value >= -24) {
      return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([31 - Number(token.value)]);
    }
  }
}

/***/ }),

/***/ 9787:
/*!*********************************************!*\
  !*** ./node_modules/cborg/esm/lib/token.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Type": () => (/* binding */ Type),
/* harmony export */   "Token": () => (/* binding */ Token)
/* harmony export */ });
class Type {
  constructor(major, name, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${ this.major }].${ this.name }`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
}
Type.uint = new Type(0, 'uint', true);
Type.negint = new Type(1, 'negint', true);
Type.bytes = new Type(2, 'bytes', true);
Type.string = new Type(3, 'string', true);
Type.array = new Type(4, 'array', false);
Type.map = new Type(5, 'map', false);
Type.tag = new Type(6, 'tag', false);
Type.float = new Type(7, 'float', true);
Type.false = new Type(7, 'false', true);
Type.true = new Type(7, 'true', true);
Type.null = new Type(7, 'null', true);
Type.undefined = new Type(7, 'undefined', true);
Type.break = new Type(7, 'break', true);
class Token {
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = undefined;
  }
  toString() {
    return `Token[${ this.type }].${ this.value }`;
  }
}


/***/ }),

/***/ 6642:
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/esm/src/agent.browser.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => {
});

/***/ }),

/***/ 657:
/*!*********************************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/esm/src/files/normalise-content.browser.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normaliseContent": () => (/* binding */ normaliseContent)
/* harmony export */ });
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ 2114);
/* harmony import */ var it_peekable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-peekable */ 8132);
/* harmony import */ var browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! browser-readablestream-to-it */ 6154);
/* harmony import */ var it_all__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-all */ 1303);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ 8873);





async function normaliseContent(input) {
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBytes)(input)) {
    return new Blob([input]);
  }
  if (typeof input === 'string' || input instanceof String) {
    return new Blob([input.toString()]);
  }
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBlob)(input)) {
    return input;
  }
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isReadableStream)(input)) {
    input = browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_2__(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = it_peekable__WEBPACK_IMPORTED_MODULE_1__(input);
    const {value, done} = await peekable.peek();
    if (done) {
      return itToBlob(peekable);
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return new Blob([Uint8Array.from(await it_all__WEBPACK_IMPORTED_MODULE_3__(peekable))]);
    }
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBytes)(value) || typeof value === 'string' || value instanceof String) {
      return itToBlob(peekable);
    }
  }
  throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`Unexpected input: ${ input }`), 'ERR_UNEXPECTED_INPUT');
}
async function itToBlob(stream) {
  const parts = [];
  for await (const chunk of stream) {
    parts.push(chunk);
  }
  return new Blob(parts);
}

/***/ }),

/***/ 7507:
/*!*******************************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/esm/src/files/normalise-input.browser.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normaliseInput": () => (/* binding */ normaliseInput)
/* harmony export */ });
/* harmony import */ var _normalise_content_browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normalise-content.browser.js */ 657);
/* harmony import */ var _normalise_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normalise.js */ 2279);


function normaliseInput(input) {
  return (0,_normalise_js__WEBPACK_IMPORTED_MODULE_1__.normalise)(input, _normalise_content_browser_js__WEBPACK_IMPORTED_MODULE_0__.normaliseContent);
}

/***/ }),

/***/ 2279:
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/esm/src/files/normalise.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normalise": () => (/* binding */ normalise)
/* harmony export */ });
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ 2114);
/* harmony import */ var browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! browser-readablestream-to-it */ 6154);
/* harmony import */ var it_peekable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-peekable */ 8132);
/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-map */ 2121);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ 8873);
/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ipfs-unixfs */ 4427);






async function* normalise(input, normaliseContent) {
  if (input === null || input === undefined) {
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`Unexpected input: ${ input }`), 'ERR_UNEXPECTED_INPUT');
  }
  if (typeof input === 'string' || input instanceof String) {
    yield toFileObject(input.toString(), normaliseContent);
    return;
  }
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBytes)(input) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBlob)(input)) {
    yield toFileObject(input, normaliseContent);
    return;
  }
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isReadableStream)(input)) {
    input = browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_1__(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = it_peekable__WEBPACK_IMPORTED_MODULE_2__(input);
    const {value, done} = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBytes)(value)) {
      yield toFileObject(peekable, normaliseContent);
      return;
    }
    if (value._readableState) {
      yield* it_map__WEBPACK_IMPORTED_MODULE_3__(peekable, value => toFileObject({ content: value }, normaliseContent));
      return;
    }
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isFileObject)(value) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isBlob)(value) || typeof value === 'string' || value instanceof String) {
      yield* it_map__WEBPACK_IMPORTED_MODULE_3__(peekable, value => toFileObject(value, normaliseContent));
      return;
    }
    if (value[Symbol.iterator] || value[Symbol.asyncIterator] || (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isReadableStream)(value)) {
      yield* it_map__WEBPACK_IMPORTED_MODULE_3__(peekable, value => toFileObject(value, normaliseContent));
      return;
    }
  }
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isFileObject)(input)) {
    yield toFileObject(input, normaliseContent);
    return;
  }
  throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');
}
async function toFileObject(input, normaliseContent) {
  const {path, mode, mtime, content} = input;
  const file = {
    path: path || '',
    mode: (0,ipfs_unixfs__WEBPACK_IMPORTED_MODULE_5__.parseMode)(mode),
    mtime: (0,ipfs_unixfs__WEBPACK_IMPORTED_MODULE_5__.parseMtime)(mtime)
  };
  if (content) {
    file.content = await normaliseContent(content);
  } else if (!path) {
    file.content = await normaliseContent(input);
  }
  return file;
}

/***/ }),

/***/ 8873:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/esm/src/files/utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isBytes": () => (/* binding */ isBytes),
/* harmony export */   "isBlob": () => (/* binding */ isBlob),
/* harmony export */   "isFileObject": () => (/* binding */ isFileObject),
/* harmony export */   "isReadableStream": () => (/* binding */ isReadableStream)
/* harmony export */ });
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob(obj) {
  return obj.constructor && (obj.constructor.name === 'Blob' || obj.constructor.name === 'File') && typeof obj.stream === 'function';
}
function isFileObject(obj) {
  return typeof obj === 'object' && (obj.path || obj.content);
}
const isReadableStream = value => value && typeof value.getReader === 'function';

/***/ }),

/***/ 5301:
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/esm/src/mode-to-string.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "modeToString": () => (/* binding */ modeToString)
/* harmony export */ });
function modeToString(mode) {
  if (mode == null) {
    return undefined;
  }
  if (typeof mode === 'string') {
    return mode;
  }
  return mode.toString(8).padStart(4, '0');
}

/***/ }),

/***/ 6255:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/esm/src/multibases.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Multibases": () => (/* binding */ Multibases)
/* harmony export */ });
const LOAD_BASE = name => Promise.reject(new Error(`No base found for "${ name }"`));
class Multibases {
  constructor(options) {
    this._basesByName = {};
    this._basesByPrefix = {};
    this._loadBase = options.loadBase || LOAD_BASE;
    for (const base of options.bases) {
      this.addBase(base);
    }
  }
  addBase(base) {
    if (this._basesByName[base.name] || this._basesByPrefix[base.prefix]) {
      throw new Error(`Codec already exists for codec "${ base.name }"`);
    }
    this._basesByName[base.name] = base;
    this._basesByPrefix[base.prefix] = base;
  }
  removeBase(base) {
    delete this._basesByName[base.name];
    delete this._basesByPrefix[base.prefix];
  }
  async getBase(nameOrPrefix) {
    if (this._basesByName[nameOrPrefix]) {
      return this._basesByName[nameOrPrefix];
    }
    if (this._basesByPrefix[nameOrPrefix]) {
      return this._basesByPrefix[nameOrPrefix];
    }
    const base = await this._loadBase(nameOrPrefix);
    if (this._basesByName[base.name] == null && this._basesByPrefix[base.prefix] == null) {
      this.addBase(base);
    }
    return base;
  }
  listBases() {
    return Object.values(this._basesByName);
  }
}

/***/ }),

/***/ 3428:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/esm/src/multicodecs.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Multicodecs": () => (/* binding */ Multicodecs)
/* harmony export */ });
const LOAD_CODEC = codeOrName => Promise.reject(new Error(`No codec found for "${ codeOrName }"`));
class Multicodecs {
  constructor(options) {
    this._codecsByName = {};
    this._codecsByCode = {};
    this._loadCodec = options.loadCodec || LOAD_CODEC;
    for (const codec of options.codecs) {
      this.addCodec(codec);
    }
  }
  addCodec(codec) {
    if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
      throw new Error(`Resolver already exists for codec "${ codec.name }"`);
    }
    this._codecsByName[codec.name] = codec;
    this._codecsByCode[codec.code] = codec;
  }
  removeCodec(codec) {
    delete this._codecsByName[codec.name];
    delete this._codecsByCode[codec.code];
  }
  async getCodec(code) {
    const table = typeof code === 'string' ? this._codecsByName : this._codecsByCode;
    if (table[code]) {
      return table[code];
    }
    const codec = await this._loadCodec(code);
    if (table[code] == null) {
      this.addCodec(codec);
    }
    return codec;
  }
  listCodecs() {
    return Object.values(this._codecsByName);
  }
}

/***/ }),

/***/ 4409:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/esm/src/multihashes.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Multihashes": () => (/* binding */ Multihashes)
/* harmony export */ });
const LOAD_HASHER = codeOrName => Promise.reject(new Error(`No hasher found for "${ codeOrName }"`));
class Multihashes {
  constructor(options) {
    this._hashersByName = {};
    this._hashersByCode = {};
    this._loadHasher = options.loadHasher || LOAD_HASHER;
    for (const hasher of options.hashers) {
      this.addHasher(hasher);
    }
  }
  addHasher(hasher) {
    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
      throw new Error(`Resolver already exists for codec "${ hasher.name }"`);
    }
    this._hashersByName[hasher.name] = hasher;
    this._hashersByCode[hasher.code] = hasher;
  }
  removeHasher(hasher) {
    delete this._hashersByName[hasher.name];
    delete this._hashersByCode[hasher.code];
  }
  async getHasher(code) {
    const table = typeof code === 'string' ? this._hashersByName : this._hashersByCode;
    if (table[code]) {
      return table[code];
    }
    const hasher = await this._loadHasher(code);
    if (table[code] == null) {
      this.addHasher(hasher);
    }
    return hasher;
  }
  listHashers() {
    return Object.values(this._hashersByName);
  }
}

/***/ }),

/***/ 8126:
/*!***************************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/esm/src/multipart-request.browser.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "multipartRequest": () => (/* binding */ multipartRequest)
/* harmony export */ });
/* harmony import */ var _files_normalise_input_browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./files/normalise-input.browser.js */ 7507);
/* harmony import */ var _mode_to_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mode-to-string.js */ 5301);


async function multipartRequest(source, abortController, headers = {}) {
  const parts = [];
  const formData = new FormData();
  let index = 0;
  let total = 0;
  for await (const {content, path, mode, mtime} of (0,_files_normalise_input_browser_js__WEBPACK_IMPORTED_MODULE_0__.normaliseInput)(source)) {
    let fileSuffix = '';
    const type = content ? 'file' : 'dir';
    if (index > 0) {
      fileSuffix = `-${ index }`;
    }
    let fieldName = type + fileSuffix;
    const qs = [];
    if (mode !== null && mode !== undefined) {
      qs.push(`mode=${ (0,_mode_to_string_js__WEBPACK_IMPORTED_MODULE_1__.modeToString)(mode) }`);
    }
    if (mtime != null) {
      const {secs, nsecs} = mtime;
      qs.push(`mtime=${ secs }`);
      if (nsecs != null) {
        qs.push(`mtime-nsecs=${ nsecs }`);
      }
    }
    if (qs.length) {
      fieldName = `${ fieldName }?${ qs.join('&') }`;
    }
    if (content) {
      formData.set(fieldName, content, path != null ? encodeURIComponent(path) : undefined);
      const end = total + content.size;
      parts.push({
        name: path,
        start: total,
        end
      });
      total = end;
    } else if (path != null) {
      formData.set(fieldName, new File([''], encodeURIComponent(path), { type: 'application/x-directory' }));
    } else {
      throw new Error('path or content or both must be set');
    }
    index++;
  }
  return {
    total,
    parts,
    headers,
    body: formData
  };
}

/***/ }),

/***/ 6127:
/*!**********************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/esm/src/pins/normalise-input.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normaliseInput": () => (/* binding */ normaliseInput)
/* harmony export */ });
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ 2114);
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ 1362);


async function* normaliseInput(input) {
  if (input === null || input === undefined) {
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`Unexpected input: ${ input }`), 'ERR_UNEXPECTED_INPUT');
  }
  const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.asCID(input);
  if (cid) {
    yield toPin({ cid });
    return;
  }
  if (input instanceof String || typeof input === 'string') {
    yield toPin({ path: input });
    return;
  }
  if (input.cid != null || input.path != null) {
    return yield toPin(input);
  }
  if (Symbol.iterator in input) {
    const iterator = input[Symbol.iterator]();
    const first = iterator.next();
    if (first.done)
      return iterator;
    if (multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.asCID(first.value) || first.value instanceof String || typeof first.value === 'string') {
      yield toPin({ cid: first.value });
      for (const cid of iterator) {
        yield toPin({ cid });
      }
      return;
    }
    if (first.value.cid != null || first.value.path != null) {
      yield toPin(first.value);
      for (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');
  }
  if (Symbol.asyncIterator in input) {
    const iterator = input[Symbol.asyncIterator]();
    const first = await iterator.next();
    if (first.done)
      return iterator;
    if (multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.asCID(first.value) || first.value instanceof String || typeof first.value === 'string') {
      yield toPin({ cid: first.value });
      for await (const cid of iterator) {
        yield toPin({ cid });
      }
      return;
    }
    if (first.value.cid != null || first.value.path != null) {
      yield toPin(first.value);
      for await (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');
  }
  throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');
}
function toPin(input) {
  const path = input.cid || `${ input.path }`;
  if (!path) {
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Unexpected input: Please path either a CID or an IPFS path'), 'ERR_UNEXPECTED_INPUT');
  }
  const pin = {
    path,
    recursive: input.recursive !== false
  };
  if (input.metadata != null) {
    pin.metadata = input.metadata;
  }
  return pin;
}

/***/ }),

/***/ 3627:
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-core-utils/esm/src/to-url-string.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toUrlString": () => (/* binding */ toUrlString)
/* harmony export */ });
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiaddr */ 6584);
/* harmony import */ var multiaddr_to_uri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiaddr-to-uri */ 5700);


function toUrlString(url) {
  try {
    url = multiaddr_to_uri__WEBPACK_IMPORTED_MODULE_1__(new multiaddr__WEBPACK_IMPORTED_MODULE_0__.Multiaddr(url));
  } catch (err) {
  }
  url = url.toString();
  return url;
}

/***/ }),

/***/ 1987:
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/add-all.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddAll": () => (/* binding */ createAddAll)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ 8126);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ 6117);
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/abort-signal.js */ 13);
/* harmony import */ var native_abort_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! native-abort-controller */ 5353);







const createAddAll = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  async function* addAll(source, options = {}) {
    const controller = new native_abort_controller__WEBPACK_IMPORTED_MODULE_6__.AbortController();
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_5__.abortSignal)(controller.signal, options.signal);
    const {headers, body, total, parts} = await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_3__.multipartRequest)(source, controller, options.headers);
    const [progressFn, onUploadProgress] = typeof options.progress === 'function' ? createProgressHandler(total, parts, options.progress) : [
      undefined,
      undefined
    ];
    const res = await api.post('add', {
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_4__.toUrlSearchParams)({
        'stream-channels': true,
        ...options,
        progress: Boolean(progressFn)
      }),
      onUploadProgress,
      signal,
      headers,
      body
    });
    for await (let file of res.ndjson()) {
      file = (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamel)(file);
      if (file.hash !== undefined) {
        yield toCoreInterface(file);
      } else if (progressFn) {
        progressFn(file.bytes || 0, file.name);
      }
    }
  }
  return addAll;
});
const createProgressHandler = (total, parts, progress) => parts ? [
  undefined,
  createOnUploadProgress(total, parts, progress)
] : [
  progress,
  undefined
];
const createOnUploadProgress = (size, parts, progress) => {
  let index = 0;
  const count = parts.length;
  return ({loaded, total}) => {
    const position = Math.floor(loaded / total * size);
    while (index < count) {
      const {start, end, name} = parts[index];
      if (position < end) {
        progress(position - start, name);
        break;
      } else {
        progress(end - start, name);
        index += 1;
      }
    }
  };
};
function toCoreInterface({name, hash, size, mode, mtime, mtimeNsecs}) {
  const output = {
    path: name,
    cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(hash),
    size: parseInt(size)
  };
  if (mode != null) {
    output.mode = parseInt(mode, 8);
  }
  if (mtime != null) {
    output.mtime = {
      secs: mtime,
      nsecs: mtimeNsecs || 0
    };
  }
  return output;
}

/***/ }),

/***/ 7563:
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/add.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAdd": () => (/* binding */ createAdd)
/* harmony export */ });
/* harmony import */ var _add_all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add-all.js */ 1987);
/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-last */ 3093);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/configure.js */ 5508);



function createAdd(options) {
  const all = (0,_add_all_js__WEBPACK_IMPORTED_MODULE_0__.createAddAll)(options);
  return (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(() => {
    async function add(input, options = {}) {
      return await it_last__WEBPACK_IMPORTED_MODULE_1__(all(input, options));
    }
    return add;
  })(options);
}

/***/ }),

/***/ 4408:
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/bitswap/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createBitswap": () => (/* binding */ createBitswap)
/* harmony export */ });
/* harmony import */ var _wantlist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wantlist.js */ 601);
/* harmony import */ var _wantlist_for_peer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wantlist-for-peer.js */ 7521);
/* harmony import */ var _stat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stat.js */ 7502);
/* harmony import */ var _unwant_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./unwant.js */ 3979);




function createBitswap(config) {
  return {
    wantlist: (0,_wantlist_js__WEBPACK_IMPORTED_MODULE_0__.createWantlist)(config),
    wantlistForPeer: (0,_wantlist_for_peer_js__WEBPACK_IMPORTED_MODULE_1__.createWantlistForPeer)(config),
    unwant: (0,_unwant_js__WEBPACK_IMPORTED_MODULE_3__.createUnwant)(config),
    stat: (0,_stat_js__WEBPACK_IMPORTED_MODULE_2__.createStat)(config)
  };
}

/***/ }),

/***/ 7502:
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/bitswap/stat.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStat": () => (/* binding */ createStat)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createStat = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function stat(options = {}) {
    const res = await api.post('bitswap/stat', {
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      signal: options.signal,
      headers: options.headers
    });
    return toCoreInterface(await res.json());
  }
  return stat;
});
function toCoreInterface(res) {
  return {
    provideBufLen: res.ProvideBufLen,
    wantlist: (res.Wantlist || []).map(k => multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(k['/'])),
    peers: res.Peers || [],
    blocksReceived: BigInt(res.BlocksReceived),
    dataReceived: BigInt(res.DataReceived),
    blocksSent: BigInt(res.BlocksSent),
    dataSent: BigInt(res.DataSent),
    dupBlksReceived: BigInt(res.DupBlksReceived),
    dupDataReceived: BigInt(res.DupDataReceived)
  };
}

/***/ }),

/***/ 3979:
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/bitswap/unwant.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createUnwant": () => (/* binding */ createUnwant)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createUnwant = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function unwant(cid, options = {}) {
    const res = await api.post('bitswap/unwant', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return res.json();
  }
  return unwant;
});

/***/ }),

/***/ 7521:
/*!****************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/bitswap/wantlist-for-peer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createWantlistForPeer": () => (/* binding */ createWantlistForPeer)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createWantlistForPeer = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function wantlistForPeer(peerId, options = {}) {
    const res = await (await api.post('bitswap/wantlist', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        ...options,
        peer: peerId.toString()
      }),
      headers: options.headers
    })).json();
    return (res.Keys || []).map(k => multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(k['/']));
  }
  return wantlistForPeer;
});

/***/ }),

/***/ 601:
/*!*******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/bitswap/wantlist.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createWantlist": () => (/* binding */ createWantlist)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createWantlist = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function wantlist(options = {}) {
    const res = await (await api.post('bitswap/wantlist', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    })).json();
    return (res.Keys || []).map(k => multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(k['/']));
  }
  return wantlist;
});

/***/ }),

/***/ 7509:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/block/get.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGet": () => (/* binding */ createGet)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createGet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function get(cid, options = {}) {
    const res = await api.post('block/get', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return new Uint8Array(await res.arrayBuffer());
  }
  return get;
});

/***/ }),

/***/ 4445:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/block/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createBlock": () => (/* binding */ createBlock)
/* harmony export */ });
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get.js */ 7509);
/* harmony import */ var _put_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./put.js */ 4989);
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rm.js */ 8453);
/* harmony import */ var _stat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stat.js */ 1083);




function createBlock(config) {
  return {
    get: (0,_get_js__WEBPACK_IMPORTED_MODULE_0__.createGet)(config),
    put: (0,_put_js__WEBPACK_IMPORTED_MODULE_1__.createPut)(config),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_2__.createRm)(config),
    stat: (0,_stat_js__WEBPACK_IMPORTED_MODULE_3__.createStat)(config)
  };
}

/***/ }),

/***/ 4989:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/block/put.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPut": () => (/* binding */ createPut)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ 8126);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/abort-signal.js */ 13);
/* harmony import */ var native_abort_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! native-abort-controller */ 5353);






const createPut = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  async function put(data, options = {}) {
    const controller = new native_abort_controller__WEBPACK_IMPORTED_MODULE_5__.AbortController();
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__.abortSignal)(controller.signal, options.signal);
    let res;
    try {
      const response = await api.post('block/put', {
        signal: signal,
        searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)(options),
        ...await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__.multipartRequest)(data, controller, options.headers)
      });
      res = await response.json();
    } catch (err) {
      if (options.format === 'dag-pb') {
        return put(data, {
          ...options,
          format: 'protobuf'
        });
      } else if (options.format === 'dag-cbor') {
        return put(data, {
          ...options,
          format: 'cbor'
        });
      }
      throw err;
    }
    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(res.Key);
  }
  return put;
});

/***/ }),

/***/ 8453:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/block/rm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": () => (/* binding */ createRm)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createRm = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function* rm(cid, options = {}) {
    if (!Array.isArray(cid)) {
      cid = [cid];
    }
    const res = await api.post('block/rm', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: cid.map(cid => cid.toString()),
        'stream-channels': true,
        ...options
      }),
      headers: options.headers
    });
    for await (const removed of res.ndjson()) {
      yield toCoreInterface(removed);
    }
  }
  return rm;
});
function toCoreInterface(removed) {
  const out = { cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(removed.Hash) };
  if (removed.Error) {
    out.error = new Error(removed.Error);
  }
  return out;
}

/***/ }),

/***/ 1083:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/block/stat.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStat": () => (/* binding */ createStat)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createStat = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function stat(cid, options = {}) {
    const res = await api.post('block/stat', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(data.Key),
      size: data.Size
    };
  }
  return stat;
});

/***/ }),

/***/ 9874:
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/bootstrap/add.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAdd": () => (/* binding */ createAdd)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiaddr */ 6584);



const createAdd = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function add(addr, options = {}) {
    const res = await api.post('bootstrap/add', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const {Peers} = await res.json();
    return { Peers: Peers.map(ma => new multiaddr__WEBPACK_IMPORTED_MODULE_2__.Multiaddr(ma)) };
  }
  return add;
});

/***/ }),

/***/ 8198:
/*!******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/bootstrap/clear.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createClear": () => (/* binding */ createClear)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiaddr */ 6584);



const createClear = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function clear(options = {}) {
    const res = await api.post('bootstrap/rm', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        ...options,
        all: true
      }),
      headers: options.headers
    });
    const {Peers} = await res.json();
    return { Peers: Peers.map(ma => new multiaddr__WEBPACK_IMPORTED_MODULE_2__.Multiaddr(ma)) };
  }
  return clear;
});

/***/ }),

/***/ 5491:
/*!******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/bootstrap/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createBootstrap": () => (/* binding */ createBootstrap)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add.js */ 9874);
/* harmony import */ var _clear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clear.js */ 8198);
/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./list.js */ 9322);
/* harmony import */ var _reset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reset.js */ 3020);
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rm.js */ 4957);





function createBootstrap(config) {
  return {
    add: (0,_add_js__WEBPACK_IMPORTED_MODULE_0__.createAdd)(config),
    clear: (0,_clear_js__WEBPACK_IMPORTED_MODULE_1__.createClear)(config),
    list: (0,_list_js__WEBPACK_IMPORTED_MODULE_2__.createList)(config),
    reset: (0,_reset_js__WEBPACK_IMPORTED_MODULE_3__.createReset)(config),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_4__.createRm)(config)
  };
}

/***/ }),

/***/ 9322:
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/bootstrap/list.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createList": () => (/* binding */ createList)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiaddr */ 6584);



const createList = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function list(options = {}) {
    const res = await api.post('bootstrap/list', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    });
    const {Peers} = await res.json();
    return { Peers: Peers.map(ma => new multiaddr__WEBPACK_IMPORTED_MODULE_2__.Multiaddr(ma)) };
  }
  return list;
});

/***/ }),

/***/ 3020:
/*!******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/bootstrap/reset.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createReset": () => (/* binding */ createReset)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiaddr */ 6584);



const createReset = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function reset(options = {}) {
    const res = await api.post('bootstrap/add', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        ...options,
        default: true
      }),
      headers: options.headers
    });
    const {Peers} = await res.json();
    return { Peers: Peers.map(ma => new multiaddr__WEBPACK_IMPORTED_MODULE_2__.Multiaddr(ma)) };
  }
  return reset;
});

/***/ }),

/***/ 4957:
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/bootstrap/rm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": () => (/* binding */ createRm)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiaddr */ 6584);



const createRm = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function rm(addr, options = {}) {
    const res = await api.post('bootstrap/rm', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const {Peers} = await res.json();
    return { Peers: Peers.map(ma => new multiaddr__WEBPACK_IMPORTED_MODULE_2__.Multiaddr(ma)) };
  }
  return rm;
});

/***/ }),

/***/ 5672:
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/cat.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCat": () => (/* binding */ createCat)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ 6117);


const createCat = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function* cat(path, options = {}) {
    const res = await api.post('cat', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path.toString(),
        ...options
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return cat;
});

/***/ }),

/***/ 6365:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/commands.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCommands": () => (/* binding */ createCommands)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ 6117);


const createCommands = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  const commands = async (options = {}) => {
    const res = await api.post('commands', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    });
    return res.json();
  };
  return commands;
});

/***/ }),

/***/ 5222:
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/config/get-all.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGetAll": () => (/* binding */ createGetAll)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createGetAll = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  const getAll = async (options = {}) => {
    const res = await api.post('config/show', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({ ...options }),
      headers: options.headers
    });
    const data = await res.json();
    return data;
  };
  return getAll;
});

/***/ }),

/***/ 4963:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/config/get.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGet": () => (/* binding */ createGet)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createGet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  const get = async (key, options = {}) => {
    if (!key) {
      throw new Error('key argument is required');
    }
    const res = await api.post('config', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: key,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Value;
  };
  return get;
});

/***/ }),

/***/ 670:
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/config/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createConfig": () => (/* binding */ createConfig)
/* harmony export */ });
/* harmony import */ var _profiles_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./profiles/index.js */ 7107);
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get.js */ 4963);
/* harmony import */ var _get_all_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-all.js */ 5222);
/* harmony import */ var _replace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./replace.js */ 3953);
/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./set.js */ 5217);





function createConfig(config) {
  return {
    getAll: (0,_get_all_js__WEBPACK_IMPORTED_MODULE_2__.createGetAll)(config),
    get: (0,_get_js__WEBPACK_IMPORTED_MODULE_1__.createGet)(config),
    set: (0,_set_js__WEBPACK_IMPORTED_MODULE_4__.createSet)(config),
    replace: (0,_replace_js__WEBPACK_IMPORTED_MODULE_3__.createReplace)(config),
    profiles: (0,_profiles_index_js__WEBPACK_IMPORTED_MODULE_0__.createProfiles)(config)
  };
}

/***/ }),

/***/ 824:
/*!************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/config/profiles/apply.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createApply": () => (/* binding */ createApply)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ 6117);


const createApply = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function apply(profile, options = {}) {
    const res = await api.post('config/profile/apply', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: profile,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      original: data.OldCfg,
      updated: data.NewCfg
    };
  }
  return apply;
});

/***/ }),

/***/ 7107:
/*!************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/config/profiles/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createProfiles": () => (/* binding */ createProfiles)
/* harmony export */ });
/* harmony import */ var _apply_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apply.js */ 824);
/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./list.js */ 3165);


function createProfiles(config) {
  return {
    apply: (0,_apply_js__WEBPACK_IMPORTED_MODULE_0__.createApply)(config),
    list: (0,_list_js__WEBPACK_IMPORTED_MODULE_1__.createList)(config)
  };
}

/***/ }),

/***/ 3165:
/*!***********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/config/profiles/list.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createList": () => (/* binding */ createList)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ 6117);



const createList = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function list(options = {}) {
    const res = await api.post('config/profile/list', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.map(profile => (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(profile));
  }
  return list;
});

/***/ }),

/***/ 3953:
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/config/replace.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createReplace": () => (/* binding */ createReplace)
/* harmony export */ });
/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/from-string */ 2217);
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ 8126);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/abort-signal.js */ 13);
/* harmony import */ var native_abort_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! native-abort-controller */ 5353);






const createReplace = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  const replace = async (config, options = {}) => {
    const controller = new native_abort_controller__WEBPACK_IMPORTED_MODULE_5__.AbortController();
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__.abortSignal)(controller.signal, options.signal);
    const res = await api.post('config/replace', {
      signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)(options),
      ...await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__.multipartRequest)((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__.fromString)(JSON.stringify(config)), controller, options.headers)
    });
    await res.text();
  };
  return replace;
});

/***/ }),

/***/ 5217:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/config/set.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSet": () => (/* binding */ createSet)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createSet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  const set = async (key, value, options = {}) => {
    if (typeof key !== 'string') {
      throw new Error('Invalid key type');
    }
    const params = {
      ...options,
      ...encodeParam(key, value)
    };
    const res = await api.post('config', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(params),
      headers: options.headers
    });
    await res.text();
  };
  return set;
});
const encodeParam = (key, value) => {
  switch (typeof value) {
  case 'boolean':
    return {
      arg: [
        key,
        value.toString()
      ],
      bool: true
    };
  case 'string':
    return {
      arg: [
        key,
        value
      ]
    };
  default:
    return {
      arg: [
        key,
        JSON.stringify(value)
      ],
      json: true
    };
  }
};

/***/ }),

/***/ 6855:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dag/export.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createExport": () => (/* binding */ createExport)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createExport = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function* dagExport(root, options = {}) {
    const res = await api.post('dag/export', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({ arg: root.toString() }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return dagExport;
});

/***/ }),

/***/ 949:
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dag/get.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGet": () => (/* binding */ createGet)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_resolve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/resolve.js */ 1933);
/* harmony import */ var it_first__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-first */ 2262);
/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-last */ 3093);
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! err-code */ 2114);
/* harmony import */ var _block_get_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../block/get.js */ 7509);






const createGet = (codecs, options) => {
  const fn = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)((api, opts) => {
    const getBlock = (0,_block_get_js__WEBPACK_IMPORTED_MODULE_5__.createGet)(opts);
    const get = async (cid, options = {}) => {
      if (options.path) {
        const entry = options.localResolve ? await it_first__WEBPACK_IMPORTED_MODULE_2__((0,_lib_resolve_js__WEBPACK_IMPORTED_MODULE_1__.resolve)(cid, options.path, codecs, getBlock, options)) : await it_last__WEBPACK_IMPORTED_MODULE_3__((0,_lib_resolve_js__WEBPACK_IMPORTED_MODULE_1__.resolve)(cid, options.path, codecs, getBlock, options));
        const result = entry;
        if (!result) {
          throw err_code__WEBPACK_IMPORTED_MODULE_4__(new Error('Not found'), 'ERR_NOT_FOUND');
        }
        return result;
      }
      const codec = await codecs.getCodec(cid.code);
      const block = await getBlock(cid, options);
      const node = codec.decode(block);
      return {
        value: node,
        remainderPath: ''
      };
    };
    return get;
  });
  return fn(options);
};

/***/ }),

/***/ 8699:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dag/import.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createImport": () => (/* binding */ createImport)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/abort-signal.js */ 13);
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ 8126);
/* harmony import */ var native_abort_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! native-abort-controller */ 5353);
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! multiformats/cid */ 1362);






const createImport = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function* dagImport(source, options = {}) {
    const controller = new native_abort_controller__WEBPACK_IMPORTED_MODULE_4__.AbortController();
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_2__.abortSignal)(controller.signal, options.signal);
    const {headers, body} = await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_3__.multipartRequest)(source, controller, options.headers);
    const res = await api.post('dag/import', {
      signal,
      headers,
      body,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({ 'pin-roots': options.pinRoots })
    });
    for await (const {Root} of res.ndjson()) {
      if (Root !== undefined) {
        const {
          Cid: {'/': Cid},
          PinErrorMsg
        } = Root;
        yield {
          root: {
            cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_5__.CID.parse(Cid),
            pinErrorMsg: PinErrorMsg
          }
        };
      }
    }
  }
  return dagImport;
});

/***/ }),

/***/ 6906:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dag/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDag": () => (/* binding */ createDag)
/* harmony export */ });
/* harmony import */ var _export_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./export.js */ 6855);
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get.js */ 949);
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./import.js */ 8699);
/* harmony import */ var _put_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./put.js */ 3641);
/* harmony import */ var _resolve_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resolve.js */ 3769);





function createDag(codecs, config) {
  return {
    export: (0,_export_js__WEBPACK_IMPORTED_MODULE_0__.createExport)(config),
    get: (0,_get_js__WEBPACK_IMPORTED_MODULE_1__.createGet)(codecs, config),
    import: (0,_import_js__WEBPACK_IMPORTED_MODULE_2__.createImport)(config),
    put: (0,_put_js__WEBPACK_IMPORTED_MODULE_3__.createPut)(codecs, config),
    resolve: (0,_resolve_js__WEBPACK_IMPORTED_MODULE_4__.createResolve)(config)
  };
}

/***/ }),

/***/ 3641:
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dag/put.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPut": () => (/* binding */ createPut)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ 8126);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/abort-signal.js */ 13);
/* harmony import */ var native_abort_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! native-abort-controller */ 5353);






const createPut = (codecs, options) => {
  const fn = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
    const put = async (dagNode, options = {}) => {
      const settings = {
        format: 'dag-cbor',
        hashAlg: 'sha2-256',
        inputEnc: 'raw',
        ...options
      };
      const codec = await codecs.getCodec(settings.format);
      const serialized = codec.encode(dagNode);
      const controller = new native_abort_controller__WEBPACK_IMPORTED_MODULE_5__.AbortController();
      const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__.abortSignal)(controller.signal, settings.signal);
      const res = await api.post('dag/put', {
        timeout: settings.timeout,
        signal,
        searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)(settings),
        ...await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_2__.multipartRequest)(serialized, controller, settings.headers)
      });
      const data = await res.json();
      return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(data.Cid['/']);
    };
    return put;
  });
  return fn(options);
};

/***/ }),

/***/ 3769:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dag/resolve.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createResolve": () => (/* binding */ createResolve)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createResolve = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  const resolve = async (ipfsPath, options = {}) => {
    const res = await api.post('dag/resolve', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${ ipfsPath }${ options.path ? `/${ options.path }`.replace(/\/[/]+/g, '/') : '' }`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(data.Cid['/']),
      remainderPath: data.RemPath
    };
  };
  return resolve;
});

/***/ }),

/***/ 6579:
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dht/find-peer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFindPeer": () => (/* binding */ createFindPeer)
/* harmony export */ });
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiaddr */ 6584);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _response_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./response-types.js */ 6208);




const createFindPeer = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function findPeer(peerId, options = {}) {
    const res = await api.post('dht/findpeer', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: peerId,
        ...options
      }),
      headers: options.headers
    });
    for await (const data of res.ndjson()) {
      if (data.Type === _response_types_js__WEBPACK_IMPORTED_MODULE_3__.FinalPeer && data.Responses) {
        const {ID, Addrs} = data.Responses[0];
        return {
          id: ID,
          addrs: (Addrs || []).map(a => new multiaddr__WEBPACK_IMPORTED_MODULE_0__.Multiaddr(a))
        };
      }
    }
    throw new Error('not found');
  }
  return findPeer;
});

/***/ }),

/***/ 4620:
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dht/find-provs.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFindProvs": () => (/* binding */ createFindProvs)
/* harmony export */ });
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiaddr */ 6584);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _response_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./response-types.js */ 6208);




const createFindProvs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function* findProvs(cid, options = {}) {
    const res = await api.post('dht/findprovs', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const message of res.ndjson()) {
      if (message.Type === _response_types_js__WEBPACK_IMPORTED_MODULE_3__.Provider && message.Responses) {
        for (const {ID, Addrs} of message.Responses) {
          yield {
            id: ID,
            addrs: (Addrs || []).map(a => new multiaddr__WEBPACK_IMPORTED_MODULE_0__.Multiaddr(a))
          };
        }
      }
    }
  }
  return findProvs;
});

/***/ }),

/***/ 4354:
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dht/get.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGet": () => (/* binding */ createGet)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _response_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./response-types.js */ 6208);
/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uint8arrays/from-string */ 2217);
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uint8arrays/to-string */ 2263);





const createGet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function get(key, options = {}) {
    const res = await api.post('dht/get', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: key instanceof Uint8Array ? (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_4__.toString)(key) : key,
        ...options
      }),
      headers: options.headers
    });
    for await (const message of res.ndjson()) {
      if (message.Type === _response_types_js__WEBPACK_IMPORTED_MODULE_2__.Value) {
        return (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__.fromString)(message.Extra, 'base64pad');
      }
    }
    throw new Error('not found');
  }
  return get;
});

/***/ }),

/***/ 4517:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dht/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDht": () => (/* binding */ createDht)
/* harmony export */ });
/* harmony import */ var _find_peer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./find-peer.js */ 6579);
/* harmony import */ var _find_provs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./find-provs.js */ 4620);
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get.js */ 4354);
/* harmony import */ var _provide_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./provide.js */ 6924);
/* harmony import */ var _put_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./put.js */ 8614);
/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./query.js */ 1045);






function createDht(config) {
  return {
    findPeer: (0,_find_peer_js__WEBPACK_IMPORTED_MODULE_0__.createFindPeer)(config),
    findProvs: (0,_find_provs_js__WEBPACK_IMPORTED_MODULE_1__.createFindProvs)(config),
    get: (0,_get_js__WEBPACK_IMPORTED_MODULE_2__.createGet)(config),
    provide: (0,_provide_js__WEBPACK_IMPORTED_MODULE_3__.createProvide)(config),
    put: (0,_put_js__WEBPACK_IMPORTED_MODULE_4__.createPut)(config),
    query: (0,_query_js__WEBPACK_IMPORTED_MODULE_5__.createQuery)(config)
  };
}

/***/ }),

/***/ 6924:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dht/provide.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createProvide": () => (/* binding */ createProvide)
/* harmony export */ });
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiaddr */ 6584);
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);




const createProvide = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  async function* provide(cids, options = { recursive: false }) {
    const cidArr = Array.isArray(cids) ? cids : [cids];
    const res = await api.post('dht/provide', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: cidArr.map(cid => cid.toString()),
        ...options
      }),
      headers: options.headers
    });
    for await (let message of res.ndjson()) {
      message = (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamel)(message);
      if (message.responses) {
        message.responses = message.responses.map(({ID, Addrs}) => ({
          id: ID,
          addrs: (Addrs || []).map(a => new multiaddr__WEBPACK_IMPORTED_MODULE_0__.Multiaddr(a))
        }));
      } else {
        message.responses = [];
      }
      yield message;
    }
  }
  return provide;
});

/***/ }),

/***/ 8614:
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dht/put.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPut": () => (/* binding */ createPut)
/* harmony export */ });
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiaddr */ 6584);
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ 8126);
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/abort-signal.js */ 13);
/* harmony import */ var native_abort_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! native-abort-controller */ 5353);
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uint8arrays/to-string */ 2263);








const createPut = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  async function* put(key, value, options = {}) {
    const controller = new native_abort_controller__WEBPACK_IMPORTED_MODULE_6__.AbortController();
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_5__.abortSignal)(controller.signal, options.signal);
    const res = await api.post('dht/put', {
      signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_7__.toString)(key),
        ...options
      }),
      ...await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_4__.multipartRequest)(value, controller, options.headers)
    });
    for await (let message of res.ndjson()) {
      message = (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamel)(message);
      if (message.responses) {
        message.responses = message.responses.map(({ID, Addrs}) => ({
          id: ID,
          addrs: (Addrs || []).map(a => new multiaddr__WEBPACK_IMPORTED_MODULE_0__.Multiaddr(a))
        }));
      }
      yield message;
    }
  }
  return put;
});

/***/ }),

/***/ 1045:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dht/query.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createQuery": () => (/* binding */ createQuery)
/* harmony export */ });
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiaddr */ 6584);
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);




const createQuery = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  async function* query(peerId, options = {}) {
    const res = await api.post('dht/query', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: peerId.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (let message of res.ndjson()) {
      message = (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamel)(message);
      message.responses = (message.responses || []).map(({ID, Addrs}) => ({
        id: ID,
        addrs: (Addrs || []).map(a => new multiaddr__WEBPACK_IMPORTED_MODULE_0__.Multiaddr(a))
      }));
      yield message;
    }
  }
  return query;
});

/***/ }),

/***/ 6208:
/*!*********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dht/response-types.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SendingQuery": () => (/* binding */ SendingQuery),
/* harmony export */   "PeerResponse": () => (/* binding */ PeerResponse),
/* harmony export */   "FinalPeer": () => (/* binding */ FinalPeer),
/* harmony export */   "QueryError": () => (/* binding */ QueryError),
/* harmony export */   "Provider": () => (/* binding */ Provider),
/* harmony export */   "Value": () => (/* binding */ Value),
/* harmony export */   "AddingPeer": () => (/* binding */ AddingPeer),
/* harmony export */   "DialingPeer": () => (/* binding */ DialingPeer)
/* harmony export */ });
const SendingQuery = 0;
const PeerResponse = 1;
const FinalPeer = 2;
const QueryError = 3;
const Provider = 4;
const Value = 5;
const AddingPeer = 6;
const DialingPeer = 7;

/***/ }),

/***/ 5909:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/diag/cmds.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCmds": () => (/* binding */ createCmds)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createCmds = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function cmds(options = {}) {
    const res = await api.post('diag/cmds', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    });
    return res.json();
  }
  return cmds;
});

/***/ }),

/***/ 4623:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/diag/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDiag": () => (/* binding */ createDiag)
/* harmony export */ });
/* harmony import */ var _cmds_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cmds.js */ 5909);
/* harmony import */ var _net_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./net.js */ 8520);
/* harmony import */ var _sys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sys.js */ 2688);



function createDiag(config) {
  return {
    cmds: (0,_cmds_js__WEBPACK_IMPORTED_MODULE_0__.createCmds)(config),
    net: (0,_net_js__WEBPACK_IMPORTED_MODULE_1__.createNet)(config),
    sys: (0,_sys_js__WEBPACK_IMPORTED_MODULE_2__.createSys)(config)
  };
}

/***/ }),

/***/ 8520:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/diag/net.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createNet": () => (/* binding */ createNet)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createNet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function net(options = {}) {
    const res = await api.post('diag/net', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    });
    return res.json();
  }
  return net;
});

/***/ }),

/***/ 2688:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/diag/sys.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSys": () => (/* binding */ createSys)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createSys = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function sys(options = {}) {
    const res = await api.post('diag/sys', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    });
    return res.json();
  }
  return sys;
});

/***/ }),

/***/ 3063:
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/dns.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDns": () => (/* binding */ createDns)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ 6117);


const createDns = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  const dns = async (domain, options = {}) => {
    const res = await api.post('dns', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: domain,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Path;
  };
  return dns;
});

/***/ }),

/***/ 1821:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/files/chmod.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createChmod": () => (/* binding */ createChmod)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createChmod = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function chmod(path, mode, options = {}) {
    const res = await api.post('files/chmod', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        mode,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return chmod;
});

/***/ }),

/***/ 3351:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/files/cp.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCp": () => (/* binding */ createCp)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createCp = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function cp(sources, destination, options = {}) {
    const sourceArr = Array.isArray(sources) ? sources : [sources];
    const res = await api.post('files/cp', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: sourceArr.concat(destination).map(src => multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.asCID(src) ? `/ipfs/${ src }` : src),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return cp;
});

/***/ }),

/***/ 8555:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/files/flush.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFlush": () => (/* binding */ createFlush)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createFlush = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function flush(path, options = {}) {
    if (!path || typeof path !== 'string') {
      throw new Error('ipfs.files.flush requires a path');
    }
    const res = await api.post('files/flush', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(data.Cid);
  }
  return flush;
});

/***/ }),

/***/ 2551:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/files/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFiles": () => (/* binding */ createFiles)
/* harmony export */ });
/* harmony import */ var _chmod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chmod.js */ 1821);
/* harmony import */ var _cp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp.js */ 3351);
/* harmony import */ var _flush_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flush.js */ 8555);
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ls.js */ 4379);
/* harmony import */ var _mkdir_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mkdir.js */ 5134);
/* harmony import */ var _mv_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mv.js */ 5115);
/* harmony import */ var _read_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./read.js */ 9458);
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rm.js */ 4696);
/* harmony import */ var _stat_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./stat.js */ 9530);
/* harmony import */ var _touch_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./touch.js */ 2065);
/* harmony import */ var _write_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./write.js */ 5182);











function createFiles(config) {
  return {
    chmod: (0,_chmod_js__WEBPACK_IMPORTED_MODULE_0__.createChmod)(config),
    cp: (0,_cp_js__WEBPACK_IMPORTED_MODULE_1__.createCp)(config),
    flush: (0,_flush_js__WEBPACK_IMPORTED_MODULE_2__.createFlush)(config),
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_3__.createLs)(config),
    mkdir: (0,_mkdir_js__WEBPACK_IMPORTED_MODULE_4__.createMkdir)(config),
    mv: (0,_mv_js__WEBPACK_IMPORTED_MODULE_5__.createMv)(config),
    read: (0,_read_js__WEBPACK_IMPORTED_MODULE_6__.createRead)(config),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_7__.createRm)(config),
    stat: (0,_stat_js__WEBPACK_IMPORTED_MODULE_8__.createStat)(config),
    touch: (0,_touch_js__WEBPACK_IMPORTED_MODULE_9__.createTouch)(config),
    write: (0,_write_js__WEBPACK_IMPORTED_MODULE_10__.createWrite)(config)
  };
}

/***/ }),

/***/ 4379:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/files/ls.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": () => (/* binding */ createLs)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_object_to_camel_with_metadata_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/object-to-camel-with-metadata.js */ 9543);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);




const createLs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  async function* ls(path, options = {}) {
    if (!path) {
      throw new Error('ipfs.files.ls requires a path');
    }
    const res = await api.post('files/ls', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.asCID(path) ? `/ipfs/${ path }` : path,
        long: true,
        ...options,
        stream: true
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      if ('Entries' in result) {
        for (const entry of result.Entries || []) {
          yield toCoreInterface((0,_lib_object_to_camel_with_metadata_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamelWithMetadata)(entry));
        }
      } else {
        yield toCoreInterface((0,_lib_object_to_camel_with_metadata_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamelWithMetadata)(result));
      }
    }
  }
  return ls;
});
function toCoreInterface(entry) {
  if (entry.hash) {
    entry.cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(entry.hash);
  }
  delete entry.hash;
  entry.type = entry.type === 1 ? 'directory' : 'file';
  return entry;
}

/***/ }),

/***/ 5134:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/files/mkdir.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMkdir": () => (/* binding */ createMkdir)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createMkdir = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function mkdir(path, options = {}) {
    const res = await api.post('files/mkdir', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mkdir;
});

/***/ }),

/***/ 5115:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/files/mv.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMv": () => (/* binding */ createMv)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createMv = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function mv(sources, destination, options = {}) {
    if (!Array.isArray(sources)) {
      sources = [sources];
    }
    const res = await api.post('files/mv', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: sources.concat(destination),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mv;
});

/***/ }),

/***/ 9458:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/files/read.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRead": () => (/* binding */ createRead)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var stream_to_it_source_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream-to-it/source.js */ 590);



const createRead = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function* read(path, options = {}) {
    const res = await api.post('files/read', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        count: options.length,
        ...options
      }),
      headers: options.headers
    });
    yield* stream_to_it_source_js__WEBPACK_IMPORTED_MODULE_2__(res.body);
  }
  return read;
});

/***/ }),

/***/ 4696:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/files/rm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": () => (/* binding */ createRm)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createRm = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function rm(path, options = {}) {
    const res = await api.post('files/rm', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return rm;
});

/***/ }),

/***/ 9530:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/files/stat.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStat": () => (/* binding */ createStat)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_object_to_camel_with_metadata_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/object-to-camel-with-metadata.js */ 9543);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);




const createStat = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  async function stat(path, options = {}) {
    const res = await api.post('files/stat', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    data.WithLocality = data.WithLocality || false;
    return toCoreInterface((0,_lib_object_to_camel_with_metadata_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamelWithMetadata)(data));
  }
  return stat;
});
function toCoreInterface(entry) {
  entry.cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(entry.hash);
  delete entry.hash;
  return entry;
}

/***/ }),

/***/ 2065:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/files/touch.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTouch": () => (/* binding */ createTouch)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createTouch = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function touch(path, options = {}) {
    const res = await api.post('files/touch', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return touch;
});

/***/ }),

/***/ 5182:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/files/write.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createWrite": () => (/* binding */ createWrite)
/* harmony export */ });
/* harmony import */ var _lib_mode_to_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/mode-to-string.js */ 7382);
/* harmony import */ var _lib_parse_mtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/parse-mtime.js */ 5158);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ 8126);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/abort-signal.js */ 13);
/* harmony import */ var native_abort_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! native-abort-controller */ 5353);







const createWrite = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  async function write(path, input, options = {}) {
    const controller = new native_abort_controller__WEBPACK_IMPORTED_MODULE_6__.AbortController();
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_5__.abortSignal)(controller.signal, options.signal);
    const res = await api.post('files/write', {
      signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_4__.toUrlSearchParams)({
        arg: path,
        streamChannels: true,
        count: options.length,
        ...options
      }),
      ...await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_3__.multipartRequest)({
        content: input,
        path: 'arg',
        mode: (0,_lib_mode_to_string_js__WEBPACK_IMPORTED_MODULE_0__.modeToString)(options.mode),
        mtime: (0,_lib_parse_mtime_js__WEBPACK_IMPORTED_MODULE_1__.parseMtime)(options.mtime)
      }, controller, options.headers)
    });
    await res.text();
  }
  return write;
});

/***/ }),

/***/ 512:
/*!**********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/get-endpoint-config.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGetEndpointConfig": () => (/* binding */ createGetEndpointConfig)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ 5508);

const createGetEndpointConfig = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  return () => {
    const url = new URL(api.opts.base || '');
    return {
      host: url.hostname,
      port: url.port,
      protocol: url.protocol,
      pathname: url.pathname,
      'api-path': url.pathname
    };
  };
});

/***/ }),

/***/ 6520:
/*!******************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/get.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGet": () => (/* binding */ createGet)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ 6117);



const createGet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function* get(path, options = {}) {
    const opts = {
      arg: `${ path instanceof Uint8Array ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(path) : path }`,
      ...options
    };
    if (opts.compressionLevel) {
      opts['compression-level'] = opts.compressionLevel;
      delete opts.compressionLevel;
    }
    const res = await api.post('get', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(opts),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return get;
});

/***/ }),

/***/ 8722:
/*!*****************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/id.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createId": () => (/* binding */ createId)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/object-to-camel.js */ 988);
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiaddr */ 6584);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ 6117);




const createId = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  async function id(options = {}) {
    const res = await api.post('id', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: options.peerId ? options.peerId.toString() : undefined,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    const output = { ...(0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(data) };
    if (output.addresses) {
      output.addresses = output.addresses.map(ma => new multiaddr__WEBPACK_IMPORTED_MODULE_1__.Multiaddr(ma));
    }
    return output;
  }
  return id;
});

/***/ }),

/***/ 5091:
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "CID": () => (/* reexport safe */ multiformats_cid__WEBPACK_IMPORTED_MODULE_42__.CID),
/* harmony export */   "multiaddr": () => (/* reexport safe */ multiaddr__WEBPACK_IMPORTED_MODULE_43__.Multiaddr),
/* harmony export */   "urlSource": () => (/* reexport default export from named module */ ipfs_utils_src_files_url_source_js__WEBPACK_IMPORTED_MODULE_44__),
/* harmony export */   "globSource": () => (/* binding */ globSource)
/* harmony export */ });
/* harmony import */ var ipfs_core_utils_multibases__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-core-utils/multibases */ 6255);
/* harmony import */ var ipfs_core_utils_multicodecs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-core-utils/multicodecs */ 3428);
/* harmony import */ var ipfs_core_utils_multihashes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-core-utils/multihashes */ 4409);
/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ipld/dag-pb */ 1864);
/* harmony import */ var _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ipld/dag-cbor */ 9101);
/* harmony import */ var multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! multiformats/hashes/identity */ 8103);
/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! multiformats/basics */ 1069);
/* harmony import */ var _bitswap_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bitswap/index.js */ 4408);
/* harmony import */ var _block_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./block/index.js */ 4445);
/* harmony import */ var _bootstrap_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./bootstrap/index.js */ 5491);
/* harmony import */ var _config_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./config/index.js */ 670);
/* harmony import */ var _dag_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dag/index.js */ 6906);
/* harmony import */ var _dht_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./dht/index.js */ 4517);
/* harmony import */ var _diag_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./diag/index.js */ 4623);
/* harmony import */ var _files_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./files/index.js */ 2551);
/* harmony import */ var _key_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./key/index.js */ 428);
/* harmony import */ var _log_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./log/index.js */ 9303);
/* harmony import */ var _name_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./name/index.js */ 8296);
/* harmony import */ var _object_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./object/index.js */ 2793);
/* harmony import */ var _pin_index_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./pin/index.js */ 2606);
/* harmony import */ var _pubsub_index_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./pubsub/index.js */ 4719);
/* harmony import */ var _refs_index_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./refs/index.js */ 4501);
/* harmony import */ var _repo_index_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./repo/index.js */ 3114);
/* harmony import */ var _stats_index_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./stats/index.js */ 9255);
/* harmony import */ var _swarm_index_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./swarm/index.js */ 7619);
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./add.js */ 7563);
/* harmony import */ var _add_all_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./add-all.js */ 1987);
/* harmony import */ var _cat_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./cat.js */ 5672);
/* harmony import */ var _commands_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./commands.js */ 6365);
/* harmony import */ var _dns_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./dns.js */ 3063);
/* harmony import */ var _get_endpoint_config_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./get-endpoint-config.js */ 512);
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./get.js */ 6520);
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./id.js */ 8722);
/* harmony import */ var _is_online_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./is-online.js */ 210);
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./ls.js */ 5682);
/* harmony import */ var _mount_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./mount.js */ 238);
/* harmony import */ var _ping_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./ping.js */ 8181);
/* harmony import */ var _resolve_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./resolve.js */ 3055);
/* harmony import */ var _start_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./start.js */ 7140);
/* harmony import */ var _stop_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./stop.js */ 5923);
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./version.js */ 8960);
/* harmony import */ var ipfs_utils_src_files_glob_source_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ipfs-utils/src/files/glob-source.js */ 2611);
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! multiaddr */ 6584);
/* harmony import */ var ipfs_utils_src_files_url_source_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ipfs-utils/src/files/url-source.js */ 6953);










































function create(options = {}) {
  const id = {
    name: multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_5__.identity.name,
    code: multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_5__.identity.code,
    encode: id => id,
    decode: id => id
  };
  const multibaseCodecs = Object.values(multiformats_basics__WEBPACK_IMPORTED_MODULE_6__.bases);
  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach(base => multibaseCodecs.push(base));
  const multibases = new ipfs_core_utils_multibases__WEBPACK_IMPORTED_MODULE_0__.Multibases({
    bases: multibaseCodecs,
    loadBase: options.ipld && options.ipld.loadBase
  });
  const blockCodecs = Object.values(multiformats_basics__WEBPACK_IMPORTED_MODULE_6__.codecs);
  [
    _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_3__,
    _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4__,
    id
  ].concat(options.ipld && options.ipld.codecs || []).forEach(codec => blockCodecs.push(codec));
  const multicodecs = new ipfs_core_utils_multicodecs__WEBPACK_IMPORTED_MODULE_1__.Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const multihashHashers = Object.values(multiformats_basics__WEBPACK_IMPORTED_MODULE_6__.hashes);
  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach(hasher => multihashHashers.push(hasher));
  const multihashes = new ipfs_core_utils_multihashes__WEBPACK_IMPORTED_MODULE_2__.Multihashes({
    hashers: multihashHashers,
    loadHasher: options.ipld && options.ipld.loadHasher
  });
  const client = {
    add: (0,_add_js__WEBPACK_IMPORTED_MODULE_25__.createAdd)(options),
    addAll: (0,_add_all_js__WEBPACK_IMPORTED_MODULE_26__.createAddAll)(options),
    bitswap: (0,_bitswap_index_js__WEBPACK_IMPORTED_MODULE_7__.createBitswap)(options),
    block: (0,_block_index_js__WEBPACK_IMPORTED_MODULE_8__.createBlock)(options),
    bootstrap: (0,_bootstrap_index_js__WEBPACK_IMPORTED_MODULE_9__.createBootstrap)(options),
    cat: (0,_cat_js__WEBPACK_IMPORTED_MODULE_27__.createCat)(options),
    commands: (0,_commands_js__WEBPACK_IMPORTED_MODULE_28__.createCommands)(options),
    config: (0,_config_index_js__WEBPACK_IMPORTED_MODULE_10__.createConfig)(options),
    dag: (0,_dag_index_js__WEBPACK_IMPORTED_MODULE_11__.createDag)(multicodecs, options),
    dht: (0,_dht_index_js__WEBPACK_IMPORTED_MODULE_12__.createDht)(options),
    diag: (0,_diag_index_js__WEBPACK_IMPORTED_MODULE_13__.createDiag)(options),
    dns: (0,_dns_js__WEBPACK_IMPORTED_MODULE_29__.createDns)(options),
    files: (0,_files_index_js__WEBPACK_IMPORTED_MODULE_14__.createFiles)(options),
    get: (0,_get_js__WEBPACK_IMPORTED_MODULE_31__.createGet)(options),
    getEndpointConfig: (0,_get_endpoint_config_js__WEBPACK_IMPORTED_MODULE_30__.createGetEndpointConfig)(options),
    id: (0,_id_js__WEBPACK_IMPORTED_MODULE_32__.createId)(options),
    isOnline: (0,_is_online_js__WEBPACK_IMPORTED_MODULE_33__.createIsOnline)(options),
    key: (0,_key_index_js__WEBPACK_IMPORTED_MODULE_15__.createKey)(options),
    log: (0,_log_index_js__WEBPACK_IMPORTED_MODULE_16__.createLog)(options),
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_34__.createLs)(options),
    mount: (0,_mount_js__WEBPACK_IMPORTED_MODULE_35__.createMount)(options),
    name: (0,_name_index_js__WEBPACK_IMPORTED_MODULE_17__.createName)(options),
    object: (0,_object_index_js__WEBPACK_IMPORTED_MODULE_18__.createObject)(multicodecs, options),
    pin: (0,_pin_index_js__WEBPACK_IMPORTED_MODULE_19__.createPin)(options),
    ping: (0,_ping_js__WEBPACK_IMPORTED_MODULE_36__.createPing)(options),
    pubsub: (0,_pubsub_index_js__WEBPACK_IMPORTED_MODULE_20__.createPubsub)(options),
    refs: (0,_refs_index_js__WEBPACK_IMPORTED_MODULE_21__.createRefs)(options),
    repo: (0,_repo_index_js__WEBPACK_IMPORTED_MODULE_22__.createRepo)(options),
    resolve: (0,_resolve_js__WEBPACK_IMPORTED_MODULE_37__.createResolve)(options),
    start: (0,_start_js__WEBPACK_IMPORTED_MODULE_38__.createStart)(options),
    stats: (0,_stats_index_js__WEBPACK_IMPORTED_MODULE_23__.createStats)(options),
    stop: (0,_stop_js__WEBPACK_IMPORTED_MODULE_39__.createStop)(options),
    swarm: (0,_swarm_index_js__WEBPACK_IMPORTED_MODULE_24__.createSwarm)(options),
    version: (0,_version_js__WEBPACK_IMPORTED_MODULE_40__.createVersion)(options),
    bases: multibases,
    codecs: multicodecs,
    hashers: multihashes
  };
  return client;
}



const globSource = ipfs_utils_src_files_glob_source_js__WEBPACK_IMPORTED_MODULE_41__;

/***/ }),

/***/ 210:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/is-online.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createIsOnline": () => (/* binding */ createIsOnline)
/* harmony export */ });
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ 8722);

const createIsOnline = options => {
  const id = (0,_id_js__WEBPACK_IMPORTED_MODULE_0__.createId)(options);
  async function isOnline(options = {}) {
    const res = await id(options);
    return Boolean(res && res.addresses && res.addresses.length);
  }
  return isOnline;
};

/***/ }),

/***/ 116:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/key/export.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createExport": () => (/* binding */ createExport)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! err-code */ 2114);


const createExport = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  const exportKey = async (name, password, options = {}) => {
    throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED');
  };
  return exportKey;
});

/***/ }),

/***/ 4865:
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/key/gen.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGen": () => (/* binding */ createGen)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createGen = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function gen(name, options = {
    type: 'rsa',
    size: 2048
  }) {
    const res = await api.post('key/gen', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: name,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(data);
  }
  return gen;
});

/***/ }),

/***/ 1073:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/key/import.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createImport": () => (/* binding */ createImport)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createImport = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function importKey(name, pem, password, options = {}) {
    const res = await api.post('key/import', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: name,
        pem,
        password,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(data);
  }
  return importKey;
});

/***/ }),

/***/ 428:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/key/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createKey": () => (/* binding */ createKey)
/* harmony export */ });
/* harmony import */ var _export_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./export.js */ 116);
/* harmony import */ var _gen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gen.js */ 4865);
/* harmony import */ var _import_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./import.js */ 1073);
/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ 7877);
/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./list.js */ 6430);
/* harmony import */ var _rename_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rename.js */ 9249);
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rm.js */ 584);







function createKey(config) {
  return {
    export: (0,_export_js__WEBPACK_IMPORTED_MODULE_0__.createExport)(config),
    gen: (0,_gen_js__WEBPACK_IMPORTED_MODULE_1__.createGen)(config),
    import: (0,_import_js__WEBPACK_IMPORTED_MODULE_2__.createImport)(config),
    info: (0,_info_js__WEBPACK_IMPORTED_MODULE_3__.createInfo)(config),
    list: (0,_list_js__WEBPACK_IMPORTED_MODULE_4__.createList)(config),
    rename: (0,_rename_js__WEBPACK_IMPORTED_MODULE_5__.createRename)(config),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_6__.createRm)(config)
  };
}

/***/ }),

/***/ 7877:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/key/info.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createInfo": () => (/* binding */ createInfo)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! err-code */ 2114);


const createInfo = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  const info = async (name, options = {}) => {
    throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED');
  };
  return info;
});

/***/ }),

/***/ 6430:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/key/list.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createList": () => (/* binding */ createList)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createList = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function list(options = {}) {
    const res = await api.post('key/list', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Keys || []).map(k => (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(k));
  }
  return list;
});

/***/ }),

/***/ 9249:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/key/rename.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRename": () => (/* binding */ createRename)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createRename = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function rename(oldName, newName, options = {}) {
    const res = await api.post('key/rename', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: [
          oldName,
          newName
        ],
        ...options
      }),
      headers: options.headers
    });
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json());
  }
  return rename;
});

/***/ }),

/***/ 584:
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/key/rm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": () => (/* binding */ createRm)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createRm = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function rm(name, options = {}) {
    const res = await api.post('key/rm', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: name,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(data.Keys[0]);
  }
  return rm;
});

/***/ }),

/***/ 13:
/*!*******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/lib/abort-signal.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abortSignal": () => (/* binding */ abortSignal)
/* harmony export */ });
/* harmony import */ var any_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! any-signal */ 2044);

function filter(signals) {
  return signals.filter(Boolean);
}
function abortSignal(...signals) {
  return (0,any_signal__WEBPACK_IMPORTED_MODULE_0__.anySignal)(filter(signals));
}

/***/ }),

/***/ 5508:
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/lib/configure.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "configure": () => (/* binding */ configure)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ 2902);

const configure = fn => {
  return options => {
    return fn(new _core_js__WEBPACK_IMPORTED_MODULE_0__.Client(options), options);
  };
};

/***/ }),

/***/ 2902:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/lib/core.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "errorHandler": () => (/* binding */ errorHandler),
/* harmony export */   "Client": () => (/* binding */ Client),
/* harmony export */   "HTTPError": () => (/* binding */ HTTPError)
/* harmony export */ });
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiaddr */ 6584);
/* harmony import */ var ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-utils/src/env.js */ 106);
/* harmony import */ var parse_duration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! parse-duration */ 2816);
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! debug */ 1227);
/* harmony import */ var ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ipfs-utils/src/http.js */ 7137);
/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! merge-options */ 726);
/* harmony import */ var ipfs_core_utils_to_url_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ipfs-core-utils/to-url-string */ 3627);
/* harmony import */ var ipfs_core_utils_agent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ipfs-core-utils/agent */ 6642);








const log = debug__WEBPACK_IMPORTED_MODULE_3__('ipfs-http-client:lib:error-handler');
const merge = merge_options__WEBPACK_IMPORTED_MODULE_5__["default"].bind({ ignoreUndefined: true });
const DEFAULT_PROTOCOL = ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser || ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isWebWorker ? location.protocol : 'http';
const DEFAULT_HOST = ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser || ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isWebWorker ? location.hostname : 'localhost';
const DEFAULT_PORT = ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser || ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isWebWorker ? location.port : '5001';
const normalizeOptions = (options = {}) => {
  let url;
  let opts = {};
  let agent;
  if (typeof options === 'string' || multiaddr__WEBPACK_IMPORTED_MODULE_0__.Multiaddr.isMultiaddr(options)) {
    url = new URL((0,ipfs_core_utils_to_url_string__WEBPACK_IMPORTED_MODULE_6__.toUrlString)(options));
  } else if (options instanceof URL) {
    url = options;
  } else if (typeof options.url === 'string' || multiaddr__WEBPACK_IMPORTED_MODULE_0__.Multiaddr.isMultiaddr(options.url)) {
    url = new URL((0,ipfs_core_utils_to_url_string__WEBPACK_IMPORTED_MODULE_6__.toUrlString)(options.url));
    opts = options;
  } else if (options.url instanceof URL) {
    url = options.url;
    opts = options;
  } else {
    opts = options || {};
    const protocol = (opts.protocol || DEFAULT_PROTOCOL).replace(':', '');
    const host = (opts.host || DEFAULT_HOST).split(':')[0];
    const port = opts.port || DEFAULT_PORT;
    url = new URL(`${ protocol }://${ host }:${ port }`);
  }
  if (opts.apiPath) {
    url.pathname = opts.apiPath;
  } else if (url.pathname === '/' || url.pathname === undefined) {
    url.pathname = 'api/v0';
  }
  if (ipfs_utils_src_env_js__WEBPACK_IMPORTED_MODULE_1__.isNode) {
    const Agent = (0,ipfs_core_utils_agent__WEBPACK_IMPORTED_MODULE_7__["default"])(url);
    agent = opts.agent || new Agent({
      keepAlive: true,
      maxSockets: 6
    });
  }
  return {
    ...opts,
    host: url.host,
    protocol: url.protocol.replace(':', ''),
    port: Number(url.port),
    apiPath: url.pathname,
    url,
    agent
  };
};
const errorHandler = async response => {
  let msg;
  try {
    if ((response.headers.get('Content-Type') || '').startsWith('application/json')) {
      const data = await response.json();
      log(data);
      msg = data.Message || data.message;
    } else {
      msg = await response.text();
    }
  } catch (err) {
    log('Failed to parse error response', err);
    msg = err.message;
  }
  let error = new ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__.HTTPError(response);
  if (msg) {
    if (msg.includes('deadline has elapsed')) {
      error = new ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__.TimeoutError();
    }
    if (msg && msg.includes('context deadline exceeded')) {
      error = new ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__.TimeoutError();
    }
  }
  if (msg && msg.includes('request timed out')) {
    error = new ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__.TimeoutError();
  }
  if (msg) {
    error.message = msg;
  }
  throw error;
};
const KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g;
const kebabCase = str => {
  return str.replace(KEBAB_REGEX, function (match) {
    return '-' + match.toLowerCase();
  });
};
const parseTimeout = value => {
  return typeof value === 'string' ? (0,parse_duration__WEBPACK_IMPORTED_MODULE_2__["default"])(value) : value;
};
class Client extends ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__ {
  constructor(options = {}) {
    const opts = normalizeOptions(options);
    super({
      timeout: parseTimeout(opts.timeout || 0) || undefined,
      headers: opts.headers,
      base: `${ opts.url }`,
      handleError: errorHandler,
      transformSearchParams: search => {
        const out = new URLSearchParams();
        for (const [key, value] of search) {
          if (value !== 'undefined' && value !== 'null' && key !== 'signal') {
            out.append(kebabCase(key), value);
          }
          if (key === 'timeout' && !isNaN(value)) {
            out.append(kebabCase(key), value);
          }
        }
        return out;
      },
      agent: opts.agent
    });
    delete this.get;
    delete this.put;
    delete this.delete;
    delete this.options;
    const fetch = this.fetch;
    this.fetch = (resource, options = {}) => {
      if (typeof resource === 'string' && !resource.startsWith('/')) {
        resource = `${ opts.url }/${ resource }`;
      }
      return fetch.call(this, resource, merge(options, { method: 'POST' }));
    };
  }
}
const HTTPError = ipfs_utils_src_http_js__WEBPACK_IMPORTED_MODULE_4__.HTTPError;

/***/ }),

/***/ 7382:
/*!*********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/lib/mode-to-string.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "modeToString": () => (/* binding */ modeToString)
/* harmony export */ });
function modeToString(mode) {
  if (mode == null) {
    return undefined;
  }
  if (typeof mode === 'string') {
    return mode;
  }
  return mode.toString(8).padStart(4, '0');
}

/***/ }),

/***/ 9543:
/*!************************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/lib/object-to-camel-with-metadata.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "objectToCamelWithMetadata": () => (/* binding */ objectToCamelWithMetadata)
/* harmony export */ });
/* harmony import */ var _object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object-to-camel.js */ 988);

function objectToCamelWithMetadata(entry) {
  const file = (0,_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(entry);
  if (Object.prototype.hasOwnProperty.call(file, 'mode')) {
    file.mode = parseInt(file.mode, 8);
  }
  if (Object.prototype.hasOwnProperty.call(file, 'mtime')) {
    file.mtime = {
      secs: file.mtime,
      nsecs: file.mtimeNsecs || 0
    };
    delete file.mtimeNsecs;
  }
  return file;
}

/***/ }),

/***/ 988:
/*!**********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/lib/object-to-camel.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "objectToCamel": () => (/* binding */ objectToCamel)
/* harmony export */ });
function objectToCamel(obj) {
  if (obj == null) {
    return obj;
  }
  const caps = /^[A-Z]+$/;
  const output = {};
  return Object.keys(obj).reduce((camelObj, k) => {
    if (caps.test(k)) {
      camelObj[k.toLowerCase()] = obj[k];
    } else if (caps.test(k[0])) {
      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k];
    } else {
      camelObj[k] = obj[k];
    }
    return camelObj;
  }, output);
}

/***/ }),

/***/ 5158:
/*!******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/lib/parse-mtime.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseMtime": () => (/* binding */ parseMtime)
/* harmony export */ });
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ 2114);

function parseMtime(input) {
  if (input == null) {
    return undefined;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1000);
    mtime = {
      secs: secs,
      nsecs: (ms - secs * 1000) * 1000
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {
    return undefined;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');
  }
  return mtime;
}

/***/ }),

/***/ 1933:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/lib/resolve.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resolve": () => (/* binding */ resolve)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! err-code */ 2114);


async function* resolve(cid, path, codecs, getBlock, options) {
  const load = async cid => {
    const codec = await codecs.getCodec(cid.code);
    const block = await getBlock(cid, options);
    return codec.decode(block);
  };
  const parts = path.split('/').filter(Boolean);
  let value = await load(cid);
  let lastCid = cid;
  if (!parts.length) {
    yield {
      value,
      remainderPath: ''
    };
  }
  while (parts.length) {
    const key = parts.shift();
    if (!key) {
      throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error(`Could not resolve path "${ path }"`), 'ERR_INVALID_PATH');
    }
    if (Object.prototype.hasOwnProperty.call(value, key)) {
      value = value[key];
      yield {
        value,
        remainderPath: parts.join('/')
      };
    } else {
      throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error(`no link named "${ key }" under ${ lastCid }`), 'ERR_NO_LINK');
    }
    const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.asCID(value);
    if (cid) {
      lastCid = cid;
      value = await load(value);
    }
  }
}

/***/ }),

/***/ 6117:
/*!***************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/lib/to-url-search-params.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toUrlSearchParams": () => (/* binding */ toUrlSearchParams)
/* harmony export */ });
/* harmony import */ var _mode_to_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode-to-string.js */ 7382);
/* harmony import */ var _lib_parse_mtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/parse-mtime.js */ 5158);


function toUrlSearchParams({arg, searchParams, hashAlg, mtime, mode, ...options} = {}) {
  if (searchParams) {
    options = {
      ...options,
      ...searchParams
    };
  }
  if (hashAlg) {
    options.hash = hashAlg;
  }
  if (mtime != null) {
    mtime = (0,_lib_parse_mtime_js__WEBPACK_IMPORTED_MODULE_1__.parseMtime)(mtime);
    options.mtime = mtime.secs;
    options.mtimeNsecs = mtime.nsecs;
  }
  if (mode != null) {
    options.mode = (0,_mode_to_string_js__WEBPACK_IMPORTED_MODULE_0__.modeToString)(mode);
  }
  if (options.timeout && !isNaN(options.timeout)) {
    options.timeout = `${ options.timeout }ms`;
  }
  if (arg === undefined || arg === null) {
    arg = [];
  } else if (!Array.isArray(arg)) {
    arg = [arg];
  }
  const urlSearchParams = new URLSearchParams(options);
  arg.forEach(arg => urlSearchParams.append('arg', arg));
  return urlSearchParams;
}

/***/ }),

/***/ 9303:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/log/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLog": () => (/* binding */ createLog)
/* harmony export */ });
/* harmony import */ var _level_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./level.js */ 8867);
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ls.js */ 9909);
/* harmony import */ var _tail_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tail.js */ 4213);



function createLog(config) {
  return {
    level: (0,_level_js__WEBPACK_IMPORTED_MODULE_0__.createLevel)(config),
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_1__.createLs)(config),
    tail: (0,_tail_js__WEBPACK_IMPORTED_MODULE_2__.createTail)(config)
  };
}

/***/ }),

/***/ 8867:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/log/level.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLevel": () => (/* binding */ createLevel)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createLevel = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function level(subsystem, level, options = {}) {
    const res = await api.post('log/level', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: [
          subsystem,
          level
        ],
        ...options
      }),
      headers: options.headers
    });
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json());
  }
  return level;
});

/***/ }),

/***/ 9909:
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/log/ls.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": () => (/* binding */ createLs)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createLs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function ls(options = {}) {
    const res = await api.post('log/ls', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings;
  }
  return ls;
});

/***/ }),

/***/ 4213:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/log/tail.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTail": () => (/* binding */ createTail)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createTail = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function* tail(options = {}) {
    const res = await api.post('log/tail', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return tail;
});

/***/ }),

/***/ 5682:
/*!*****************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/ls.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": () => (/* binding */ createLs)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ 6117);
/* harmony import */ var _files_stat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./files/stat.js */ 9530);




const createLs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)((api, opts) => {
  async function* ls(path, options = {}) {
    const pathStr = `${ path instanceof Uint8Array ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(path) : path }`;
    async function mapLink(link) {
      let hash = link.Hash;
      if (hash.includes('/')) {
        const ipfsPath = hash.startsWith('/ipfs/') ? hash : `/ipfs/${ hash }`;
        const stats = await (0,_files_stat_js__WEBPACK_IMPORTED_MODULE_3__.createStat)(opts)(ipfsPath);
        hash = stats.cid;
      } else {
        hash = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(hash);
      }
      const entry = {
        name: link.Name,
        path: pathStr + (link.Name ? `/${ link.Name }` : ''),
        size: link.Size,
        cid: hash,
        type: typeOf(link)
      };
      if (link.Mode) {
        entry.mode = parseInt(link.Mode, 8);
      }
      if (link.Mtime !== undefined && link.Mtime !== null) {
        entry.mtime = { secs: link.Mtime };
        if (link.MtimeNsecs !== undefined && link.MtimeNsecs !== null) {
          entry.mtime.nsecs = link.MtimeNsecs;
        }
      }
      return entry;
    }
    const res = await api.post('ls', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: pathStr,
        ...options
      }),
      headers: options.headers
    });
    for await (let result of res.ndjson()) {
      result = result.Objects;
      if (!result) {
        throw new Error('expected .Objects in results');
      }
      result = result[0];
      if (!result) {
        throw new Error('expected one array in results.Objects');
      }
      const links = result.Links;
      if (!Array.isArray(links)) {
        throw new Error('expected one array in results.Objects[0].Links');
      }
      if (!links.length) {
        yield mapLink(result);
        return;
      }
      yield* links.map(mapLink);
    }
  }
  return ls;
});
function typeOf(link) {
  switch (link.Type) {
  case 1:
  case 5:
    return 'dir';
  case 2:
    return 'file';
  default:
    return 'file';
  }
}

/***/ }),

/***/ 238:
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/mount.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMount": () => (/* binding */ createMount)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ 6117);



const createMount = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function mount(options = {}) {
    const res = await api.post('dns', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    });
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json());
  }
  return mount;
});

/***/ }),

/***/ 8296:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/name/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createName": () => (/* binding */ createName)
/* harmony export */ });
/* harmony import */ var _publish_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./publish.js */ 1326);
/* harmony import */ var _resolve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve.js */ 2138);
/* harmony import */ var _pubsub_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pubsub/index.js */ 8154);



function createName(config) {
  return {
    publish: (0,_publish_js__WEBPACK_IMPORTED_MODULE_0__.createPublish)(config),
    resolve: (0,_resolve_js__WEBPACK_IMPORTED_MODULE_1__.createResolve)(config),
    pubsub: (0,_pubsub_index_js__WEBPACK_IMPORTED_MODULE_2__.createPubsub)(config)
  };
}

/***/ }),

/***/ 1326:
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/name/publish.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPublish": () => (/* binding */ createPublish)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createPublish = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function publish(path, options = {}) {
    const res = await api.post('name/publish', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${ path }`,
        ...options
      }),
      headers: options.headers
    });
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json());
  }
  return publish;
});

/***/ }),

/***/ 6113:
/*!*********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/name/pubsub/cancel.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCancel": () => (/* binding */ createCancel)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ 6117);



const createCancel = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function cancel(name, options = {}) {
    const res = await api.post('name/pubsub/cancel', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: name,
        ...options
      }),
      headers: options.headers
    });
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json());
  }
  return cancel;
});

/***/ }),

/***/ 8154:
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/name/pubsub/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPubsub": () => (/* binding */ createPubsub)
/* harmony export */ });
/* harmony import */ var _cancel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cancel.js */ 6113);
/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./state.js */ 888);
/* harmony import */ var _subs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./subs.js */ 3426);



function createPubsub(config) {
  return {
    cancel: (0,_cancel_js__WEBPACK_IMPORTED_MODULE_0__.createCancel)(config),
    state: (0,_state_js__WEBPACK_IMPORTED_MODULE_1__.createState)(config),
    subs: (0,_subs_js__WEBPACK_IMPORTED_MODULE_2__.createSubs)(config)
  };
}

/***/ }),

/***/ 888:
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/name/pubsub/state.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createState": () => (/* binding */ createState)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ 6117);



const createState = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function state(options = {}) {
    const res = await api.post('name/pubsub/state', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    });
    return (0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json());
  }
  return state;
});

/***/ }),

/***/ 3426:
/*!*******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/name/pubsub/subs.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSubs": () => (/* binding */ createSubs)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ 6117);


const createSubs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function subs(options = {}) {
    const res = await api.post('name/pubsub/subs', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings || [];
  }
  return subs;
});

/***/ }),

/***/ 2138:
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/name/resolve.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createResolve": () => (/* binding */ createResolve)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createResolve = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function* resolve(path, options = {}) {
    const res = await api.post('name/resolve', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        stream: true,
        ...options
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      yield result.Path;
    }
  }
  return resolve;
});

/***/ }),

/***/ 1558:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/object/data.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createData": () => (/* binding */ createData)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createData = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function data(cid, options = {}) {
    const res = await api.post('object/data', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${ cid instanceof Uint8Array ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(cid) : cid }`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.arrayBuffer();
    return new Uint8Array(data, 0, data.byteLength);
  }
  return data;
});

/***/ }),

/***/ 3116:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/object/get.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGet": () => (/* binding */ createGet)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uint8arrays/from-string */ 2217);




const createGet = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function get(cid, options = {}) {
    const res = await api.post('object/get', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${ cid instanceof Uint8Array ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(cid) : cid }`,
        dataEncoding: 'base64',
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      Data: (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__.fromString)(data.Data, 'base64pad'),
      Links: (data.Links || []).map(link => ({
        Name: link.Name,
        Hash: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(link.Hash),
        Tsize: link.Size
      }))
    };
  }
  return get;
});

/***/ }),

/***/ 2793:
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/object/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createObject": () => (/* binding */ createObject)
/* harmony export */ });
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ 1558);
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get.js */ 3116);
/* harmony import */ var _links_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./links.js */ 4943);
/* harmony import */ var _new_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./new.js */ 6339);
/* harmony import */ var _put_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./put.js */ 7520);
/* harmony import */ var _stat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stat.js */ 5997);
/* harmony import */ var _patch_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./patch/index.js */ 8512);







function createObject(codecs, config) {
  return {
    data: (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.createData)(config),
    get: (0,_get_js__WEBPACK_IMPORTED_MODULE_1__.createGet)(config),
    links: (0,_links_js__WEBPACK_IMPORTED_MODULE_2__.createLinks)(config),
    new: (0,_new_js__WEBPACK_IMPORTED_MODULE_3__.createNew)(config),
    put: (0,_put_js__WEBPACK_IMPORTED_MODULE_4__.createPut)(codecs, config),
    stat: (0,_stat_js__WEBPACK_IMPORTED_MODULE_5__.createStat)(config),
    patch: (0,_patch_index_js__WEBPACK_IMPORTED_MODULE_6__.createPatch)(config)
  };
}

/***/ }),

/***/ 4943:
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/object/links.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLinks": () => (/* binding */ createLinks)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createLinks = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function links(cid, options = {}) {
    const res = await api.post('object/links', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${ cid instanceof Uint8Array ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(cid) : cid }`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Links || []).map(l => ({
      Name: l.Name,
      Tsize: l.Size,
      Hash: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(l.Hash)
    }));
  }
  return links;
});

/***/ }),

/***/ 6339:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/object/new.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createNew": () => (/* binding */ createNew)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createNew = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function newObject(options = {}) {
    const res = await api.post('object/new', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: options.template,
        ...options
      }),
      headers: options.headers
    });
    const {Hash} = await res.json();
    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(Hash);
  }
  return newObject;
});

/***/ }),

/***/ 9879:
/*!************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/object/patch/add-link.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddLink": () => (/* binding */ createAddLink)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ 6117);



const createAddLink = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function addLink(cid, dLink, options = {}) {
    const res = await api.post('object/patch/add-link', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: [
          `${ cid }`,
          dLink.Name || dLink.name || '',
          (dLink.Hash || dLink.cid || '').toString() || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const {Hash} = await res.json();
    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(Hash);
  }
  return addLink;
});

/***/ }),

/***/ 3621:
/*!***************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/object/patch/append-data.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAppendData": () => (/* binding */ createAppendData)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ 8126);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/abort-signal.js */ 13);
/* harmony import */ var native_abort_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! native-abort-controller */ 5353);






const createAppendData = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  async function appendData(cid, data, options = {}) {
    const controller = new native_abort_controller__WEBPACK_IMPORTED_MODULE_5__.AbortController();
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__.abortSignal)(controller.signal, options.signal);
    const res = await api.post('object/patch/append-data', {
      signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: `${ cid }`,
        ...options
      }),
      ...await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__.multipartRequest)(data, controller, options.headers)
    });
    const {Hash} = await res.json();
    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(Hash);
  }
  return appendData;
});

/***/ }),

/***/ 8512:
/*!*********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/object/patch/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPatch": () => (/* binding */ createPatch)
/* harmony export */ });
/* harmony import */ var _add_link_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add-link.js */ 9879);
/* harmony import */ var _append_data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./append-data.js */ 3621);
/* harmony import */ var _rm_link_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rm-link.js */ 7075);
/* harmony import */ var _set_data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./set-data.js */ 2608);




function createPatch(config) {
  return {
    addLink: (0,_add_link_js__WEBPACK_IMPORTED_MODULE_0__.createAddLink)(config),
    appendData: (0,_append_data_js__WEBPACK_IMPORTED_MODULE_1__.createAppendData)(config),
    rmLink: (0,_rm_link_js__WEBPACK_IMPORTED_MODULE_2__.createRmLink)(config),
    setData: (0,_set_data_js__WEBPACK_IMPORTED_MODULE_3__.createSetData)(config)
  };
}

/***/ }),

/***/ 7075:
/*!***********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/object/patch/rm-link.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRmLink": () => (/* binding */ createRmLink)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ 6117);



const createRmLink = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function rmLink(cid, dLink, options = {}) {
    const res = await api.post('object/patch/rm-link', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: [
          `${ cid }`,
          dLink.Name || dLink.name || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const {Hash} = await res.json();
    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(Hash);
  }
  return rmLink;
});

/***/ }),

/***/ 2608:
/*!************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/object/patch/set-data.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSetData": () => (/* binding */ createSetData)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ 8126);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/abort-signal.js */ 13);
/* harmony import */ var native_abort_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! native-abort-controller */ 5353);






const createSetData = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(api => {
  async function setData(cid, data, options = {}) {
    const controller = new native_abort_controller__WEBPACK_IMPORTED_MODULE_5__.AbortController();
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_4__.abortSignal)(controller.signal, options.signal);
    const res = await api.post('object/patch/set-data', {
      signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: [`${ cid }`],
        ...options
      }),
      ...await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_1__.multipartRequest)(data, controller, options.headers)
    });
    const {Hash} = await res.json();
    return multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(Hash);
  }
  return setData;
});

/***/ }),

/***/ 7520:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/object/put.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPut": () => (/* binding */ createPut)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _dag_put_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dag/put.js */ 3641);


const createPut = (codecs, options) => {
  const fn = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
    const dagPut = (0,_dag_put_js__WEBPACK_IMPORTED_MODULE_1__.createPut)(codecs, options);
    async function put(obj, options = {}) {
      return dagPut(obj, {
        ...options,
        format: 'dag-pb',
        hashAlg: 'sha2-256',
        version: 0
      });
    }
    return put;
  });
  return fn(options);
};

/***/ }),

/***/ 5997:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/object/stat.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStat": () => (/* binding */ createStat)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createStat = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function stat(cid, options = {}) {
    const res = await api.post('object/stat', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${ cid }`,
        ...options
      }),
      headers: options.headers
    });
    const output = await res.json();
    return {
      ...output,
      Hash: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(output.Hash)
    };
  }
  return stat;
});

/***/ }),

/***/ 11:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/add-all.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddAll": () => (/* binding */ createAddAll)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var ipfs_core_utils_pins_normalise_input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-core-utils/pins/normalise-input */ 6127);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);




const createAddAll = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function* addAll(source, options = {}) {
    for await (const {path, recursive, metadata} of (0,ipfs_core_utils_pins_normalise_input__WEBPACK_IMPORTED_MODULE_2__.normaliseInput)(source)) {
      const res = await api.post('pin/add', {
        signal: options.signal,
        searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
          ...options,
          arg: path,
          recursive,
          metadata: metadata ? JSON.stringify(metadata) : undefined,
          stream: true
        }),
        headers: options.headers
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          for (const cid of pin.Pins) {
            yield multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(cid);
          }
          continue;
        }
        yield multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(pin);
      }
    }
  }
  return addAll;
});

/***/ }),

/***/ 3295:
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/add.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAdd": () => (/* binding */ createAdd)
/* harmony export */ });
/* harmony import */ var _add_all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add-all.js */ 11);
/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-last */ 3093);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ 5508);



function createAdd(config) {
  const all = (0,_add_all_js__WEBPACK_IMPORTED_MODULE_0__.createAddAll)(config);
  return (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(() => {
    async function add(path, options = {}) {
      return it_last__WEBPACK_IMPORTED_MODULE_1__(all([{
          path,
          ...options
        }], options));
    }
    return add;
  })(config);
}

/***/ }),

/***/ 2606:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPin": () => (/* binding */ createPin)
/* harmony export */ });
/* harmony import */ var _add_all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add-all.js */ 11);
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./add.js */ 3295);
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ls.js */ 9348);
/* harmony import */ var _rm_all_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rm-all.js */ 4449);
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rm.js */ 5956);
/* harmony import */ var _remote_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./remote/index.js */ 2221);






function createPin(config) {
  return {
    addAll: (0,_add_all_js__WEBPACK_IMPORTED_MODULE_0__.createAddAll)(config),
    add: (0,_add_js__WEBPACK_IMPORTED_MODULE_1__.createAdd)(config),
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_2__.createLs)(config),
    rmAll: (0,_rm_all_js__WEBPACK_IMPORTED_MODULE_3__.createRmAll)(config),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_4__.createRm)(config),
    remote: (0,_remote_index_js__WEBPACK_IMPORTED_MODULE_5__.createRemote)(config)
  };
}

/***/ }),

/***/ 9348:
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/ls.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": () => (/* binding */ createLs)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



function toPin(type, cid, metadata) {
  const pin = {
    type,
    cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(cid)
  };
  if (metadata) {
    pin.metadata = metadata;
  }
  return pin;
}
const createLs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function* ls(options = {}) {
    let paths = [];
    if (options.paths) {
      paths = Array.isArray(options.paths) ? options.paths : [options.paths];
    }
    const res = await api.post('pin/ls', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        ...options,
        arg: paths.map(path => `${ path }`),
        stream: true
      }),
      headers: options.headers
    });
    for await (const pin of res.ndjson()) {
      if (pin.Keys) {
        for (const cid of Object.keys(pin.Keys)) {
          yield toPin(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata);
        }
        return;
      }
      yield toPin(pin.Type, pin.Cid, pin.Metadata);
    }
  }
  return ls;
});

/***/ }),

/***/ 5910:
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/remote/add.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAdd": () => (/* binding */ createAdd)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ 3012);

function createAdd(client) {
  async function add(cid, {timeout, signal, headers, ...query}) {
    const response = await client.post('pin/remote/add', {
      timeout,
      signal,
      headers,
      searchParams: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.encodeAddParams)({
        cid,
        ...query
      })
    });
    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.decodePin)(await response.json());
  }
  return add;
}

/***/ }),

/***/ 2221:
/*!*******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/remote/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRemote": () => (/* binding */ createRemote)
/* harmony export */ });
/* harmony import */ var _lib_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/core.js */ 2902);
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./add.js */ 5910);
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ls.js */ 9235);
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rm.js */ 4882);
/* harmony import */ var _rm_all_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rm-all.js */ 2490);
/* harmony import */ var _service_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./service/index.js */ 994);






function createRemote(config) {
  const client = new _lib_core_js__WEBPACK_IMPORTED_MODULE_0__.Client(config);
  return {
    add: (0,_add_js__WEBPACK_IMPORTED_MODULE_1__.createAdd)(client),
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_2__.createLs)(client),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_3__.createRm)(client),
    rmAll: (0,_rm_all_js__WEBPACK_IMPORTED_MODULE_4__.createRmAll)(client),
    service: (0,_service_index_js__WEBPACK_IMPORTED_MODULE_5__.createService)(config)
  };
}

/***/ }),

/***/ 9235:
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/remote/ls.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": () => (/* binding */ createLs)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ 3012);

function createLs(client) {
  async function* ls({timeout, signal, headers, ...query}) {
    const response = await client.post('pin/remote/ls', {
      timeout,
      signal,
      headers,
      searchParams: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.encodeQuery)(query)
    });
    for await (const pin of response.ndjson()) {
      yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.decodePin)(pin);
    }
  }
  return ls;
}

/***/ }),

/***/ 2490:
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/remote/rm-all.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRmAll": () => (/* binding */ createRmAll)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ 3012);

function createRmAll(client) {
  async function rmAll({timeout, signal, headers, ...query}) {
    await client.post('pin/remote/rm', {
      timeout,
      signal,
      headers,
      searchParams: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.encodeQuery)({
        ...query,
        all: true
      })
    });
  }
  return rmAll;
}

/***/ }),

/***/ 4882:
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/remote/rm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": () => (/* binding */ createRm)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ 3012);

function createRm(client) {
  async function rm({timeout, signal, headers, ...query}) {
    await client.post('pin/remote/rm', {
      timeout,
      signal,
      headers,
      searchParams: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.encodeQuery)({
        ...query,
        all: false
      })
    });
  }
  return rm;
}

/***/ }),

/***/ 7027:
/*!*************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/remote/service/add.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAdd": () => (/* binding */ createAdd)
/* harmony export */ });
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ 7979);


function createAdd(client) {
  async function add(name, options) {
    const {endpoint, key, headers, timeout, signal} = options;
    await client.post('pin/remote/service/add', {
      timeout,
      signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_0__.toUrlSearchParams)({
        arg: [
          name,
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.encodeEndpoint)(endpoint),
          key
        ]
      }),
      headers
    });
  }
  return add;
}

/***/ }),

/***/ 994:
/*!***************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/remote/service/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createService": () => (/* binding */ createService)
/* harmony export */ });
/* harmony import */ var _lib_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/core.js */ 2902);
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./add.js */ 7027);
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ls.js */ 5600);
/* harmony import */ var _rm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rm.js */ 8992);




function createService(config) {
  const client = new _lib_core_js__WEBPACK_IMPORTED_MODULE_0__.Client(config);
  return {
    add: (0,_add_js__WEBPACK_IMPORTED_MODULE_1__.createAdd)(client),
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_2__.createLs)(client),
    rm: (0,_rm_js__WEBPACK_IMPORTED_MODULE_3__.createRm)(client)
  };
}

/***/ }),

/***/ 5600:
/*!************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/remote/service/ls.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": () => (/* binding */ createLs)
/* harmony export */ });
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ 7979);


function createLs(client) {
  async function ls(options = {}) {
    const {stat, headers, timeout, signal} = options;
    const response = await client.post('pin/remote/service/ls', {
      timeout,
      signal,
      headers,
      searchParams: stat === true ? (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_0__.toUrlSearchParams)({ stat }) : undefined
    });
    const {RemoteServices} = await response.json();
    return RemoteServices.map(_utils_js__WEBPACK_IMPORTED_MODULE_1__.decodeRemoteService);
  }
  return ls;
}

/***/ }),

/***/ 8992:
/*!************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/remote/service/rm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": () => (/* binding */ createRm)
/* harmony export */ });
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/to-url-search-params.js */ 6117);

function createRm(client) {
  async function rm(name, options = {}) {
    await client.post('pin/remote/service/rm', {
      signal: options.signal,
      headers: options.headers,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_0__.toUrlSearchParams)({ arg: name })
    });
  }
  return rm;
}

/***/ }),

/***/ 7979:
/*!***************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/remote/service/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "encodeEndpoint": () => (/* binding */ encodeEndpoint),
/* harmony export */   "decodeRemoteService": () => (/* binding */ decodeRemoteService),
/* harmony export */   "decodeStat": () => (/* binding */ decodeStat)
/* harmony export */ });
function encodeEndpoint(url) {
  const href = String(url);
  if (href === 'undefined') {
    throw Error('endpoint is required');
  }
  return href[href.length - 1] === '/' ? href.slice(0, -1) : href;
}
function decodeRemoteService(json) {
  return {
    service: json.Service,
    endpoint: new URL(json.ApiEndpoint),
    ...json.Stat && { stat: decodeStat(json.Stat) }
  };
}
function decodeStat(json) {
  switch (json.Status) {
  case 'valid': {
      const {Pinning, Pinned, Queued, Failed} = json.PinCount;
      return {
        status: 'valid',
        pinCount: {
          queued: Queued,
          pinning: Pinning,
          pinned: Pinned,
          failed: Failed
        }
      };
    }
  case 'invalid': {
      return { status: 'invalid' };
    }
  default: {
      return { status: json.Status };
    }
  }
}

/***/ }),

/***/ 3012:
/*!*******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/remote/utils.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodePin": () => (/* binding */ decodePin),
/* harmony export */   "encodeService": () => (/* binding */ encodeService),
/* harmony export */   "encodeCID": () => (/* binding */ encodeCID),
/* harmony export */   "encodeQuery": () => (/* binding */ encodeQuery),
/* harmony export */   "encodeAddParams": () => (/* binding */ encodeAddParams)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/to-url-search-params.js */ 6117);


const decodePin = ({
  Name: name,
  Status: status,
  Cid: cid
}) => {
  return {
    cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(cid),
    name,
    status
  };
};
const encodeService = service => {
  if (typeof service === 'string' && service !== '') {
    return service;
  } else {
    throw new TypeError('service name must be passed');
  }
};
const encodeCID = cid => {
  if (multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.asCID(cid)) {
    return cid.toString();
  } else {
    throw new TypeError(`CID instance expected instead of ${ typeof cid }`);
  }
};
const encodeQuery = ({service, cid, name, status, all}) => {
  const query = (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
    service: encodeService(service),
    name,
    force: all ? true : undefined
  });
  if (cid) {
    for (const value of cid) {
      query.append('cid', encodeCID(value));
    }
  }
  if (status) {
    for (const value of status) {
      query.append('status', value);
    }
  }
  return query;
};
const encodeAddParams = ({cid, service, background, name, origins}) => {
  const params = (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
    arg: encodeCID(cid),
    service: encodeService(service),
    name,
    background: background ? true : undefined
  });
  if (origins) {
    for (const origin of origins) {
      params.append('origin', origin.toString());
    }
  }
  return params;
};

/***/ }),

/***/ 4449:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/rm-all.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRmAll": () => (/* binding */ createRmAll)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var ipfs_core_utils_pins_normalise_input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-core-utils/pins/normalise-input */ 6127);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);




const createRmAll = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function* rmAll(source, options = {}) {
    for await (const {path, recursive} of (0,ipfs_core_utils_pins_normalise_input__WEBPACK_IMPORTED_MODULE_2__.normaliseInput)(source)) {
      const searchParams = new URLSearchParams(options.searchParams);
      searchParams.append('arg', `${ path }`);
      if (recursive != null)
        searchParams.set('recursive', String(recursive));
      const res = await api.post('pin/rm', {
        signal: options.signal,
        headers: options.headers,
        searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
          ...options,
          arg: `${ path }`,
          recursive
        })
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          yield* pin.Pins.map(cid => multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(cid));
          continue;
        }
        yield multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(pin);
      }
    }
  }
  return rmAll;
});

/***/ }),

/***/ 5956:
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pin/rm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRm": () => (/* binding */ createRm)
/* harmony export */ });
/* harmony import */ var _rm_all_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rm-all.js */ 4449);
/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-last */ 3093);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ 5508);



const createRm = config => {
  const all = (0,_rm_all_js__WEBPACK_IMPORTED_MODULE_0__.createRmAll)(config);
  return (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)(() => {
    async function rm(path, options = {}) {
      return it_last__WEBPACK_IMPORTED_MODULE_1__(all([{
          path,
          ...options
        }], options));
    }
    return rm;
  })(config);
};

/***/ }),

/***/ 8181:
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/ping.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPing": () => (/* binding */ createPing)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ 6117);



const createPing = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function* ping(peerId, options = {}) {
    const res = await api.post('ping', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)({
        arg: `${ peerId }`,
        ...options
      }),
      headers: options.headers,
      transform: _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel
    });
    yield* res.ndjson();
  }
  return ping;
});

/***/ }),

/***/ 4719:
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pubsub/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPubsub": () => (/* binding */ createPubsub)
/* harmony export */ });
/* harmony import */ var _ls_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ls.js */ 9093);
/* harmony import */ var _peers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./peers.js */ 9580);
/* harmony import */ var _publish_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./publish.js */ 993);
/* harmony import */ var _subscribe_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./subscribe.js */ 5246);
/* harmony import */ var _unsubscribe_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./unsubscribe.js */ 7294);
/* harmony import */ var _subscription_tracker_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./subscription-tracker.js */ 4776);






function createPubsub(config) {
  const subscriptionTracker = new _subscription_tracker_js__WEBPACK_IMPORTED_MODULE_5__.SubscriptionTracker();
  return {
    ls: (0,_ls_js__WEBPACK_IMPORTED_MODULE_0__.createLs)(config),
    peers: (0,_peers_js__WEBPACK_IMPORTED_MODULE_1__.createPeers)(config),
    publish: (0,_publish_js__WEBPACK_IMPORTED_MODULE_2__.createPublish)(config),
    subscribe: (0,_subscribe_js__WEBPACK_IMPORTED_MODULE_3__.createSubscribe)(config, subscriptionTracker),
    unsubscribe: (0,_unsubscribe_js__WEBPACK_IMPORTED_MODULE_4__.createUnsubscribe)(config, subscriptionTracker)
  };
}

/***/ }),

/***/ 9093:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pubsub/ls.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLs": () => (/* binding */ createLs)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createLs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function ls(options = {}) {
    const {Strings} = await (await api.post('pubsub/ls', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })).json();
    return Strings || [];
  }
  return ls;
});

/***/ }),

/***/ 9580:
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pubsub/peers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPeers": () => (/* binding */ createPeers)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createPeers = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function peers(topic, options = {}) {
    const res = await api.post('pubsub/peers', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: topic,
        ...options
      }),
      headers: options.headers
    });
    const {Strings} = await res.json();
    return Strings || [];
  }
  return peers;
});

/***/ }),

/***/ 993:
/*!*****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pubsub/publish.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPublish": () => (/* binding */ createPublish)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-core-utils/multipart-request */ 8126);
/* harmony import */ var _lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/abort-signal.js */ 13);
/* harmony import */ var native_abort_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! native-abort-controller */ 5353);





const createPublish = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function publish(topic, data, options = {}) {
    const searchParams = (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
      arg: topic,
      ...options
    });
    const controller = new native_abort_controller__WEBPACK_IMPORTED_MODULE_4__.AbortController();
    const signal = (0,_lib_abort_signal_js__WEBPACK_IMPORTED_MODULE_3__.abortSignal)(controller.signal, options.signal);
    const res = await api.post('pubsub/pub', {
      signal,
      searchParams,
      ...await (0,ipfs_core_utils_multipart_request__WEBPACK_IMPORTED_MODULE_2__.multipartRequest)(data, controller, options.headers)
    });
    await res.text();
  }
  return publish;
});

/***/ }),

/***/ 5246:
/*!*******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pubsub/subscribe.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSubscribe": () => (/* binding */ createSubscribe)
/* harmony export */ });
/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/from-string */ 2217);
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/to-string */ 2263);
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ 1227);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);





const log = debug__WEBPACK_IMPORTED_MODULE_2__('ipfs-http-client:pubsub:subscribe');
const createSubscribe = (options, subsTracker) => {
  return (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_3__.configure)(api => {
    async function subscribe(topic, handler, options = {}) {
      options.signal = subsTracker.subscribe(topic, handler, options.signal);
      let done;
      let fail;
      const result = new Promise((resolve, reject) => {
        done = resolve;
        fail = reject;
      });
      const ffWorkaround = setTimeout(() => done(), 1000);
      api.post('pubsub/sub', {
        signal: options.signal,
        searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_4__.toUrlSearchParams)({
          arg: topic,
          ...options
        }),
        headers: options.headers
      }).catch(err => {
        subsTracker.unsubscribe(topic, handler);
        fail(err);
      }).then(response => {
        clearTimeout(ffWorkaround);
        if (!response) {
          return;
        }
        readMessages(response, {
          onMessage: handler,
          onEnd: () => subsTracker.unsubscribe(topic, handler),
          onError: options.onError
        });
        done();
      });
      return result;
    }
    return subscribe;
  })(options);
};
async function readMessages(response, {onMessage, onEnd, onError}) {
  onError = onError || log;
  try {
    for await (const msg of response.ndjson()) {
      try {
        if (!msg.from) {
          continue;
        }
        onMessage({
          from: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__.fromString)(msg.from, 'base64pad'), 'base58btc'),
          data: (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__.fromString)(msg.data, 'base64pad'),
          seqno: (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__.fromString)(msg.seqno, 'base64pad'),
          topicIDs: msg.topicIDs
        });
      } catch (err) {
        err.message = `Failed to parse pubsub message: ${ err.message }`;
        onError(err, false, msg);
      }
    }
  } catch (err) {
    if (!isAbortError(err)) {
      onError(err, true);
    }
  } finally {
    onEnd();
  }
}
const isAbortError = error => {
  switch (error.type) {
  case 'aborted':
    return true;
  case 'abort':
    return true;
  default:
    return error.name === 'AbortError';
  }
};

/***/ }),

/***/ 4776:
/*!******************************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pubsub/subscription-tracker.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SubscriptionTracker": () => (/* binding */ SubscriptionTracker)
/* harmony export */ });
/* harmony import */ var native_abort_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! native-abort-controller */ 5353);

class SubscriptionTracker {
  constructor() {
    this._subs = new Map();
  }
  subscribe(topic, handler, signal) {
    const topicSubs = this._subs.get(topic) || [];
    if (topicSubs.find(s => s.handler === handler)) {
      throw new Error(`Already subscribed to ${ topic } with this handler`);
    }
    const controller = new native_abort_controller__WEBPACK_IMPORTED_MODULE_0__.AbortController();
    this._subs.set(topic, [{
        handler,
        controller
      }].concat(topicSubs));
    if (signal) {
      signal.addEventListener('abort', () => this.unsubscribe(topic, handler));
    }
    return controller.signal;
  }
  unsubscribe(topic, handler) {
    const subs = this._subs.get(topic) || [];
    let unsubs;
    if (handler) {
      this._subs.set(topic, subs.filter(s => s.handler !== handler));
      unsubs = subs.filter(s => s.handler === handler);
    } else {
      this._subs.set(topic, []);
      unsubs = subs;
    }
    if (!(this._subs.get(topic) || []).length) {
      this._subs.delete(topic);
    }
    unsubs.forEach(s => s.controller.abort());
  }
}

/***/ }),

/***/ 7294:
/*!*********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/pubsub/unsubscribe.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createUnsubscribe": () => (/* binding */ createUnsubscribe)
/* harmony export */ });
const createUnsubscribe = (options, subsTracker) => {
  async function unsubscribe(topic, handler) {
    subsTracker.unsubscribe(topic, handler);
  }
  return unsubscribe;
};

/***/ }),

/***/ 4501:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/refs/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRefs": () => (/* binding */ createRefs)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);
/* harmony import */ var _local_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./local.js */ 356);





const createRefs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_2__.configure)((api, opts) => {
  const refs = async function* (args, options = {}) {
    const argsArr = Array.isArray(args) ? args : [args];
    const res = await api.post('refs', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_3__.toUrlSearchParams)({
        arg: argsArr.map(arg => `${ arg instanceof Uint8Array ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.decode(arg) : arg }`),
        ...options
      }),
      headers: options.headers,
      transform: _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_1__.objectToCamel
    });
    yield* res.ndjson();
  };
  return Object.assign(refs, { local: (0,_local_js__WEBPACK_IMPORTED_MODULE_4__.createLocal)(opts) });
});

/***/ }),

/***/ 356:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/refs/local.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLocal": () => (/* binding */ createLocal)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createLocal = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function* refsLocal(options = {}) {
    const res = await api.post('refs/local', {
      signal: options.signal,
      transform: _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return refsLocal;
});

/***/ }),

/***/ 8355:
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/repo/gc.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGc": () => (/* binding */ createGc)
/* harmony export */ });
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ 1362);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createGc = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function* gc(options = {}) {
    const res = await api.post('repo/gc', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers,
      transform: res => {
        return {
          err: res.Error ? new Error(res.Error) : null,
          cid: (res.Key || {})['/'] ? multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse(res.Key['/']) : null
        };
      }
    });
    yield* res.ndjson();
  }
  return gc;
});

/***/ }),

/***/ 3114:
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/repo/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRepo": () => (/* binding */ createRepo)
/* harmony export */ });
/* harmony import */ var _gc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gc.js */ 8355);
/* harmony import */ var _stat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stat.js */ 7058);
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./version.js */ 5191);



function createRepo(config) {
  return {
    gc: (0,_gc_js__WEBPACK_IMPORTED_MODULE_0__.createGc)(config),
    stat: (0,_stat_js__WEBPACK_IMPORTED_MODULE_1__.createStat)(config),
    version: (0,_version_js__WEBPACK_IMPORTED_MODULE_2__.createVersion)(config)
  };
}

/***/ }),

/***/ 7058:
/*!************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/repo/stat.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStat": () => (/* binding */ createStat)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createStat = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function stat(options = {}) {
    const res = await api.post('repo/stat', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    });
    const data = await res.json();
    return {
      numObjects: BigInt(data.NumObjects),
      repoSize: BigInt(data.RepoSize),
      repoPath: data.RepoPath,
      version: data.Version,
      storageMax: BigInt(data.StorageMax)
    };
  }
  return stat;
});

/***/ }),

/***/ 5191:
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/repo/version.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createVersion": () => (/* binding */ createVersion)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createVersion = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function version(options = {}) {
    const res = await (await api.post('repo/version', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    })).json();
    return res.Version;
  }
  return version;
});

/***/ }),

/***/ 3055:
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/resolve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createResolve": () => (/* binding */ createResolve)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ 6117);


const createResolve = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function resolve(path, options = {}) {
    const res = await api.post('resolve', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const {Path} = await res.json();
    return Path;
  }
  return resolve;
});

/***/ }),

/***/ 7140:
/*!********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/start.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStart": () => (/* binding */ createStart)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! err-code */ 2114);


const createStart = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  const start = async (options = {}) => {
    throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED');
  };
  return start;
});

/***/ }),

/***/ 1371:
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/stats/bw.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createBw": () => (/* binding */ createBw)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createBw = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function* bw(options = {}) {
    const res = await api.post('stats/bw', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers,
      transform: stats => ({
        totalIn: BigInt(stats.TotalIn),
        totalOut: BigInt(stats.TotalOut),
        rateIn: parseFloat(stats.RateIn),
        rateOut: parseFloat(stats.RateOut)
      })
    });
    yield* res.ndjson();
  }
  return bw;
});

/***/ }),

/***/ 9255:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/stats/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStats": () => (/* binding */ createStats)
/* harmony export */ });
/* harmony import */ var _bitswap_stat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bitswap/stat.js */ 7502);
/* harmony import */ var _repo_stat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../repo/stat.js */ 7058);
/* harmony import */ var _bw_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bw.js */ 1371);



function createStats(config) {
  return {
    bitswap: (0,_bitswap_stat_js__WEBPACK_IMPORTED_MODULE_0__.createStat)(config),
    repo: (0,_repo_stat_js__WEBPACK_IMPORTED_MODULE_1__.createStat)(config),
    bw: (0,_bw_js__WEBPACK_IMPORTED_MODULE_2__.createBw)(config)
  };
}

/***/ }),

/***/ 5923:
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/stop.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStop": () => (/* binding */ createStop)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ 6117);


const createStop = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function stop(options = {}) {
    const res = await api.post('shutdown', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)(options),
      headers: options.headers
    });
    await res.text();
  }
  return stop;
});

/***/ }),

/***/ 4026:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/swarm/addrs.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddrs": () => (/* binding */ createAddrs)
/* harmony export */ });
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiaddr */ 6584);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createAddrs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function addrs(options = {}) {
    const res = await api.post('swarm/addrs', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    });
    const {Addrs} = await res.json();
    return Object.keys(Addrs).map(id => ({
      id,
      addrs: (Addrs[id] || []).map(a => new multiaddr__WEBPACK_IMPORTED_MODULE_0__.Multiaddr(a))
    }));
  }
  return addrs;
});

/***/ }),

/***/ 895:
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/swarm/connect.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createConnect": () => (/* binding */ createConnect)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createConnect = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function connect(addr, options = {}) {
    const res = await api.post('swarm/connect', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const {Strings} = await res.json();
    return Strings || [];
  }
  return connect;
});

/***/ }),

/***/ 505:
/*!*******************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/swarm/disconnect.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDisconnect": () => (/* binding */ createDisconnect)
/* harmony export */ });
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);


const createDisconnect = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_0__.configure)(api => {
  async function disconnect(addr, options = {}) {
    const res = await api.post('swarm/disconnect', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_1__.toUrlSearchParams)({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const {Strings} = await res.json();
    return Strings || [];
  }
  return disconnect;
});

/***/ }),

/***/ 7619:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/swarm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSwarm": () => (/* binding */ createSwarm)
/* harmony export */ });
/* harmony import */ var _addrs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addrs.js */ 4026);
/* harmony import */ var _connect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./connect.js */ 895);
/* harmony import */ var _disconnect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./disconnect.js */ 505);
/* harmony import */ var _local_addrs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./local-addrs.js */ 3134);
/* harmony import */ var _peers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./peers.js */ 1133);





function createSwarm(config) {
  return {
    addrs: (0,_addrs_js__WEBPACK_IMPORTED_MODULE_0__.createAddrs)(config),
    connect: (0,_connect_js__WEBPACK_IMPORTED_MODULE_1__.createConnect)(config),
    disconnect: (0,_disconnect_js__WEBPACK_IMPORTED_MODULE_2__.createDisconnect)(config),
    localAddrs: (0,_local_addrs_js__WEBPACK_IMPORTED_MODULE_3__.createLocalAddrs)(config),
    peers: (0,_peers_js__WEBPACK_IMPORTED_MODULE_4__.createPeers)(config)
  };
}

/***/ }),

/***/ 3134:
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/swarm/local-addrs.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLocalAddrs": () => (/* binding */ createLocalAddrs)
/* harmony export */ });
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiaddr */ 6584);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createLocalAddrs = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function localAddrs(options = {}) {
    const res = await api.post('swarm/addrs/local', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    });
    const {Strings} = await res.json();
    return (Strings || []).map(a => new multiaddr__WEBPACK_IMPORTED_MODULE_0__.Multiaddr(a));
  }
  return localAddrs;
});

/***/ }),

/***/ 1133:
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/swarm/peers.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPeers": () => (/* binding */ createPeers)
/* harmony export */ });
/* harmony import */ var multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiaddr */ 6584);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/to-url-search-params.js */ 6117);



const createPeers = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function peers(options = {}) {
    const res = await api.post('swarm/peers', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    });
    const {Peers} = await res.json();
    return (Peers || []).map(peer => {
      return {
        addr: new multiaddr__WEBPACK_IMPORTED_MODULE_0__.Multiaddr(peer.Addr),
        peer: peer.Peer,
        muxer: peer.Muxer,
        latency: peer.Latency,
        streams: peer.Streams,
        direction: peer.Direction == null ? undefined : peer.Direction === 0 ? 'inbound' : 'outbound'
      };
    });
  }
  return peers;
});

/***/ }),

/***/ 8960:
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-http-client/esm/src/version.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createVersion": () => (/* binding */ createVersion)
/* harmony export */ });
/* harmony import */ var _lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/object-to-camel.js */ 988);
/* harmony import */ var _lib_configure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/configure.js */ 5508);
/* harmony import */ var _lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/to-url-search-params.js */ 6117);



const createVersion = (0,_lib_configure_js__WEBPACK_IMPORTED_MODULE_1__.configure)(api => {
  async function version(options = {}) {
    const res = await api.post('version', {
      signal: options.signal,
      searchParams: (0,_lib_to_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.toUrlSearchParams)(options),
      headers: options.headers
    });
    return {
      ...(0,_lib_object_to_camel_js__WEBPACK_IMPORTED_MODULE_0__.objectToCamel)(await res.json()),
      'ipfs-http-client': '1.0.0'
    };
  }
  return version;
});

/***/ }),

/***/ 4427:
/*!***************************************************!*\
  !*** ./node_modules/ipfs-unixfs/esm/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseMode": () => (/* binding */ parseMode),
/* harmony export */   "parseMtime": () => (/* binding */ parseMtime),
/* harmony export */   "UnixFS": () => (/* binding */ UnixFS)
/* harmony export */ });
/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ 2114);
/* harmony import */ var _unixfs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unixfs.js */ 9720);


const PBData = _unixfs_js__WEBPACK_IMPORTED_MODULE_1__.Data;
const types = [
  'raw',
  'directory',
  'file',
  'metadata',
  'symlink',
  'hamt-sharded-directory'
];
const dirTypes = [
  'directory',
  'hamt-sharded-directory'
];
const DEFAULT_FILE_MODE = parseInt('0644', 8);
const DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);
function parseMode(mode) {
  if (mode == null) {
    return undefined;
  }
  if (typeof mode === 'number') {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === '0') {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime(input) {
  if (input == null) {
    return undefined;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1000);
    mtime = {
      secs: secs,
      nsecs: (ms - secs * 1000) * 1000
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {
    return undefined;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');
  }
  return mtime;
}
class UnixFS {
  static unmarshal(marshaled) {
    const message = PBData.decode(marshaled);
    const decoded = PBData.toObject(message, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const data = new UnixFS({
      type: types[decoded.Type],
      data: decoded.Data,
      blockSizes: decoded.blocksizes,
      mode: decoded.mode,
      mtime: decoded.mtime ? {
        secs: decoded.mtime.Seconds,
        nsecs: decoded.mtime.FractionalNanoseconds
      } : undefined
    });
    data._originalMode = decoded.mode || 0;
    return data;
  }
  constructor(options = { type: 'file' }) {
    const {type, data, blockSizes, hashType, fanout, mtime, mode} = options;
    if (type && !types.includes(type)) {
      throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');
    }
    this.type = type || 'file';
    this.data = data;
    this.hashType = hashType;
    this.fanout = fanout;
    this.blockSizes = blockSizes || [];
    this._originalMode = 0;
    this.mode = parseMode(mode);
    if (mtime) {
      this.mtime = parseMtime(mtime);
      if (this.mtime && !this.mtime.nsecs) {
        this.mtime.nsecs = 0;
      }
    }
  }
  set mode(mode) {
    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
    const parsedMode = parseMode(mode);
    if (parsedMode !== undefined) {
      this._mode = parsedMode;
    }
  }
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return Boolean(this.type && dirTypes.includes(this.type));
  }
  addBlockSize(size) {
    this.blockSizes.push(size);
  }
  removeBlockSize(index) {
    this.blockSizes.splice(index, 1);
  }
  fileSize() {
    if (this.isDirectory()) {
      return 0;
    }
    let sum = 0;
    this.blockSizes.forEach(size => {
      sum += size;
    });
    if (this.data) {
      sum += this.data.length;
    }
    return sum;
  }
  marshal() {
    let type;
    switch (this.type) {
    case 'raw':
      type = PBData.DataType.Raw;
      break;
    case 'directory':
      type = PBData.DataType.Directory;
      break;
    case 'file':
      type = PBData.DataType.File;
      break;
    case 'metadata':
      type = PBData.DataType.Metadata;
      break;
    case 'symlink':
      type = PBData.DataType.Symlink;
      break;
    case 'hamt-sharded-directory':
      type = PBData.DataType.HAMTShard;
      break;
    default:
      throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');
    }
    let data = this.data;
    if (!this.data || !this.data.length) {
      data = undefined;
    }
    let mode;
    if (this.mode != null) {
      mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode = undefined;
      }
      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode = undefined;
      }
    }
    let mtime;
    if (this.mtime != null) {
      const parsed = parseMtime(this.mtime);
      if (parsed) {
        mtime = {
          Seconds: parsed.secs,
          FractionalNanoseconds: parsed.nsecs
        };
        if (mtime.FractionalNanoseconds === 0) {
          delete mtime.FractionalNanoseconds;
        }
      }
    }
    const pbData = {
      Type: type,
      Data: data,
      filesize: this.isDirectory() ? undefined : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode,
      mtime
    };
    return PBData.encode(pbData).finish();
  }
}


/***/ }),

/***/ 9720:
/*!****************************************************!*\
  !*** ./node_modules/ipfs-unixfs/esm/src/unixfs.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Data": () => (/* binding */ Data),
/* harmony export */   "UnixTime": () => (/* binding */ UnixTime),
/* harmony export */   "Metadata": () => (/* binding */ Metadata),
/* harmony export */   "default": () => (/* binding */ $root)
/* harmony export */ });
/* harmony import */ var protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal.js */ 2100);

const $Reader = protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.Reader, $Writer = protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.Writer, $util = protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.util;
const $root = protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.roots["ipfs-unixfs"] || (protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.roots["ipfs-unixfs"] = {});
const Data = $root.Data = (() => {
  function Data(p) {
    this.blocksizes = [];
    if (p)
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
  }
  Data.prototype.Type = 0;
  Data.prototype.Data = $util.newBuffer([]);
  Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data.prototype.blocksizes = $util.emptyArray;
  Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data.prototype.mode = 0;
  Data.prototype.mtime = null;
  Data.encode = function encode(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int32(m.Type);
    if (m.Data != null && Object.hasOwnProperty.call(m, 'Data'))
      w.uint32(18).bytes(m.Data);
    if (m.filesize != null && Object.hasOwnProperty.call(m, 'filesize'))
      w.uint32(24).uint64(m.filesize);
    if (m.blocksizes != null && m.blocksizes.length) {
      for (var i = 0; i < m.blocksizes.length; ++i)
        w.uint32(32).uint64(m.blocksizes[i]);
    }
    if (m.hashType != null && Object.hasOwnProperty.call(m, 'hashType'))
      w.uint32(40).uint64(m.hashType);
    if (m.fanout != null && Object.hasOwnProperty.call(m, 'fanout'))
      w.uint32(48).uint64(m.fanout);
    if (m.mode != null && Object.hasOwnProperty.call(m, 'mode'))
      w.uint32(56).uint32(m.mode);
    if (m.mtime != null && Object.hasOwnProperty.call(m, 'mtime'))
      $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
    return w;
  };
  Data.decode = function decode(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
      case 1:
        m.Type = r.int32();
        break;
      case 2:
        m.Data = r.bytes();
        break;
      case 3:
        m.filesize = r.uint64();
        break;
      case 4:
        if (!(m.blocksizes && m.blocksizes.length))
          m.blocksizes = [];
        if ((t & 7) === 2) {
          var c2 = r.uint32() + r.pos;
          while (r.pos < c2)
            m.blocksizes.push(r.uint64());
        } else
          m.blocksizes.push(r.uint64());
        break;
      case 5:
        m.hashType = r.uint64();
        break;
      case 6:
        m.fanout = r.uint64();
        break;
      case 7:
        m.mode = r.uint32();
        break;
      case 8:
        m.mtime = $root.UnixTime.decode(r, r.uint32());
        break;
      default:
        r.skipType(t & 7);
        break;
      }
    }
    if (!m.hasOwnProperty('Type'))
      throw $util.ProtocolError('missing required \'Type\'', { instance: m });
    return m;
  };
  Data.fromObject = function fromObject(d) {
    if (d instanceof $root.Data)
      return d;
    var m = new $root.Data();
    switch (d.Type) {
    case 'Raw':
    case 0:
      m.Type = 0;
      break;
    case 'Directory':
    case 1:
      m.Type = 1;
      break;
    case 'File':
    case 2:
      m.Type = 2;
      break;
    case 'Metadata':
    case 3:
      m.Type = 3;
      break;
    case 'Symlink':
    case 4:
      m.Type = 4;
      break;
    case 'HAMTShard':
    case 5:
      m.Type = 5;
      break;
    }
    if (d.Data != null) {
      if (typeof d.Data === 'string')
        $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
      else if (d.Data.length)
        m.Data = d.Data;
    }
    if (d.filesize != null) {
      if ($util.Long)
        (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
      else if (typeof d.filesize === 'string')
        m.filesize = parseInt(d.filesize, 10);
      else if (typeof d.filesize === 'number')
        m.filesize = d.filesize;
      else if (typeof d.filesize === 'object')
        m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
    }
    if (d.blocksizes) {
      if (!Array.isArray(d.blocksizes))
        throw TypeError('.Data.blocksizes: array expected');
      m.blocksizes = [];
      for (var i = 0; i < d.blocksizes.length; ++i) {
        if ($util.Long)
          (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
        else if (typeof d.blocksizes[i] === 'string')
          m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
        else if (typeof d.blocksizes[i] === 'number')
          m.blocksizes[i] = d.blocksizes[i];
        else if (typeof d.blocksizes[i] === 'object')
          m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
      }
    }
    if (d.hashType != null) {
      if ($util.Long)
        (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
      else if (typeof d.hashType === 'string')
        m.hashType = parseInt(d.hashType, 10);
      else if (typeof d.hashType === 'number')
        m.hashType = d.hashType;
      else if (typeof d.hashType === 'object')
        m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
    }
    if (d.fanout != null) {
      if ($util.Long)
        (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
      else if (typeof d.fanout === 'string')
        m.fanout = parseInt(d.fanout, 10);
      else if (typeof d.fanout === 'number')
        m.fanout = d.fanout;
      else if (typeof d.fanout === 'object')
        m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
    }
    if (d.mode != null) {
      m.mode = d.mode >>> 0;
    }
    if (d.mtime != null) {
      if (typeof d.mtime !== 'object')
        throw TypeError('.Data.mtime: object expected');
      m.mtime = $root.UnixTime.fromObject(d.mtime);
    }
    return m;
  };
  Data.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocksizes = [];
    }
    if (o.defaults) {
      d.Type = o.enums === String ? 'Raw' : 0;
      if (o.bytes === String)
        d.Data = '';
      else {
        d.Data = [];
        if (o.bytes !== Array)
          d.Data = $util.newBuffer(d.Data);
      }
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.filesize = o.longs === String ? '0' : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.hashType = o.longs === String ? '0' : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.fanout = o.longs === String ? '0' : 0;
      d.mode = 0;
      d.mtime = null;
    }
    if (m.Type != null && m.hasOwnProperty('Type')) {
      d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
    }
    if (m.Data != null && m.hasOwnProperty('Data')) {
      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
    }
    if (m.filesize != null && m.hasOwnProperty('filesize')) {
      if (typeof m.filesize === 'number')
        d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
      else
        d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
    }
    if (m.blocksizes && m.blocksizes.length) {
      d.blocksizes = [];
      for (var j = 0; j < m.blocksizes.length; ++j) {
        if (typeof m.blocksizes[j] === 'number')
          d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
        else
          d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
      }
    }
    if (m.hashType != null && m.hasOwnProperty('hashType')) {
      if (typeof m.hashType === 'number')
        d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
      else
        d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
    }
    if (m.fanout != null && m.hasOwnProperty('fanout')) {
      if (typeof m.fanout === 'number')
        d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
      else
        d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
    }
    if (m.mode != null && m.hasOwnProperty('mode')) {
      d.mode = m.mode;
    }
    if (m.mtime != null && m.hasOwnProperty('mtime')) {
      d.mtime = $root.UnixTime.toObject(m.mtime, o);
    }
    return d;
  };
  Data.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.util.toJSONOptions);
  };
  Data.DataType = function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'Raw'] = 0;
    values[valuesById[1] = 'Directory'] = 1;
    values[valuesById[2] = 'File'] = 2;
    values[valuesById[3] = 'Metadata'] = 3;
    values[valuesById[4] = 'Symlink'] = 4;
    values[valuesById[5] = 'HAMTShard'] = 5;
    return values;
  }();
  return Data;
})();
const UnixTime = $root.UnixTime = (() => {
  function UnixTime(p) {
    if (p)
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
  }
  UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
  UnixTime.prototype.FractionalNanoseconds = 0;
  UnixTime.encode = function encode(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int64(m.Seconds);
    if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, 'FractionalNanoseconds'))
      w.uint32(21).fixed32(m.FractionalNanoseconds);
    return w;
  };
  UnixTime.decode = function decode(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l, m = new $root.UnixTime();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
      case 1:
        m.Seconds = r.int64();
        break;
      case 2:
        m.FractionalNanoseconds = r.fixed32();
        break;
      default:
        r.skipType(t & 7);
        break;
      }
    }
    if (!m.hasOwnProperty('Seconds'))
      throw $util.ProtocolError('missing required \'Seconds\'', { instance: m });
    return m;
  };
  UnixTime.fromObject = function fromObject(d) {
    if (d instanceof $root.UnixTime)
      return d;
    var m = new $root.UnixTime();
    if (d.Seconds != null) {
      if ($util.Long)
        (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
      else if (typeof d.Seconds === 'string')
        m.Seconds = parseInt(d.Seconds, 10);
      else if (typeof d.Seconds === 'number')
        m.Seconds = d.Seconds;
      else if (typeof d.Seconds === 'object')
        m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
    }
    if (d.FractionalNanoseconds != null) {
      m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
    }
    return m;
  };
  UnixTime.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if ($util.Long) {
        var n = new $util.Long(0, 0, false);
        d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.Seconds = o.longs === String ? '0' : 0;
      d.FractionalNanoseconds = 0;
    }
    if (m.Seconds != null && m.hasOwnProperty('Seconds')) {
      if (typeof m.Seconds === 'number')
        d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
      else
        d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
    }
    if (m.FractionalNanoseconds != null && m.hasOwnProperty('FractionalNanoseconds')) {
      d.FractionalNanoseconds = m.FractionalNanoseconds;
    }
    return d;
  };
  UnixTime.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.util.toJSONOptions);
  };
  return UnixTime;
})();
const Metadata = $root.Metadata = (() => {
  function Metadata(p) {
    if (p)
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
  }
  Metadata.prototype.MimeType = '';
  Metadata.encode = function encode(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.MimeType != null && Object.hasOwnProperty.call(m, 'MimeType'))
      w.uint32(10).string(m.MimeType);
    return w;
  };
  Metadata.decode = function decode(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l, m = new $root.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
      case 1:
        m.MimeType = r.string();
        break;
      default:
        r.skipType(t & 7);
        break;
      }
    }
    return m;
  };
  Metadata.fromObject = function fromObject(d) {
    if (d instanceof $root.Metadata)
      return d;
    var m = new $root.Metadata();
    if (d.MimeType != null) {
      m.MimeType = String(d.MimeType);
    }
    return m;
  };
  Metadata.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.MimeType = '';
    }
    if (m.MimeType != null && m.hasOwnProperty('MimeType')) {
      d.MimeType = m.MimeType;
    }
    return d;
  };
  Metadata.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, protobufjs_minimal_js__WEBPACK_IMPORTED_MODULE_0__.util.toJSONOptions);
  };
  return Metadata;
})();


/***/ }),

/***/ 726:
/*!**********************************************!*\
  !*** ./node_modules/merge-options/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ 942);
/**
 * Thin ESM wrapper for CJS named exports.
 *
 * Ref: https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1
 */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ 7810:
/*!*********************************************************!*\
  !*** ./node_modules/multiformats/esm/src/bases/base.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Codec": () => (/* binding */ Codec),
/* harmony export */   "from": () => (/* binding */ from),
/* harmony export */   "baseX": () => (/* binding */ baseX),
/* harmony export */   "rfc4648": () => (/* binding */ rfc4648)
/* harmony export */ });
/* harmony import */ var _vendor_base_x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vendor/base-x.js */ 2310);
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bytes.js */ 5934);


class Encoder {
  constructor(name, prefix, baseEncode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${ this.prefix }${ this.baseEncode(bytes) }`;
    } else {
      throw Error('Unknown type, must be binary type');
    }
  }
}
class Decoder {
  constructor(name, prefix, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === 'string') {
      switch (text[0]) {
      case this.prefix: {
          return this.baseDecode(text.slice(1));
        }
      default: {
          throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);
        }
      }
    } else {
      throw Error('Can only multibase decode strings');
    }
  }
  or(decoder) {
    const decoders = {
      [this.prefix]: this,
      ...decoder.decoders || { [decoder.prefix]: decoder }
    };
    return new ComposedDecoder(decoders);
  }
}
class ComposedDecoder {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    const other = decoder.decoders || { [decoder.prefix]: decoder };
    return new ComposedDecoder({
      ...this.decoders,
      ...other
    });
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);
    }
  }
}
class Codec {
  constructor(name, prefix, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);
const baseX = ({prefix, name, alphabet}) => {
  const {encode, decode} = (0,_vendor_base_x_js__WEBPACK_IMPORTED_MODULE_0__["default"])(alphabet, name);
  return from({
    prefix,
    name,
    encode,
    decode: text => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.coerce)(decode(text))
  });
};
const decode = (string, alphabet, bitsPerChar, name) => {
  const codes = {};
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i;
  }
  let end = string.length;
  while (string[end - 1] === '=') {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes[string[i]];
    if (value === undefined) {
      throw new SyntaxError(`Non-${ name } character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError('Unexpected end of data');
  }
  return out;
};
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '=';
  const mask = (1 << bitsPerChar) - 1;
  let out = '';
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += '=';
    }
  }
  return out;
};
const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {
  return from({
    prefix,
    name,
    encode(input) {
      return encode(input, alphabet, bitsPerChar);
    },
    decode(input) {
      return decode(input, alphabet, bitsPerChar, name);
    }
  });
};

/***/ }),

/***/ 2190:
/*!***********************************************************!*\
  !*** ./node_modules/multiformats/esm/src/bases/base10.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base10": () => (/* binding */ base10)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ 7810);

const base10 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  prefix: '9',
  name: 'base10',
  alphabet: '0123456789'
});

/***/ }),

/***/ 4835:
/*!***********************************************************!*\
  !*** ./node_modules/multiformats/esm/src/bases/base16.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base16": () => (/* binding */ base16),
/* harmony export */   "base16upper": () => (/* binding */ base16upper)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ 7810);

const base16 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'f',
  name: 'base16',
  alphabet: '0123456789abcdef',
  bitsPerChar: 4
});
const base16upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'F',
  name: 'base16upper',
  alphabet: '0123456789ABCDEF',
  bitsPerChar: 4
});

/***/ }),

/***/ 4530:
/*!**********************************************************!*\
  !*** ./node_modules/multiformats/esm/src/bases/base2.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base2": () => (/* binding */ base2)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ 7810);

const base2 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: '0',
  name: 'base2',
  alphabet: '01',
  bitsPerChar: 1
});

/***/ }),

/***/ 2817:
/*!***********************************************************!*\
  !*** ./node_modules/multiformats/esm/src/bases/base32.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base32": () => (/* binding */ base32),
/* harmony export */   "base32upper": () => (/* binding */ base32upper),
/* harmony export */   "base32pad": () => (/* binding */ base32pad),
/* harmony export */   "base32padupper": () => (/* binding */ base32padupper),
/* harmony export */   "base32hex": () => (/* binding */ base32hex),
/* harmony export */   "base32hexupper": () => (/* binding */ base32hexupper),
/* harmony export */   "base32hexpad": () => (/* binding */ base32hexpad),
/* harmony export */   "base32hexpadupper": () => (/* binding */ base32hexpadupper),
/* harmony export */   "base32z": () => (/* binding */ base32z)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ 7810);

const base32 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'b',
  name: 'base32',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
  bitsPerChar: 5
});
const base32upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'B',
  name: 'base32upper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
  bitsPerChar: 5
});
const base32pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'c',
  name: 'base32pad',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
  bitsPerChar: 5
});
const base32padupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'C',
  name: 'base32padupper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
  bitsPerChar: 5
});
const base32hex = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'v',
  name: 'base32hex',
  alphabet: '0123456789abcdefghijklmnopqrstuv',
  bitsPerChar: 5
});
const base32hexupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'V',
  name: 'base32hexupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
  bitsPerChar: 5
});
const base32hexpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 't',
  name: 'base32hexpad',
  alphabet: '0123456789abcdefghijklmnopqrstuv=',
  bitsPerChar: 5
});
const base32hexpadupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'T',
  name: 'base32hexpadupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
  bitsPerChar: 5
});
const base32z = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'h',
  name: 'base32z',
  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
  bitsPerChar: 5
});

/***/ }),

/***/ 8441:
/*!***********************************************************!*\
  !*** ./node_modules/multiformats/esm/src/bases/base36.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base36": () => (/* binding */ base36),
/* harmony export */   "base36upper": () => (/* binding */ base36upper)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ 7810);

const base36 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  prefix: 'k',
  name: 'base36',
  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
});
const base36upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  prefix: 'K',
  name: 'base36upper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
});

/***/ }),

/***/ 9086:
/*!***********************************************************!*\
  !*** ./node_modules/multiformats/esm/src/bases/base58.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base58btc": () => (/* binding */ base58btc),
/* harmony export */   "base58flickr": () => (/* binding */ base58flickr)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ 7810);

const base58btc = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  name: 'base58btc',
  prefix: 'z',
  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
const base58flickr = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
  name: 'base58flickr',
  prefix: 'Z',
  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
});

/***/ }),

/***/ 9885:
/*!***********************************************************!*\
  !*** ./node_modules/multiformats/esm/src/bases/base64.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base64": () => (/* binding */ base64),
/* harmony export */   "base64pad": () => (/* binding */ base64pad),
/* harmony export */   "base64url": () => (/* binding */ base64url),
/* harmony export */   "base64urlpad": () => (/* binding */ base64urlpad)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ 7810);

const base64 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'm',
  name: 'base64',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
  bitsPerChar: 6
});
const base64pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'M',
  name: 'base64pad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
  bitsPerChar: 6
});
const base64url = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'u',
  name: 'base64url',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
  bitsPerChar: 6
});
const base64urlpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: 'U',
  name: 'base64urlpad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
  bitsPerChar: 6
});

/***/ }),

/***/ 794:
/*!**********************************************************!*\
  !*** ./node_modules/multiformats/esm/src/bases/base8.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base8": () => (/* binding */ base8)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ 7810);

const base8 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
  prefix: '7',
  name: 'base8',
  alphabet: '01234567',
  bitsPerChar: 3
});

/***/ }),

/***/ 3254:
/*!*************************************************************!*\
  !*** ./node_modules/multiformats/esm/src/bases/identity.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": () => (/* binding */ identity)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ 7810);
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bytes.js */ 5934);


const identity = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.from)({
  prefix: '\0',
  name: 'identity',
  encode: buf => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.toString)(buf),
  decode: str => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromString)(str)
});

/***/ }),

/***/ 1069:
/*!*****************************************************!*\
  !*** ./node_modules/multiformats/esm/src/basics.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CID": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_13__.CID),
/* harmony export */   "hasher": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_13__.hasher),
/* harmony export */   "digest": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_13__.digest),
/* harmony export */   "varint": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_13__.varint),
/* harmony export */   "bytes": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_13__.bytes),
/* harmony export */   "hashes": () => (/* binding */ hashes),
/* harmony export */   "bases": () => (/* binding */ bases),
/* harmony export */   "codecs": () => (/* binding */ codecs)
/* harmony export */ });
/* harmony import */ var _bases_identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bases/identity.js */ 3254);
/* harmony import */ var _bases_base2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bases/base2.js */ 4530);
/* harmony import */ var _bases_base8_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bases/base8.js */ 794);
/* harmony import */ var _bases_base10_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bases/base10.js */ 2190);
/* harmony import */ var _bases_base16_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bases/base16.js */ 4835);
/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bases/base32.js */ 2817);
/* harmony import */ var _bases_base36_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bases/base36.js */ 8441);
/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bases/base58.js */ 9086);
/* harmony import */ var _bases_base64_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./bases/base64.js */ 9885);
/* harmony import */ var _hashes_sha2_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./hashes/sha2.js */ 6155);
/* harmony import */ var _hashes_identity_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./hashes/identity.js */ 8103);
/* harmony import */ var _codecs_raw_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./codecs/raw.js */ 6945);
/* harmony import */ var _codecs_json_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./codecs/json.js */ 950);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./index.js */ 6441);














const bases = {
  ..._bases_identity_js__WEBPACK_IMPORTED_MODULE_0__,
  ..._bases_base2_js__WEBPACK_IMPORTED_MODULE_1__,
  ..._bases_base8_js__WEBPACK_IMPORTED_MODULE_2__,
  ..._bases_base10_js__WEBPACK_IMPORTED_MODULE_3__,
  ..._bases_base16_js__WEBPACK_IMPORTED_MODULE_4__,
  ..._bases_base32_js__WEBPACK_IMPORTED_MODULE_5__,
  ..._bases_base36_js__WEBPACK_IMPORTED_MODULE_6__,
  ..._bases_base58_js__WEBPACK_IMPORTED_MODULE_7__,
  ..._bases_base64_js__WEBPACK_IMPORTED_MODULE_8__
};
const hashes = {
  ..._hashes_sha2_js__WEBPACK_IMPORTED_MODULE_9__,
  ..._hashes_identity_js__WEBPACK_IMPORTED_MODULE_10__
};
const codecs = {
  raw: _codecs_raw_js__WEBPACK_IMPORTED_MODULE_11__,
  json: _codecs_json_js__WEBPACK_IMPORTED_MODULE_12__
};


/***/ }),

/***/ 5934:
/*!****************************************************!*\
  !*** ./node_modules/multiformats/esm/src/bytes.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "coerce": () => (/* binding */ coerce),
/* harmony export */   "isBinary": () => (/* binding */ isBinary),
/* harmony export */   "fromHex": () => (/* binding */ fromHex),
/* harmony export */   "toHex": () => (/* binding */ toHex),
/* harmony export */   "fromString": () => (/* binding */ fromString),
/* harmony export */   "toString": () => (/* binding */ toString),
/* harmony export */   "empty": () => (/* binding */ empty)
/* harmony export */ });
const empty = new Uint8Array(0);
const toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');
const fromHex = hex => {
  const hexes = hex.match(/../g);
  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;
};
const equals = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce = o => {
  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error('Unknown type, must be binary type');
};
const isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
const fromString = str => new TextEncoder().encode(str);
const toString = b => new TextDecoder().decode(b);


/***/ }),

/***/ 1362:
/*!**************************************************!*\
  !*** ./node_modules/multiformats/esm/src/cid.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CID": () => (/* binding */ CID)
/* harmony export */ });
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./varint.js */ 5389);
/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hashes/digest.js */ 8924);
/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bases/base58.js */ 9086);
/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bases/base32.js */ 2817);
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bytes.js */ 5934);





class CID {
  constructor(version, code, multihash, bytes) {
    this.code = code;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
    case 0: {
        return this;
      }
    default: {
        const {code, multihash} = this;
        if (code !== DAG_PB_CODE) {
          throw new Error('Cannot convert a non dag-pb CID to CIDv0');
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
        }
        return CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
    case 0: {
        const {code, digest} = this.multihash;
        const multihash = _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.create(code, digest);
        return CID.createV1(this.code, multihash);
      }
    case 1: {
        return this;
      }
    default: {
        throw Error(`Can not convert CID version ${ this.version } to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.equals(this.multihash, other.multihash);
  }
  toString(base) {
    const {bytes, version, _baseCache} = this;
    switch (version) {
    case 0:
      return toStringV0(bytes, _baseCache, base || _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.encoder);
    default:
      return toStringV1(bytes, _baseCache, base || _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return 'CID';
  }
  [Symbol.for('nodejs.util.inspect.custom')]() {
    return 'CID(' + this.toString() + ')';
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error('Deprecated, use .toString()');
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const {version, code, multihash, bytes} = value;
      return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const {version, multihash, code} = value;
      const digest = _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.decode(multihash);
      return CID.create(version, code, digest);
    } else {
      return null;
    }
  }
  static create(version, code, digest) {
    if (typeof code !== 'number') {
      throw new Error('String codecs are no longer supported');
    }
    switch (version) {
    case 0: {
        if (code !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${ DAG_PB_CODE }) block encoding`);
        } else {
          return new CID(version, code, digest, digest.bytes);
        }
      }
    case 1: {
        const bytes = encodeCID(version, code, digest.bytes);
        return new CID(version, code, digest, bytes);
      }
    default: {
        throw new Error('Invalid version');
      }
    }
  }
  static createV0(digest) {
    return CID.create(0, DAG_PB_CODE, digest);
  }
  static createV1(code, digest) {
    return CID.create(1, code, digest);
  }
  static decode(bytes) {
    const [cid, remainder] = CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error('Incorrect length');
    }
    return cid;
  }
  static decodeFirst(bytes) {
    const specs = CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_4__.coerce)(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error('Incorrect length');
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest = new _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
    return [
      cid,
      bytes.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length] = _varint_js__WEBPACK_IMPORTED_MODULE_0__.decode(initialBytes.subarray(offset));
      offset += length;
      return i;
    };
    let version = next();
    let codec = DAG_PB_CODE;
    if (version === 18) {
      version = 0;
      offset = 0;
    } else if (version === 1) {
      codec = next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${ version }`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base) {
    const [prefix, bytes] = parseCIDtoBytes(source, base);
    const cid = CID.decode(bytes);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes = (source, base) => {
  switch (source[0]) {
  case 'Q': {
      const decoder = base || _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc;
      return [
        _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix,
        decoder.decode(`${ _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix }${ source }`)
      ];
    }
  case _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix: {
      const decoder = base || _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc;
      return [
        _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix,
        decoder.decode(source)
      ];
    }
  case _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32.prefix: {
      const decoder = base || _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32;
      return [
        _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32.prefix,
        decoder.decode(source)
      ];
    }
  default: {
      if (base == null) {
        throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');
      }
      return [
        source[0],
        base.decode(source)
      ];
    }
  }
};
const toStringV0 = (bytes, cache, base) => {
  const {prefix} = base;
  if (prefix !== _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${ base.name } encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid = base.encode(bytes).slice(1);
    cache.set(prefix, cid);
    return cid;
  } else {
    return cid;
  }
};
const toStringV1 = (bytes, cache, base) => {
  const {prefix} = base;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid = base.encode(bytes);
    cache.set(prefix, cid);
    return cid;
  } else {
    return cid;
  }
};
const DAG_PB_CODE = 112;
const SHA_256_CODE = 18;
const encodeCID = (version, code, multihash) => {
  const codeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodingLength(version);
  const hashOffset = codeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodingLength(code);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodeTo(version, bytes, 0);
  _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodeTo(code, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
const cidSymbol = Symbol.for('@ipld/js-cid/CID');
const readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version = '0.0.0-dev';
const deprecate = (range, message) => {
  if (range.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

/***/ }),

/***/ 950:
/*!**********************************************************!*\
  !*** ./node_modules/multiformats/esm/src/codecs/json.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => (/* binding */ name),
/* harmony export */   "code": () => (/* binding */ code),
/* harmony export */   "encode": () => (/* binding */ encode),
/* harmony export */   "decode": () => (/* binding */ decode)
/* harmony export */ });
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const name = 'json';
const code = 512;
const encode = node => textEncoder.encode(JSON.stringify(node));
const decode = data => JSON.parse(textDecoder.decode(data));

/***/ }),

/***/ 6945:
/*!*********************************************************!*\
  !*** ./node_modules/multiformats/esm/src/codecs/raw.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => (/* binding */ name),
/* harmony export */   "code": () => (/* binding */ code),
/* harmony export */   "encode": () => (/* binding */ encode),
/* harmony export */   "decode": () => (/* binding */ decode)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ 5934);

const name = 'raw';
const code = 85;
const encode = node => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(node);
const decode = data => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(data);

/***/ }),

/***/ 8924:
/*!************************************************************!*\
  !*** ./node_modules/multiformats/esm/src/hashes/digest.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "Digest": () => (/* binding */ Digest)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ 5934);
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../varint.js */ 5389);


const create = (code, digest) => {
  const size = digest.byteLength;
  const sizeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(code);
  const digestOffset = sizeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(code, bytes, 0);
  _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest(code, size, digest, bytes);
};
const decode = multihash => {
  const bytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(multihash);
  const [code, sizeOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes);
  const [size, digestOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes.subarray(sizeOffset));
  const digest = bytes.subarray(sizeOffset + digestOffset);
  if (digest.byteLength !== size) {
    throw new Error('Incorrect length');
  }
  return new Digest(code, size, digest, bytes);
};
const equals = (a, b) => {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.equals)(a.bytes, b.bytes);
  }
};
class Digest {
  constructor(code, size, digest, bytes) {
    this.code = code;
    this.size = size;
    this.digest = digest;
    this.bytes = bytes;
  }
}

/***/ }),

/***/ 7225:
/*!************************************************************!*\
  !*** ./node_modules/multiformats/esm/src/hashes/hasher.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "from": () => (/* binding */ from),
/* harmony export */   "Hasher": () => (/* binding */ Hasher)
/* harmony export */ });
/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./digest.js */ 8924);

const from = ({name, code, encode}) => new Hasher(name, code, encode);
class Hasher {
  constructor(name, code, encode) {
    this.name = name;
    this.code = code;
    this.encode = encode;
  }
  async digest(input) {
    if (input instanceof Uint8Array) {
      const digest = await this.encode(input);
      return _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, digest);
    } else {
      throw Error('Unknown type, must be binary type');
    }
  }
}

/***/ }),

/***/ 8103:
/*!**************************************************************!*\
  !*** ./node_modules/multiformats/esm/src/hashes/identity.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": () => (/* binding */ identity)
/* harmony export */ });
/* harmony import */ var _hasher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hasher.js */ 7225);
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bytes.js */ 5934);


const identity = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_0__.from)({
  name: 'identity',
  code: 0,
  encode: input => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.coerce)(input)
});

/***/ }),

/***/ 6155:
/*!******************************************************************!*\
  !*** ./node_modules/multiformats/esm/src/hashes/sha2-browser.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sha256": () => (/* binding */ sha256),
/* harmony export */   "sha512": () => (/* binding */ sha512)
/* harmony export */ });
/* harmony import */ var _hasher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hasher.js */ 7225);

const sha = name => async data => new Uint8Array(await crypto.subtle.digest(name, data));
const sha256 = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_0__.from)({
  name: 'sha2-256',
  code: 18,
  encode: sha('SHA-256')
});
const sha512 = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_0__.from)({
  name: 'sha2-512',
  code: 19,
  encode: sha('SHA-512')
});

/***/ }),

/***/ 6441:
/*!****************************************************!*\
  !*** ./node_modules/multiformats/esm/src/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CID": () => (/* reexport safe */ _cid_js__WEBPACK_IMPORTED_MODULE_0__.CID),
/* harmony export */   "hasher": () => (/* reexport module object */ _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   "digest": () => (/* reexport module object */ _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   "varint": () => (/* reexport module object */ _varint_js__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   "bytes": () => (/* reexport module object */ _bytes_js__WEBPACK_IMPORTED_MODULE_2__)
/* harmony export */ });
/* harmony import */ var _cid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cid.js */ 1362);
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./varint.js */ 5389);
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bytes.js */ 5934);
/* harmony import */ var _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hashes/hasher.js */ 7225);
/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hashes/digest.js */ 8924);







/***/ }),

/***/ 5389:
/*!*****************************************************!*\
  !*** ./node_modules/multiformats/esm/src/varint.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "encodeTo": () => (/* binding */ encodeTo),
/* harmony export */   "encodingLength": () => (/* binding */ encodingLength)
/* harmony export */ });
/* harmony import */ var _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vendor/varint.js */ 6034);

const decode = data => {
  const code = _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__["default"].decode(data);
  return [
    code,
    _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__["default"].decode.bytes
  ];
};
const encodeTo = (int, target, offset = 0) => {
  _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__["default"].encode(int, target, offset);
  return target;
};
const encodingLength = int => {
  return _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__["default"].encodingLength(int);
};

/***/ }),

/***/ 2310:
/*!********************************************************!*\
  !*** ./node_modules/multiformats/esm/vendor/base-x.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function base(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError('Alphabet too long');
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + ' is ambiguous');
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode(source) {
    if (source instanceof Uint8Array);
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError('Expected Uint8Array');
    }
    if (source.length === 0) {
      return '';
    }
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i = 0;
      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = i;
      pbegin++;
    }
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== 'string') {
      throw new TypeError('Expected String');
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === ' ') {
      return;
    }
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i = 0;
      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = i;
      psz++;
    }
    if (source[psz] === ' ') {
      return;
    }
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode(string) {
    var buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${ name } character`);
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_brrp__multiformats_scope_baseX);

/***/ }),

/***/ 6034:
/*!********************************************************!*\
  !*** ./node_modules/multiformats/esm/vendor/varint.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var encode_1 = encode;
var MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode.bytes = offset - oldOffset + 1;
  return out;
}
var decode = read;
var MSB$1 = 128, REST$1 = 127;
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError('Could not decode varint');
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function (value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode,
  encodingLength: length
};
var _brrp_varint = varint;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_brrp_varint);

/***/ }),

/***/ 2816:
/*!***********************************************!*\
  !*** ./node_modules/parse-duration/index.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
let durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig


/**
 * conversion ratios
 */

parse.nanosecond =
parse.ns = 1 / 1e6

parse['s'] =
parse['s'] =
parse.us =
parse.microsecond = 1 / 1e3

parse.millisecond =
parse.ms =
parse[''] = 1

parse.second =
parse.sec =
parse.s = parse.ms * 1000

parse.minute =
parse.min =
parse.m = parse.s * 60

parse.hour =
parse.hr =
parse.h = parse.m * 60

parse.day =
parse.d = parse.h * 24

parse.week =
parse.wk =
parse.w = parse.d * 7

parse.month =
parse.b =
parse.d * (365.25 / 12)

parse.year =
parse.yr =
parse.y = parse.d * 365.25

/**
 * convert `str` to ms
 *
 * @param {String} str
 * @param {String} format
 * @return {Number}
 */

function parse(str='', format='ms'){
  var result = null
  // ignore commas/placeholders
  str = (str+'').replace(/(\d)[,_](\d)/g, '$1$2')
  str.replace(durationRE, function(_, n, units){
    units = unitRatio(units)
    if (units) result = (result || 0) + parseFloat(n, 10) * units
  })

  return result && (result / (unitRatio(format) || 1))
}

function unitRatio(str) {
  return parse[str] || parse[str.toLowerCase().replace(/s$/, '')]
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);


/***/ }),

/***/ 605:
/*!****************************************************!*\
  !*** ./node_modules/uint8arrays/esm/src/concat.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "concat": () => (/* binding */ concat)
/* harmony export */ });
function concat(arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = new Uint8Array(length);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return output;
}

/***/ }),

/***/ 9588:
/*!****************************************************!*\
  !*** ./node_modules/uint8arrays/esm/src/equals.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equals": () => (/* binding */ equals)
/* harmony export */ });
function equals(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

/***/ }),

/***/ 2217:
/*!*********************************************************!*\
  !*** ./node_modules/uint8arrays/esm/src/from-string.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromString": () => (/* binding */ fromString)
/* harmony export */ });
/* harmony import */ var _util_bases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/bases.js */ 7645);

function fromString(string, encoding = 'utf8') {
  const base = _util_bases_js__WEBPACK_IMPORTED_MODULE_0__["default"][encoding];
  if (!base) {
    throw new Error(`Unsupported encoding "${ encoding }"`);
  }
  return base.decoder.decode(`${ base.prefix }${ string }`);
}

/***/ }),

/***/ 2263:
/*!*******************************************************!*\
  !*** ./node_modules/uint8arrays/esm/src/to-string.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toString": () => (/* binding */ toString)
/* harmony export */ });
/* harmony import */ var _util_bases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/bases.js */ 7645);

function toString(array, encoding = 'utf8') {
  const base = _util_bases_js__WEBPACK_IMPORTED_MODULE_0__["default"][encoding];
  if (!base) {
    throw new Error(`Unsupported encoding "${ encoding }"`);
  }
  return base.encoder.encode(array).substring(1);
}

/***/ }),

/***/ 7645:
/*!********************************************************!*\
  !*** ./node_modules/uint8arrays/esm/src/util/bases.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/basics */ 1069);

function createCodec(name, prefix, encode, decode) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode
    },
    decoder: { decode }
  };
}
const string = createCodec('utf8', 'u', buf => {
  const decoder = new TextDecoder('utf8');
  return 'u' + decoder.decode(buf);
}, str => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', buf => {
  let string = 'a';
  for (let i = 0; i < buf.length; i++) {
    string += String.fromCharCode(buf[i]);
  }
  return string;
}, str => {
  str = str.substring(1);
  const buf = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
const BASES = {
  utf8: string,
  'utf-8': string,
  hex: multiformats_basics__WEBPACK_IMPORTED_MODULE_0__.bases.base16,
  latin1: ascii,
  ascii: ascii,
  binary: ascii,
  ...multiformats_basics__WEBPACK_IMPORTED_MODULE_0__.bases
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BASES);

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy5mOGZiY2U2MjkyOGIyNGE4ZTYzMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQSxVQUFVO0FBQ1YsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsR0FBRztBQUNkLFdBQVcsTUFBTTtBQUNqQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7Ozs7Ozs7Ozs7O0FDbkRhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsOEJBQThCLEVBQUUsbUJBQW1CLEVBQUUsaUJBQWlCLEVBQUU7QUFDeEU7Ozs7Ozs7Ozs7OztBQzFJYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDM0VhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUs7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssS0FBSztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWMsMENBQTBDO0FBQ3hEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxxREFB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QTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxHQUFHLFNBQVM7QUFDNUMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0QkFBNEI7QUFDNUIsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVWWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQ7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0EsZ0VBQWdFO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7OztBQ3BDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0Qzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLG9CQUFVOztBQUVuQyxPQUFPLFlBQVk7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxjQUFJO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNqUmE7O0FBRWI7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNwRWE7O0FBRWI7QUFDQTtBQUNBLG9CQUFvQixLQUFLLFFBQVEsS0FBSztBQUN0Qzs7QUFFQSx3R0FBd0csRUFBRTs7QUFFMUcsMkJBQTJCLElBQUk7QUFDL0I7QUFDQTtBQUNBLEtBQUssTUFBTSxHQUFHLEVBQUUsS0FBSyxNQUFNO0FBQzNCLEtBQUssTUFBTSxHQUFHLEVBQUUsS0FBSyxHQUFHLElBQUksTUFBTTtBQUNsQyxLQUFLLE1BQU0sR0FBRyxFQUFFLE1BQU0sR0FBRyxPQUFPLE1BQU0sRUFBRSxJQUFJO0FBQzVDLEtBQUssTUFBTSxHQUFHLEVBQUUsU0FBUyxNQUFNLEVBQUUsSUFBSSxHQUFHLEdBQUcsT0FBTyxNQUFNLEVBQUUsSUFBSTtBQUM5RCxLQUFLLE1BQU0sR0FBRyxFQUFFLFNBQVMsTUFBTSxFQUFFLElBQUksR0FBRyxHQUFHLE9BQU8sTUFBTSxFQUFFLElBQUk7QUFDOUQsS0FBSyxNQUFNLEdBQUcsRUFBRSxTQUFTLE1BQU0sRUFBRSxJQUFJLEdBQUcsR0FBRyxPQUFPLE1BQU0sRUFBRSxJQUFJO0FBQzlELEtBQUssTUFBTSxHQUFHLEVBQUUsU0FBUyxNQUFNLEVBQUUsSUFBSSxHQUFHLEdBQUcsT0FBTyxNQUFNLEVBQUUsSUFBSTtBQUM5RCxhQUFhLE1BQU0sRUFBRSxJQUFJLEdBQUcsR0FBRyxPQUFPLE1BQU0sRUFBRSxJQUFJO0FBQ2xELGlCQUFpQixHQUFHO0FBQ3BCOztBQUVBO0FBQ0EsbUNBQW1DLEdBQUcsU0FBUyxHQUFHO0FBQ2xELCtCQUErQixHQUFHO0FBQ2xDLCtCQUErQixHQUFHOztBQUVsQztBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsRUFBRSxHQUFHLEVBQUUsV0FBVyxPQUFPLFdBQVcsRUFBRSxHQUFHLEVBQUUsV0FBVzs7QUFFbkYsc0VBQXNFLFdBQVcsRUFBRSxHQUFHLEVBQUUsV0FBVztBQUNuRyxzRUFBc0UsV0FBVyxFQUFFLEdBQUcsRUFBRSxXQUFXOztBQUVuRzs7Ozs7Ozs7Ozs7O0FDbkNZO0FBQ1osbUJBQW1CLG1CQUFPLENBQUMsdUJBQWE7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUE2QjtBQUM3QztBQUNBO0FBQ0Esd0ZBQXdGLGFBQW9CO0FBQzVHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVCWTs7QUFFWixRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsZ0JBQU87O0FBRTFDO0FBQ0EsRUFBRSxnRUFBMEM7QUFDNUMsRUFBRTtBQUNGO0FBQ0EsRUFBRSw2REFBd0M7QUFDMUM7Ozs7Ozs7Ozs7OztBQ1RZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxtQkFBUzs7QUFFOUI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdDQUFnQztBQUMzQyxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdDQUFnQztBQUMzQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ1k7O0FBRVosUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLHVCQUFjO0FBQzFELFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQyx3QkFBYztBQUMxRCxjQUFjLGtEQUE2QixHQUFHLHVCQUF1QjtBQUNyRSxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsbUJBQVM7QUFDbEQsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLG1DQUF5QjtBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxzQkFBWTs7QUFFdEM7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QyxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLG9DQUFvQztBQUNqRDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQSwyQkFBMkI7QUFDM0IsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxhQUFhO0FBQzFCLGVBQWU7QUFDZjtBQUNBLHFDQUFxQztBQUNyQyxlQUFlLGFBQWE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsYUFBYTtBQUMxQjtBQUNBLDhCQUE4QjtBQUM5QixrQ0FBa0MsNEJBQTRCO0FBQzlEOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsNkJBQTZCO0FBQzdCLGtDQUFrQywyQkFBMkI7QUFDN0Q7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLGFBQWE7QUFDMUI7QUFDQSw2QkFBNkI7QUFDN0Isa0NBQWtDLDJCQUEyQjtBQUM3RDs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsYUFBYTtBQUMxQjtBQUNBLGdDQUFnQztBQUNoQyxrQ0FBa0MsOEJBQThCO0FBQ2hFOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsaUNBQWlDO0FBQ2pDLGtDQUFrQywrQkFBK0I7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDs7QUFFQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBb0Q7QUFDL0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxLQUFLO0FBQ25CLFdBQVcsNkJBQTZCO0FBQ3hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLEtBQUs7QUFDbkIsV0FBVyw4QkFBOEI7QUFDekMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6Qzs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLGFBQWE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsYUFBYTtBQUN4QjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLGFBQWE7QUFDeEI7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDdFdZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOzs7Ozs7Ozs7Ozs7QUM1Qkw7O0FBRVosUUFBUSwyQkFBMkIsRUFBRSxtQkFBTyxDQUFDLG1CQUFTO0FBQ3RELFFBQVEsNkNBQTZDLEVBQUUsbUJBQU8sQ0FBQyxvQkFBVTs7QUFFekU7QUFDQSxhQUFhLGlDQUFpQztBQUM5QyxhQUFhLCtCQUErQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUEsVUFBVSxtQkFBbUI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxjQUFjO0FBQ3pCO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNwQmE7QUFDYixnQkFBZ0IsbUJBQU8sQ0FBQyxvQkFBVTs7QUFFbEMsZ0NBQWdDLFlBQVk7QUFDNUMsZ0NBQWdDLFlBQVk7QUFDNUMsZ0NBQWdDLFlBQVk7QUFDNUM7O0FBRUE7Ozs7Ozs7Ozs7OztBQ1JhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDVFk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHFCQUFXO0FBQ3ZCLGlCQUFpQixtQkFBTyxDQUFDLDBCQUFnQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hCWTs7QUFFWixRQUFRLCtCQUErQixFQUFFLG1CQUFPLENBQUMsaUJBQU87O0FBRXhEO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEI7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7Ozs7Ozs7Ozs7QUMvQlk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLEdBQUcsYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUyxFQUFFLGlCQUFpQjtBQUMxQztBQUNBLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOUxZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNsQlk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNqQlk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDbkJZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLDBCQUEwQjtBQUNyQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNqQlk7O0FBRVo7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLCtCQUErQjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsd0NBQXdDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxtQkFBbUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBLGFBQWEsK0NBQStDO0FBQzVEOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDhEQUE4RDtBQUMzRTs7QUFFQTtBQUNBLGNBQWMsb0NBQW9DO0FBQ2xELFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUMzRWE7QUFDYix1QkFBdUIsbUJBQU8sQ0FBQyx3QkFBYzs7QUFFN0MsT0FBTyxnQkFBZ0I7QUFDdkIsT0FBTyxzQkFBc0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUZBQXFGO0FBQ3JGLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixVQUFVO0FBQ3BDOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pLQSxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHFCQUFXOztBQUV6QztBQUNBO0FBQ0E7QUFDQSx5REFBeUQsSUFBSSxHQUFHLEtBQUs7QUFDckU7QUFDQTtBQUNBLHlCQUF5QixLQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUyxLQUFLLElBQUksRUFBRSxhQUFhO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJLEdBQUcsUUFBUTtBQUMxQjtBQUNBO0FBQ0Esa0NBQWtDLElBQUksR0FBRyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJLFFBQVEsUUFBUTtBQUNqRCw0QkFBNEIsSUFBSSxPQUFPLFFBQVE7QUFDL0MseUJBQXlCLElBQUk7QUFDN0IsMkJBQTJCLElBQUk7QUFDL0IscUJBQXFCLElBQUk7QUFDekIsdUJBQXVCLElBQUk7QUFDM0Isa0NBQWtDLElBQUk7QUFDdEMsK0JBQStCLElBQUk7QUFDbkMsaUNBQWlDLElBQUk7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7Ozs7OztBQzNEWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxxQkFBVztBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyw2QkFBbUI7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLGtCQUFRO0FBQy9CLFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyw2QkFBb0I7QUFDakUsUUFBUSwrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLGlDQUF1Qjs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekMsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0EsMkRBQTJELE9BQU87QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN6Ulk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLGdCQUFNO0FBQ3pCLGtCQUFrQixtQkFBTyxDQUFDLDZCQUFtQjtBQUM3QyxRQUFRLE1BQU0sRUFBRSxtQkFBTyxDQUFDLDRCQUFrQjtBQUMxQyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHFDQUEyQjtBQUN0RCxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHFDQUEyQjtBQUN6RCxlQUFlLG1CQUFPLENBQUMsc0NBQTRCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxrQkFBUTtBQUMvQixRQUFRLCtCQUErQixFQUFFLG1CQUFPLENBQUMsaUNBQXVCO0FBQ3hFLFFBQVEsbUNBQW1DLEVBQUUsbUJBQU8sQ0FBQyxtQ0FBeUI7QUFDOUUsUUFBUSwyQkFBMkIsRUFBRSxtQkFBTyxDQUFDLDZCQUFvQjs7QUFFakU7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Qsa0JBQWtCLHFCQUFxQixRQUFRO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pELElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN1BZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyxtQkFBUztBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyw2QkFBbUI7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLGtCQUFRO0FBQy9CLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsNEJBQWtCO0FBQzFDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMscUNBQTJCO0FBQ3pELGdCQUFnQixtQkFBTyxDQUFDLG9CQUFVO0FBQ2xDO0FBQ0EsUUFBUSwrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLGlDQUF1QjtBQUN4RSxRQUFRLDJCQUEyQixFQUFFLG1CQUFPLENBQUMsOEJBQW9COztBQUVqRTtBQUNBLGFBQWEsd0NBQXdDO0FBQ3JELGFBQWEsd0NBQXdDO0FBQ3JELGFBQWEsbUNBQW1DO0FBQ2hELGFBQWEsNEJBQTRCO0FBQ3pDOztBQUVBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxhQUFhOztBQUV2RDtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBLE1BQU0sd0NBQXdDO0FBQzlDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRCxxQkFBcUI7QUFDaEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQscUJBQXFCLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxLQUFLO0FBQy9HLE1BQU07QUFDTixrREFBa0QsU0FBUyxxQ0FBcUMscUJBQXFCO0FBQ3JILE1BQU07QUFDTixrREFBa0QsU0FBUyw0Q0FBNEMsU0FBUztBQUNoSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sV0FBVyxFQUFFLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtDQUErQztBQUM3RCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1COzs7Ozs7Ozs7Ozs7QUMvbUJQOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxpQkFBTztBQUM1QixRQUFRLCtCQUErQixFQUFFLG1CQUFPLENBQUMsaUNBQXVCOztBQUV4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7QUFFQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZHWTtBQUNaLGNBQWMsNEJBQTRCOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsNkRBQTZEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN4R1k7O0FBRVo7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRixTQUFTLG1CQUFPLENBQUMsNEJBQWtCO0FBQ25DOztBQUVBLDBCQUEwQjtBQUMxQiw4QkFBOEI7Ozs7Ozs7Ozs7OztBQ1hsQjs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLGFBQWEsc0RBQTZCO0FBQzFDLGFBQWEsbURBQTZCO0FBQzFDLGFBQWEsbURBQTZCO0FBQzFDLGNBQWMsb0RBQThCO0FBQzVDO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hCYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBZTtBQUNoQjs7QUFFQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjs7Ozs7Ozs7Ozs7QUN4QmhCOztBQUVhO0FBQ2IscUVBQStDOzs7Ozs7Ozs7Ozs7QUNIbEM7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsb0JBQVU7QUFDMUMsd0JBQXdCLG1CQUFPLENBQUMsMkJBQWlCO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLG9CQUFVO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLDBCQUFpQjs7QUFFakQ7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQywwQkFBZ0I7QUFDaEQsd0JBQXdCLG1CQUFPLENBQUMsaUJBQU87QUFDdkMsd0JBQXdCLG1CQUFPLENBQUMsbUJBQVM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuQ2E7QUFDYjs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQywwQkFBZ0I7O0FBRXhDLGtCQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxxQkFBcUIsR0FBRyxvQkFBb0Isc0NBQXNDO0FBQy9GLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esa0VBQWtFO0FBQ2xFLGtFQUFrRTtBQUNsRSxrRUFBa0U7QUFDbEUsa0VBQWtFO0FBQ2xFLGtFQUFrRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMOzs7Ozs7Ozs7Ozs7QUMxWmE7QUFDYjs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvQkFBVTtBQUMvQjs7QUFFQSxXQUFXLG1CQUFPLENBQUMsMEJBQWdCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTs7Ozs7Ozs7Ozs7O0FDbERhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pCYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLHNCQUFzQjtBQUN2RDtBQUNBLFVBQVU7QUFDVixXQUFXLG1DQUFtQyxZQUFZLElBQUk7QUFDOUQsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0EsVUFBVTtBQUNWLFdBQVcsWUFBWTtBQUN2QixXQUFXLGlCQUFpQjtBQUM1QixhQUFhO0FBQ2I7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLHlCQUFlOzs7Ozs7Ozs7Ozs7QUNuQ3hCO0FBQ2I7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLDJCQUFpQjs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxzQ0FBc0M7QUFDL0U7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7O0FBRUE7QUFDQSwrQkFBK0IsbUJBQW1CLGVBQWUscUJBQXFCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLGlDQUFpQztBQUM1QyxhQUFhLHdCQUF3QjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxrQ0FBa0M7QUFDckUsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdJYTtBQUNiOztBQUVBLFdBQVcsbUJBQU8sQ0FBQywyQkFBaUI7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCLDZDQUE2QztBQUM3QywyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZNYTtBQUNiOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsaUNBQXVCOztBQUVoRDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw4QkFBb0I7O0FBRTFDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsb0NBQTBCOztBQUV0RDtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw0QkFBbUI7O0FBRXhDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLCtCQUFxQjs7QUFFNUM7QUFDQSxZQUFZLG1CQUFPLENBQUMsNEJBQWtCOztBQUV0QztBQUNBLFlBQVksbUJBQU8sQ0FBQyw0QkFBa0I7O0FBRXRDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0JBQVk7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDZCQUE2QixxQkFBTTtBQUNuQyxzQkFBc0IscUJBQU07QUFDNUIsc0JBQXNCLHFCQUFNO0FBQzVCLHNCQUFzQixxQkFBTTtBQUM1QixzQkFBc0IscUJBQU07O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDZCQUE2QixxQkFBTTtBQUNuQztBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHFGQUFxRjs7QUFFckY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsbURBQW1ELG1DQUFtQzs7QUFFdEY7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrQ0FBa0MsRUFBRTs7QUFFcEM7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFNBQVM7QUFDcEIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQSxxQ0FBcUM7QUFDckMsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaURBQWlELGtCQUFrQixtQkFBbUI7O0FBRXRGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdDQUFnQzs7QUFFbkY7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJEQUEyRCxrQkFBa0IsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQSxVQUFVO0FBQ1YsYUFBYSxrQkFBa0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQzs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGdFQUFnRSxRQUFRO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBLFVBQVU7QUFDVixXQUFXLGtCQUFrQjtBQUM3QixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLGFBQWE7QUFDMUI7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwYWE7QUFDYjs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQywwQkFBZ0I7O0FBRXhDLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQixHQUFHLG9CQUFvQix5Q0FBeUM7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsUUFBUTtBQUNyQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLFFBQVE7QUFDckIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsUUFBUTtBQUNyQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLFFBQVE7QUFDckIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsYUFBYSxRQUFRO0FBQ3JCLFlBQVksV0FBVztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEIsSUFBSSw0QkFBNEI7QUFDdEUsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoZGE7QUFDYjs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvQkFBVTtBQUMvQjs7QUFFQSxXQUFXLG1CQUFPLENBQUMsMEJBQWdCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBOzs7Ozs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQSxZQUFZLG1CQUFPLENBQUMsdUJBQWE7QUFDakMsWUFBWSxtQkFBTyxDQUFDLHVCQUFhO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLHFCQUFhO0FBQ3pDOzs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEIrQjtBQUNRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVEQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0NBQVcsQ0FBQywyQ0FBYztBQUNsQyxRQUFRLHdDQUFXLENBQUMsNkNBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLFNBQVMsd0RBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBLHVCQUF1Qix5Q0FBWTtBQUNuQyx1QkFBdUIseUNBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMURIO0FBQ0s7QUFDQTtBQU16QjtBQUNaO0FBQ0E7QUFDQTtBQUNQLEVBQUUsa0RBQVE7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBVTtBQUNuQjtBQUNPO0FBQ1AsY0FBYyx5REFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFVO0FBQzlCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxVQUFVO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxVQUFVO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFVBQVU7QUFDekU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBGQUEwRixVQUFVO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsVUFBVTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUZBQXVGLFVBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBZSxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBZSxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUF3Qjs7Ozs7Ozs7Ozs7Ozs7OztBQzdLM0I7QUFDekI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZUFBZSxxREFBSztBQUNwQjtBQUNBLE1BQU07QUFDTixhQUFhLHNEQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDTztBQUNQO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDTztBQUNQ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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ1hPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNib0M7QUFDN0I7QUFDUCxlQUFlLHNEQUFLO0FBQ3BCO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQSxpQ0FBaUMsYUFBYSxHQUFHLFFBQVE7QUFDekQ7Ozs7Ozs7Ozs7Ozs7Ozs7QUNQb0M7QUFDN0I7QUFDUCxlQUFlLHNEQUFLO0FBQ3BCO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDUDRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLE9BQU8sNkRBQVk7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzREFBSztBQUNWO0FBQ0EsaUVBQWUsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYmFzZTY0L2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9pbnF1aXJlL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvcG9vbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9hYm9ydC1jb250cm9sbGVyL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9hbnktc2lnbmFsL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2Vudi9kYXRhLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy92YWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9icm93c2VyLXJlYWRhYmxlc3RyZWFtLXRvLWl0L2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvZXJyLWNvZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcC1yZWdleC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvc3JjL2Vudi5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvc3JjL2ZldGNoLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy11dGlscy9zcmMvZmlsZXMvdXJsLXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvc3JjL2h0dHAuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLXV0aWxzL3NyYy9odHRwL2Vycm9yLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy11dGlscy9zcmMvaHR0cC9mZXRjaC5icm93c2VyLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXMtZWxlY3Ryb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcy1pcC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lzLXBsYWluLW9iai9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lzby11cmwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pc28tdXJsL3NyYy9yZWxhdGl2ZS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lzby11cmwvc3JjL3VybC1icm93c2VyLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXQtYWxsL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXQtZmlyc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pdC1sYXN0L2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXQtbWFwL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXQtcGVla2FibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tZXJnZS1vcHRpb25zL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tdWx0aWFkZHItdG8tdXJpL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL3NyYy9jb2RlYy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL211bHRpYWRkci9zcmMvY29udmVydC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL211bHRpYWRkci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tdWx0aWFkZHIvc3JjL2lwLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvbXVsdGlhZGRyL3NyYy9wcm90b2NvbHMtdGFibGUuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9uYXRpdmUtYWJvcnQtY29udHJvbGxlci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9uYXRpdmUtZmV0Y2gvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9icm93c2VyLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9taW5pbWFsLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlci5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9zdHJlYW0tdG8taXQvc291cmNlLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvdmFyaW50L2RlY29kZS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3ZhcmludC9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy92YXJpbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy92YXJpbnQvbGVuZ3RoLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGlwbGQvZGFnLWNib3IvZXNtL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGlwbGQvZGFnLXBiL2VzbS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AaXBsZC9kYWctcGIvZXNtL3NyYy9wYi1kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AaXBsZC9kYWctcGIvZXNtL3NyYy9wYi1lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AaXBsZC9kYWctcGIvZXNtL3NyYy91dGlsLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2Nib3JnLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi8wdWludC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvMW5lZ2ludC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvMmJ5dGVzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi8zc3RyaW5nLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi80YXJyYXkuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliLzVtYXAuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliLzZ0YWcuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliLzdmbG9hdC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvYmwuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliL2J5dGUtdXRpbHMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvZGVjb2RlLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliL2lzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi9qdW1wLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi90b2tlbi5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9lc20vc3JjL2FnZW50LmJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvZXNtL3NyYy9maWxlcy9ub3JtYWxpc2UtY29udGVudC5icm93c2VyLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1jb3JlLXV0aWxzL2VzbS9zcmMvZmlsZXMvbm9ybWFsaXNlLWlucHV0LmJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvZXNtL3NyYy9maWxlcy9ub3JtYWxpc2UuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvZXNtL3NyYy9maWxlcy91dGlscy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9lc20vc3JjL21vZGUtdG8tc3RyaW5nLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1jb3JlLXV0aWxzL2VzbS9zcmMvbXVsdGliYXNlcy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9lc20vc3JjL211bHRpY29kZWNzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1jb3JlLXV0aWxzL2VzbS9zcmMvbXVsdGloYXNoZXMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvZXNtL3NyYy9tdWx0aXBhcnQtcmVxdWVzdC5icm93c2VyLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1jb3JlLXV0aWxzL2VzbS9zcmMvcGlucy9ub3JtYWxpc2UtaW5wdXQuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvZXNtL3NyYy90by11cmwtc3RyaW5nLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2FkZC1hbGwuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvYWRkLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2JpdHN3YXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvYml0c3dhcC9zdGF0LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2JpdHN3YXAvdW53YW50LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2JpdHN3YXAvd2FudGxpc3QtZm9yLXBlZXIuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvYml0c3dhcC93YW50bGlzdC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9ibG9jay9nZXQuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvYmxvY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvYmxvY2svcHV0LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2Jsb2NrL3JtLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2Jsb2NrL3N0YXQuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvYm9vdHN0cmFwL2FkZC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9ib290c3RyYXAvY2xlYXIuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvYm9vdHN0cmFwL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2Jvb3RzdHJhcC9saXN0LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2Jvb3RzdHJhcC9yZXNldC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9ib290c3RyYXAvcm0uanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvY2F0LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2NvbW1hbmRzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2NvbmZpZy9nZXQtYWxsLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2NvbmZpZy9nZXQuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvY29uZmlnL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2NvbmZpZy9wcm9maWxlcy9hcHBseS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9jb25maWcvcHJvZmlsZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvY29uZmlnL3Byb2ZpbGVzL2xpc3QuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvY29uZmlnL3JlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvY29uZmlnL3NldC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9kYWcvZXhwb3J0LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2RhZy9nZXQuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZGFnL2ltcG9ydC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9kYWcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZGFnL3B1dC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9kYWcvcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9kaHQvZmluZC1wZWVyLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2RodC9maW5kLXByb3ZzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2RodC9nZXQuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZGh0L2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2RodC9wcm92aWRlLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2RodC9wdXQuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZGh0L3F1ZXJ5LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2RodC9yZXNwb25zZS10eXBlcy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9kaWFnL2NtZHMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZGlhZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9kaWFnL25ldC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9kaWFnL3N5cy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9kbnMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZmlsZXMvY2htb2QuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZmlsZXMvY3AuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZmlsZXMvZmx1c2guanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZmlsZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZmlsZXMvbHMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZmlsZXMvbWtkaXIuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZmlsZXMvbXYuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZmlsZXMvcmVhZC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9maWxlcy9ybS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9maWxlcy9zdGF0LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2ZpbGVzL3RvdWNoLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2ZpbGVzL3dyaXRlLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2dldC1lbmRwb2ludC1jb25maWcuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvZ2V0LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2lkLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2lzLW9ubGluZS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9rZXkvZXhwb3J0LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2tleS9nZW4uanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMva2V5L2ltcG9ydC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9rZXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMva2V5L2luZm8uanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMva2V5L2xpc3QuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMva2V5L3JlbmFtZS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9rZXkvcm0uanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvbGliL2Fib3J0LXNpZ25hbC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9saWIvY29uZmlndXJlLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2xpYi9jb3JlLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2xpYi9tb2RlLXRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9saWIvb2JqZWN0LXRvLWNhbWVsLXdpdGgtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvbGliL29iamVjdC10by1jYW1lbC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9saWIvcGFyc2UtbXRpbWUuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvbGliL3Jlc29sdmUuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2xvZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9sb2cvbGV2ZWwuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvbG9nL2xzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2xvZy90YWlsLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL2xzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL21vdW50LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL25hbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvbmFtZS9wdWJsaXNoLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL25hbWUvcHVic3ViL2NhbmNlbC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9uYW1lL3B1YnN1Yi9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9uYW1lL3B1YnN1Yi9zdGF0ZS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9uYW1lL3B1YnN1Yi9zdWJzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL25hbWUvcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9vYmplY3QvZGF0YS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9vYmplY3QvZ2V0LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL29iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9vYmplY3QvbGlua3MuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvb2JqZWN0L25ldy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9vYmplY3QvcGF0Y2gvYWRkLWxpbmsuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvb2JqZWN0L3BhdGNoL2FwcGVuZC1kYXRhLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL29iamVjdC9wYXRjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9vYmplY3QvcGF0Y2gvcm0tbGluay5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9vYmplY3QvcGF0Y2gvc2V0LWRhdGEuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvb2JqZWN0L3B1dC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9vYmplY3Qvc3RhdC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9waW4vYWRkLWFsbC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9waW4vYWRkLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3Bpbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9waW4vbHMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvcGluL3JlbW90ZS9hZGQuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvcGluL3JlbW90ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9waW4vcmVtb3RlL2xzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3Bpbi9yZW1vdGUvcm0tYWxsLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3Bpbi9yZW1vdGUvcm0uanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvcGluL3JlbW90ZS9zZXJ2aWNlL2FkZC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9waW4vcmVtb3RlL3NlcnZpY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvcGluL3JlbW90ZS9zZXJ2aWNlL2xzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3Bpbi9yZW1vdGUvc2VydmljZS9ybS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9waW4vcmVtb3RlL3NlcnZpY2UvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvcGluL3JlbW90ZS91dGlscy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9waW4vcm0tYWxsLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3Bpbi9ybS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9waW5nLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3B1YnN1Yi9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9wdWJzdWIvbHMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvcHVic3ViL3BlZXJzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3B1YnN1Yi9wdWJsaXNoLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3B1YnN1Yi9zdWJzY3JpYmUuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvcHVic3ViL3N1YnNjcmlwdGlvbi10cmFja2VyLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3B1YnN1Yi91bnN1YnNjcmliZS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9yZWZzL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3JlZnMvbG9jYWwuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvcmVwby9nYy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9yZXBvL2luZGV4LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3JlcG8vc3RhdC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9yZXBvL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9zdGFydC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9zdGF0cy9idy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9zdGF0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9zdG9wLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3N3YXJtL2FkZHJzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy1odHRwLWNsaWVudC9lc20vc3JjL3N3YXJtL2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcGZzLWh0dHAtY2xpZW50L2VzbS9zcmMvc3dhcm0vZGlzY29ubmVjdC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9zd2FybS9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9zd2FybS9sb2NhbC1hZGRycy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy9zd2FybS9wZWVycy5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtaHR0cC1jbGllbnQvZXNtL3NyYy92ZXJzaW9uLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMvZXNtL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzL2VzbS9zcmMvdW5peGZzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVyZ2Utb3B0aW9ucy9pbmRleC5tanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTEwLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTE2LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTIuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlMzIuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlMzYuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlNTguanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlOC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2lkZW50aXR5LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzaWNzLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYnl0ZXMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9jaWQuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9jb2RlY3MvanNvbi5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2NvZGVjcy9yYXcuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9oYXNoZXMvZGlnZXN0LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvaGFzaGVzL2hhc2hlci5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2hhc2hlcy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2hhc2hlcy9zaGEyLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL3ZhcmludC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vdmVuZG9yL2Jhc2UteC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vdmVuZG9yL3ZhcmludC5qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3BhcnNlLWR1cmF0aW9uL2luZGV4Lm1qcyIsIndlYnBhY2s6Ly9jb21wdXRlLW1lc2gtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvY29uY2F0LmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9lc20vc3JjL2Zyb20tc3RyaW5nLmpzIiwid2VicGFjazovL2NvbXB1dGUtbWVzaC1jbGllbnQvLi9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy90by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vY29tcHV0ZS1tZXNoLWNsaWVudC8uL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9lc20vc3JjL3V0aWwvYmFzZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gYXNQcm9taXNlO1xyXG5cclxuLyoqXHJcbiAqIENhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwuYXNQcm9taXNlfS5cclxuICogQHR5cGVkZWYgYXNQcm9taXNlQ2FsbGJhY2tcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgQWRkaXRpb25hbCBhcmd1bWVudHNcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb21pc2UgZnJvbSBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7YXNQcm9taXNlQ2FsbGJhY2t9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHsqfSBjdHggRnVuY3Rpb24gY29udGV4dFxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBGdW5jdGlvbiBhcmd1bWVudHNcclxuICogQHJldHVybnMge1Byb21pc2U8Kj59IFByb21pc2lmaWVkIGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBhc1Byb21pc2UoZm4sIGN0eC8qLCB2YXJhcmdzICovKSB7XHJcbiAgICB2YXIgcGFyYW1zICA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgb2Zmc2V0ICA9IDAsXHJcbiAgICAgICAgaW5kZXggICA9IDIsXHJcbiAgICAgICAgcGVuZGluZyA9IHRydWU7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbaW5kZXgrK107XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgcGFyYW1zW29mZnNldF0gPSBmdW5jdGlvbiBjYWxsYmFjayhlcnIvKiwgdmFyYXJncyAqLykge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycilcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBwYXJhbXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW29mZnNldF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZS5hcHBseShudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmbi5hcHBseShjdHggfHwgbnVsbCwgcGFyYW1zKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIGJhc2U2NCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG5iYXNlNjQubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIHAgPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgaWYgKCFwKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIG4gPSAwO1xyXG4gICAgd2hpbGUgKC0tcCAlIDQgPiAxICYmIHN0cmluZy5jaGFyQXQocCkgPT09IFwiPVwiKVxyXG4gICAgICAgICsrbjtcclxuICAgIHJldHVybiBNYXRoLmNlaWwoc3RyaW5nLmxlbmd0aCAqIDMpIC8gNCAtIG47XHJcbn07XHJcblxyXG4vLyBCYXNlNjQgZW5jb2RpbmcgdGFibGVcclxudmFyIGI2NCA9IG5ldyBBcnJheSg2NCk7XHJcblxyXG4vLyBCYXNlNjQgZGVjb2RpbmcgdGFibGVcclxudmFyIHM2NCA9IG5ldyBBcnJheSgxMjMpO1xyXG5cclxuLy8gNjUuLjkwLCA5Ny4uMTIyLCA0OC4uNTcsIDQzLCA0N1xyXG5mb3IgKHZhciBpID0gMDsgaSA8IDY0OylcclxuICAgIHM2NFtiNjRbaV0gPSBpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgLSA1OSB8IDQzXSA9IGkrKztcclxuXHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgYnVmZmVyIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuYmFzZTY0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXTtcclxuICAgIHZhciBpID0gMCwgLy8gb3V0cHV0IGluZGV4XHJcbiAgICAgICAgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB2YXIgYiA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiID4+IDJdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMykgPDwgNDtcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNF07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAxNSkgPDwgMjtcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNl07XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgJiA2M107XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGopIHtcclxuICAgICAgICBjaHVua1tpKytdID0gYjY0W3RdO1xyXG4gICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgICAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbnZhciBpbnZhbGlkRW5jb2RpbmcgPSBcImludmFsaWQgZW5jb2RpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBlbmNvZGluZyBpcyBpbnZhbGlkXHJcbiAqL1xyXG5iYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgIHZhciBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDspIHtcclxuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgaWYgKGMgPT09IDYxICYmIGogPiAxKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBpZiAoKGMgPSBzNjRbY10pID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IHQgPDwgMiB8IChjICYgNDgpID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDE1KSA8PCA0IHwgKGMgJiA2MCkgPj4gMjtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMykgPDwgNiB8IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBzdHJpbmcgYXBwZWFycyB0byBiZSBiYXNlNjQgZW5jb2RlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHByb2JhYmx5IGJhc2U2NCBlbmNvZGVkLCBvdGhlcndpc2UgZmFsc2VcclxuICovXHJcbmJhc2U2NC50ZXN0ID0gZnVuY3Rpb24gdGVzdChzdHJpbmcpIHtcclxuICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHJpbmcpO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBldmVudCBlbWl0dGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEEgbWluaW1hbCBldmVudCBlbWl0dGVyLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBMaXN0ZW5lclxyXG4gKiBAcGFyYW0geyp9IFtjdHhdIExpc3RlbmVyIGNvbnRleHRcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldnQsIGZuLCBjdHgpIHtcclxuICAgICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSB8fCAodGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXSkpLnB1c2goe1xyXG4gICAgICAgIGZuICA6IGZuLFxyXG4gICAgICAgIGN0eCA6IGN0eCB8fCB0aGlzXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgb3IgYW55IG1hdGNoaW5nIGxpc3RlbmVycyBpZiBhcmd1bWVudHMgYXJlIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZ0XSBFdmVudCBuYW1lLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgaWYgb21pdHRlZC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBMaXN0ZW5lciB0byByZW1vdmUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBvZiBgZXZ0YCBpZiBvbWl0dGVkLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYoZXZ0LCBmbikge1xyXG4gICAgaWYgKGV2dCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGZuID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW107XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuKVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXRzIGFuIGV2ZW50IGJ5IGNhbGxpbmcgaXRzIGxpc3RlbmVycyB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcclxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdLFxyXG4gICAgICAgICAgICBpID0gMTtcclxuICAgICAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpKytdLmN0eCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZmFjdG9yeSk7XHJcblxyXG4vKipcclxuICogUmVhZHMgLyB3cml0ZXMgZmxvYXRzIC8gZG91YmxlcyBmcm9tIC8gdG8gYnVmZmVycy5cclxuICogQG5hbWUgdXRpbC5mbG9hdFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8vIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoZSBwdXJwb3NlIG9mIG5vZGUtYmFzZWQgdGVzdGluZyBpbiBtb2RpZmllZCBnbG9iYWwgZW52aXJvbm1lbnRzXHJcbmZ1bmN0aW9uIGZhY3RvcnkoZXhwb3J0cykge1xyXG5cclxuICAgIC8vIGZsb2F0OiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoWyAtMCBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjMyLmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4YlszXSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfY3B5IDogd3JpdGVGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX3JldiA6IHdyaXRlRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gbGUgPyByZWFkRmxvYXRfZjMyX2NweSA6IHJlYWRGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9yZXYgOiByZWFkRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAvLyBmbG9hdDogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfaWVlZTc1NCh3cml0ZVVpbnQsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4odmFsKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQzMjg5MzQ0LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA+IDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpIC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxMzkwOTUwNDApID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDEuMTc1NDk0MzUwODIyMjg3NWUtMzgpIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBNYXRoLnJvdW5kKHZhbCAvIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSkpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gTWF0aC5yb3VuZCh2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpICogODM4ODYwOCkgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMjcgPDwgMjMgfCBtYW50aXNzYSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9pZWVlNzU0KHJlYWRVaW50LCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgdWludCA9IHJlYWRVaW50KGJ1ZiwgcG9zKSxcclxuICAgICAgICAgICAgICAgIHNpZ24gPSAodWludCA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gdWludCA+Pj4gMjMgJiAyNTUsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHVpbnQgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDI1NVxyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxNTApICogKG1hbnRpc3NhICsgODM4ODYwOCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFKTtcclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIC8vIGRvdWJsZTogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmNjQgPSBuZXcgRmxvYXQ2NEFycmF5KFstMF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmNjQuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzddID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzddO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzddO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X2NweSA6IHdyaXRlRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9yZXYgOiB3cml0ZURvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9jcHkgOiByZWFkRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfcmV2IDogcmVhZERvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgIC8vIGRvdWJsZTogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2llZWU3NTQod3JpdGVVaW50LCBvZmYwLCBvZmYxLCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQ2OTU5MzYwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KSB7IC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjE0NjQzNTA3MikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFudGlzc2E7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsIDwgMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHsgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAvIDVlLTMyNDtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgbWFudGlzc2EgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gMTAyNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSAxMDIzO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgKiA0NTAzNTk5NjI3MzcwNDk2ID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTAyMyA8PCAyMCB8IG1hbnRpc3NhICogMTA0ODU3NiAmIDEwNDg1NzUpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfaWVlZTc1NChyZWFkVWludCwgb2ZmMCwgb2ZmMSwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIGxvID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYwKSxcclxuICAgICAgICAgICAgICAgIGhpID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSAoaGkgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IGhpID4+PiAyMCAmIDIwNDcsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IDQyOTQ5NjcyOTYgKiAoaGkgJiAxMDQ4NTc1KSArIGxvO1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDIwNDdcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogNWUtMzI0ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTA3NSkgKiAobWFudGlzc2EgKyA0NTAzNTk5NjI3MzcwNDk2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzO1xyXG59XHJcblxyXG4vLyB1aW50IGhlbHBlcnNcclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludExFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRCRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsID4+PiAyNDtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsICAgICAgICAmIDI1NTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRMRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF1cclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSA8PCAyNCkgPj4+IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50QkUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdIDw8IDI0XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10pID4+PiAwO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGlucXVpcmU7XHJcblxyXG4vKipcclxuICogUmVxdWlyZXMgYSBtb2R1bGUgb25seSBpZiBhdmFpbGFibGUuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIE1vZHVsZSB0byByZXF1aXJlXHJcbiAqIEByZXR1cm5zIHs/T2JqZWN0fSBSZXF1aXJlZCBtb2R1bGUgaWYgYXZhaWxhYmxlIGFuZCBub3QgZW1wdHksIG90aGVyd2lzZSBgbnVsbGBcclxuICovXHJcbmZ1bmN0aW9uIGlucXVpcmUobW9kdWxlTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgbW9kID0gZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sXCJyZVwiKSkobW9kdWxlTmFtZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxyXG4gICAgICAgIGlmIChtb2QgJiYgKG1vZC5sZW5ndGggfHwgT2JqZWN0LmtleXMobW9kKS5sZW5ndGgpKVxyXG4gICAgICAgICAgICByZXR1cm4gbW9kO1xyXG4gICAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gcG9vbDtcclxuXHJcbi8qKlxyXG4gKiBBbiBhbGxvY2F0b3IgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbEFsbG9jYXRvclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcclxuICovXHJcblxyXG4vKipcclxuICogQSBzbGljZXIgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbFNsaWNlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXIgc2xpY2VcclxuICogQHRoaXMge1VpbnQ4QXJyYXl9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJhbCBwdXJwb3NlIGJ1ZmZlciBwb29sLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtQb29sQWxsb2NhdG9yfSBhbGxvYyBBbGxvY2F0b3JcclxuICogQHBhcmFtIHtQb29sU2xpY2VyfSBzbGljZSBTbGljZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTgxOTJdIFNsYWIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7UG9vbEFsbG9jYXRvcn0gUG9vbGVkIGFsbG9jYXRvclxyXG4gKi9cclxuZnVuY3Rpb24gcG9vbChhbGxvYywgc2xpY2UsIHNpemUpIHtcclxuICAgIHZhciBTSVpFICAgPSBzaXplIHx8IDgxOTI7XHJcbiAgICB2YXIgTUFYICAgID0gU0laRSA+Pj4gMTtcclxuICAgIHZhciBzbGFiICAgPSBudWxsO1xyXG4gICAgdmFyIG9mZnNldCA9IFNJWkU7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcG9vbF9hbGxvYyhzaXplKSB7XHJcbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiBNQVgpXHJcbiAgICAgICAgICAgIHJldHVybiBhbGxvYyhzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICsgc2l6ZSA+IFNJWkUpIHtcclxuICAgICAgICAgICAgc2xhYiA9IGFsbG9jKFNJWkUpO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmID0gc2xpY2UuY2FsbChzbGFiLCBvZmZzZXQsIG9mZnNldCArPSBzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICYgNykgLy8gYWxpZ24gdG8gMzIgYml0XHJcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgfCA3KSArIDE7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH07XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIFVURjggaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciB1dGY4ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBVVEY4IGJ5dGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxudXRmOC5sZW5ndGggPSBmdW5jdGlvbiB1dGY4X2xlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBsZW4gPSAwLFxyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpXHJcbiAgICAgICAgICAgIGxlbiArPSAxO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMjtcclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgbGVuICs9IDQ7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGxlbiArPSAzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBVVEY4IGJ5dGVzIGFzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZWFkXHJcbiAqL1xyXG51dGY4LnJlYWQgPSBmdW5jdGlvbiB1dGY4X3JlYWQoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBpZiAobGVuIDwgMSlcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXSxcclxuICAgICAgICBpID0gMCwgLy8gY2hhciBvZmZzZXRcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB0ID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIGlmICh0IDwgMTI4KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gdDtcclxuICAgICAgICBlbHNlIGlmICh0ID4gMTkxICYmIHQgPCAyMjQpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDMxKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDIzOSAmJiB0IDwgMzY1KSB7XHJcbiAgICAgICAgICAgIHQgPSAoKHQgJiA3KSA8PCAxOCB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MykgLSAweDEwMDAwO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEODAwICsgKHQgPj4gMTApO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEQzAwICsgKHQgJiAxMDIzKTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMTUpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc3RyaW5nIGFzIFVURjggYnl0ZXMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZXMgd3JpdHRlblxyXG4gKi9cclxudXRmOC53cml0ZSA9IGZ1bmN0aW9uIHV0Zjhfd3JpdGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgIGMxLCAvLyBjaGFyYWN0ZXIgMVxyXG4gICAgICAgIGMyOyAvLyBjaGFyYWN0ZXIgMlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjMSA8IDIwNDgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICAgICAgfCAxOTI7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKGMxICYgMHhGQzAwKSA9PT0gMHhEODAwICYmICgoYzIgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSkpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgIGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzRkYpIDw8IDEwKSArIChjMiAmIDB4MDNGRik7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDE4ICAgICAgfCAyNDA7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICAgICAgfCAyMjQ7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcbiIsIi8qZ2xvYmFscyBzZWxmLCB3aW5kb3cgKi9cblwidXNlIHN0cmljdFwiXG5cbi8qZXNsaW50LWRpc2FibGUgQG15c3RpY2F0ZWEvcHJldHRpZXIgKi9cbmNvbnN0IHsgQWJvcnRDb250cm9sbGVyLCBBYm9ydFNpZ25hbCB9ID1cbiAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOlxuICAgIC8qIG90aGVyd2lzZSAqLyB1bmRlZmluZWRcbi8qZXNsaW50LWVuYWJsZSBAbXlzdGljYXRlYS9wcmV0dGllciAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFib3J0Q29udHJvbGxlclxubW9kdWxlLmV4cG9ydHMuQWJvcnRTaWduYWwgPSBBYm9ydFNpZ25hbFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEFib3J0Q29udHJvbGxlclxuIiwiY29uc3QgeyBBYm9ydENvbnRyb2xsZXIgfSA9IHJlcXVpcmUoJ25hdGl2ZS1hYm9ydC1jb250cm9sbGVyJylcblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBBYm9ydFNpZ25hbHMgYW5kIHJldHVybnMgYSBzaW5nbGUgc2lnbmFsLlxuICogSWYgYW55IHNpZ25hbHMgYXJlIGFib3J0ZWQsIHRoZSByZXR1cm5lZCBzaWduYWwgd2lsbCBiZSBhYm9ydGVkLlxuICogQHBhcmFtIHtBcnJheTxBYm9ydFNpZ25hbD59IHNpZ25hbHNcbiAqIEByZXR1cm5zIHtBYm9ydFNpZ25hbH1cbiAqL1xuZnVuY3Rpb24gYW55U2lnbmFsIChzaWduYWxzKSB7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuICBmdW5jdGlvbiBvbkFib3J0ICgpIHtcbiAgICBjb250cm9sbGVyLmFib3J0KClcblxuICAgIGZvciAoY29uc3Qgc2lnbmFsIG9mIHNpZ25hbHMpIHtcbiAgICAgIGlmICghc2lnbmFsIHx8ICFzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikgY29udGludWVcbiAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQpXG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBzaWduYWwgb2Ygc2lnbmFscykge1xuICAgIGlmICghc2lnbmFsIHx8ICFzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcikgY29udGludWVcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIG9uQWJvcnQoKVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25BYm9ydClcbiAgfVxuXG4gIHJldHVybiBjb250cm9sbGVyLnNpZ25hbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFueVNpZ25hbFxubW9kdWxlLmV4cG9ydHMuYW55U2lnbmFsID0gYW55U2lnbmFsXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4uL2NvcmUvYnVpbGRGdWxsUGF0aCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9DYW5jZWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuICAgIHZhciByZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIHZhciBvbkNhbmNlbGVkO1xuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIXJlc3BvbnNlVHlwZSB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCAgcmVzcG9uc2VUeXBlID09PSAnanNvbicgP1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUoZnVuY3Rpb24gX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIF9yZWplY3QoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnb25sb2FkZW5kJyBpbiByZXF1ZXN0KSB7XG4gICAgICAvLyBVc2Ugb25sb2FkZW5kIGlmIGF2YWlsYWJsZVxuICAgICAgcmVxdWVzdC5vbmxvYWRlbmQgPSBvbmxvYWRlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGUgdG8gZW11bGF0ZSBvbmxvYWRlbmRcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeXN0YXRlIGhhbmRsZXIgaXMgY2FsbGluZyBiZWZvcmUgb25lcnJvciBvciBvbnRpbWVvdXQgaGFuZGxlcnMsXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBjYWxsIG9ubG9hZGVuZCBvbiB0aGUgbmV4dCAndGljaydcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWRlbmQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgdmFyIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcgOiAndGltZW91dCBleGNlZWRlZCc7XG4gICAgICB2YXIgdHJhbnNpdGlvbmFsID0gY29uZmlnLnRyYW5zaXRpb25hbCB8fCBkZWZhdWx0cy50cmFuc2l0aW9uYWw7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gJ0VUSU1FRE9VVCcgOiAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuIHx8IGNvbmZpZy5zaWduYWwpIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBvbkNhbmNlbGVkID0gZnVuY3Rpb24oY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCAoY2FuY2VsICYmIGNhbmNlbC50eXBlKSA/IG5ldyBDYW5jZWwoJ2NhbmNlbGVkJykgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuICYmIGNvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICBpZiAoY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBjb25maWcuc2lnbmFsLmFib3J0ZWQgPyBvbkNhbmNlbGVkKCkgOiBjb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0RGF0YSkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuICBpbnN0YW5jZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgaW5zdGFuY2VDb25maWcpKTtcbiAgfTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5heGlvcy5WRVJTSU9OID0gcmVxdWlyZSgnLi9lbnYvZGF0YScpLnZlcnNpb247XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0F4aW9zRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcblxuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICB0aGlzLnByb21pc2UudGhlbihmdW5jdGlvbihjYW5jZWwpIHtcbiAgICBpZiAoIXRva2VuLl9saXN0ZW5lcnMpIHJldHVybjtcblxuICAgIHZhciBpO1xuICAgIHZhciBsID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0b2tlbi5fbGlzdGVuZXJzW2ldKGNhbmNlbCk7XG4gICAgfVxuICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICB0aGlzLnByb21pc2UudGhlbiA9IGZ1bmN0aW9uKG9uZnVsZmlsbGVkKSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICB0b2tlbi5zdWJzY3JpYmUocmVzb2x2ZSk7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XG5cbiAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uIHJlamVjdCgpIHtcbiAgICAgIHRva2VuLnVuc3Vic2NyaWJlKF9yZXNvbHZlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gKi9cblxuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICBsaXN0ZW5lcih0aGlzLnJlYXNvbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbbGlzdGVuZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGNhbmNlbCBzaWduYWxcbiAqL1xuXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL21lcmdlQ29uZmlnJyk7XG52YXIgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy92YWxpZGF0b3InKTtcblxudmFyIHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgY29uZmlnLnVybCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsO1xuXG4gIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gIHZhciByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICB2YXIgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciBwcm9taXNlO1xuXG4gIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcblxuICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgY2hhaW4gPSBjaGFpbi5jb25jYXQocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcblxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cblxuICB2YXIgbmV3Q29uZmlnID0gY29uZmlnO1xuICB3aGlsZSAocmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgdmFyIG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB2YXIgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uUmVqZWN0ZWQoZXJyb3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0KG5ld0NvbmZpZyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuXG4gIHdoaWxlIChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICByZXR1cm4gYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCAnJyk7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQsXG4gICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXG4gICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvQ2FuY2VsJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cblxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgQ2FuY2VsKCdjYW5jZWxlZCcpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNcbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG5cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XG5cbiAgZXJyb3IudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgc3RhdHVzOiB0aGlzLnJlc3BvbnNlICYmIHRoaXMucmVzcG9uc2Uuc3RhdHVzID8gdGhpcy5yZXNwb25zZS5zdGF0dXMgOiBudWxsXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGVycm9yO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURpcmVjdEtleXMocHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1lcmdlTWFwID0ge1xuICAgICd1cmwnOiB2YWx1ZUZyb21Db25maWcyLFxuICAgICdtZXRob2QnOiB2YWx1ZUZyb21Db25maWcyLFxuICAgICdkYXRhJzogdmFsdWVGcm9tQ29uZmlnMixcbiAgICAnYmFzZVVSTCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RyYW5zZm9ybVJlcXVlc3QnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0cmFuc2Zvcm1SZXNwb25zZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3BhcmFtc1NlcmlhbGl6ZXInOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0aW1lb3V0JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndGltZW91dE1lc3NhZ2UnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd3aXRoQ3JlZGVudGlhbHMnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdhZGFwdGVyJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAncmVzcG9uc2VUeXBlJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAneHNyZkNvb2tpZU5hbWUnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd4c3JmSGVhZGVyTmFtZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ29uVXBsb2FkUHJvZ3Jlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdvbkRvd25sb2FkUHJvZ3Jlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdkZWNvbXByZXNzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnbWF4Q29udGVudExlbmd0aCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ21heEJvZHlMZW5ndGgnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0cmFuc3BvcnQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdodHRwQWdlbnQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdodHRwc0FnZW50JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnY2FuY2VsVG9rZW4nOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdzb2NrZXRQYXRoJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAncmVzcG9uc2VFbmNvZGluZyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3ZhbGlkYXRlU3RhdHVzJzogbWVyZ2VEaXJlY3RLZXlzXG4gIH07XG5cbiAgdXRpbHMuZm9yRWFjaChPYmplY3Qua2V5cyhjb25maWcxKS5jb25jYXQoT2JqZWN0LmtleXMoY29uZmlnMikpLCBmdW5jdGlvbiBjb21wdXRlQ29uZmlnVmFsdWUocHJvcCkge1xuICAgIHZhciBtZXJnZSA9IG1lcmdlTWFwW3Byb3BdIHx8IG1lcmdlRGVlcFByb3BlcnRpZXM7XG4gICAgdmFyIGNvbmZpZ1ZhbHVlID0gbWVyZ2UocHJvcCk7XG4gICAgKHV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZ1ZhbHVlKSAmJiBtZXJnZSAhPT0gbWVyZ2VEaXJlY3RLZXlzKSB8fCAoY29uZmlnW3Byb3BdID0gY29uZmlnVmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICB2YXIgY29udGV4dCA9IHRoaXMgfHwgZGVmYXVsdHM7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuLmNhbGwoY29udGV4dCwgZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vY29yZS9lbmhhbmNlRXJyb3InKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuXG4gIHRyYW5zaXRpb25hbDoge1xuICAgIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICAgIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IGZhbHNlXG4gIH0sXG5cbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSB8fCAoaGVhZGVycyAmJiBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IGRlZmF1bHRzLnRyYW5zaXRpb25hbDtcbiAgICB2YXIgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgIHZhciBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgdmFyIHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcgfHwgKGZvcmNlZEpTT05QYXJzaW5nICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGVuaGFuY2VFcnJvcihlLCB0aGlzLCAnRV9KU09OX1BBUlNFJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH0sXG5cbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gICAgfVxuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFwidmVyc2lvblwiOiBcIjAuMjMuMFwiXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuICh0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWRVJTSU9OID0gcmVxdWlyZSgnLi4vZW52L2RhdGEnKS52ZXJzaW9uO1xuXG52YXIgdmFsaWRhdG9ycyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnZnVuY3Rpb24nLCAnc3RyaW5nJywgJ3N5bWJvbCddLmZvckVhY2goZnVuY3Rpb24odHlwZSwgaSkge1xuICB2YWxpZGF0b3JzW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gdHlwZSB8fCAnYScgKyAoaSA8IDEgPyAnbiAnIDogJyAnKSArIHR5cGU7XG4gIH07XG59KTtcblxudmFyIGRlcHJlY2F0ZWRXYXJuaW5ncyA9IHt9O1xuXG4vKipcbiAqIFRyYW5zaXRpb25hbCBvcHRpb24gdmFsaWRhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3IgLSBzZXQgdG8gZmFsc2UgaWYgdGhlIHRyYW5zaXRpb25hbCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uIC0gZGVwcmVjYXRlZCB2ZXJzaW9uIC8gcmVtb3ZlZCBzaW5jZSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IG1lc3NhZ2UgLSBzb21lIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIGluZm9cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3B0LCBvcHRzKSB7XG4gICAgaWYgKHZhbGlkYXRvciA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXRNZXNzYWdlKG9wdCwgJyBoYXMgYmVlbiByZW1vdmVkJyArICh2ZXJzaW9uID8gJyBpbiAnICsgdmVyc2lvbiA6ICcnKSkpO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICB2YXIgb3B0ID0ga2V5c1tpXTtcbiAgICB2YXIgdmFsaWRhdG9yID0gc2NoZW1hW29wdF07XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NlcnRPcHRpb25zOiBhc3NlcnRPcHRpb25zLFxuICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqIEByZXR1cm4ge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5mdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbSxcbiAgc3RyaXBCT006IHN0cmlwQk9NXG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogVHVybnMgYSBicm93c2VyIHJlYWRhYmxlIHN0cmVhbSBpbnRvIGFuIGFzeW5jIGl0ZXJhYmxlLiBBc3luYyBpdGVyYXRpb24gb3ZlclxuICogcmV0dXJuZWQgaXRlcmFibGUgd2lsbCBsb2NrIGdpdmUgc3RyZWFtLCBwcmV2ZW50aW5nIGFueSBvdGhlciBjb25zdW1lciBmcm9tXG4gKiBhY3F1aXJpbmcgYSByZWFkZXIuIFRoZSBsb2NrIHdpbGwgYmUgcmVsZWFzZWQgaWYgaXRlcmF0aW9uIGxvb3AgaXMgYnJva2VuLiBUb1xuICogcHJldmVudCBzdHJlYW0gY2FuY2VsbGluZyBvcHRpb25hbCBgeyBwcmV2ZW50Q2FuY2VsOiB0cnVlIH1gIGNvdWxkIGJlIHBhc3NlZFxuICogYXMgYSBzZWNvbmQgYXJndW1lbnQuXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbTxUPn0gc3RyZWFtXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXZlbnRDYW5jZWw9Ym9vbGVhbl1cbiAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFQ+fVxuICovXG5hc3luYyBmdW5jdGlvbiAqIGJyb3dzZXJSZWFkYWJsZVN0cmVhbVRvSXQgKHN0cmVhbSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKVxuXG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKClcblxuICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB5aWVsZCByZXN1bHQudmFsdWVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKG9wdGlvbnMucHJldmVudENhbmNlbCAhPT0gdHJ1ZSkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpXG4gICAgfVxuXG4gICAgcmVhZGVyLnJlbGVhc2VMb2NrKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJyb3dzZXJSZWFkYWJsZVN0cmVhbVRvSXRcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IFtrZXk6IHN0cmluZ106IGFueSB9fSBFeHRlbnNpb25zXG4gKiBAdHlwZWRlZiB7RXJyb3J9IEVyclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2VcbiAqL1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBvYmpcbiAqIEBwYXJhbSB7RXh0ZW5zaW9uc30gcHJvcHNcbiAqIEByZXR1cm5zIHtFcnJvciAmIEV4dGVuc2lvbnN9XG4gKi9cbmZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogcHJvcHNba2V5XSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7YW55fSBlcnIgLSBBbiBFcnJvclxuICogQHBhcmFtIHtzdHJpbmd8RXh0ZW5zaW9uc30gY29kZSAtIEEgc3RyaW5nIGNvZGUgb3IgcHJvcHMgdG8gc2V0IG9uIHRoZSBlcnJvclxuICogQHBhcmFtIHtFeHRlbnNpb25zfSBbcHJvcHNdIC0gUHJvcHMgdG8gc2V0IG9uIHRoZSBlcnJvclxuICogQHJldHVybnMge0Vycm9yICYgRXh0ZW5zaW9uc31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3IoZXJyLCBjb2RlLCBwcm9wcykge1xuICAgIGlmICghZXJyIHx8IHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSBwYXNzIGFuIEVycm9yIHRvIGVyci1jb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcHJvcHMgPSBjb2RlO1xuICAgICAgICBjb2RlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUpIHtcbiAgICAgICAgcHJvcHMuY29kZSA9IGNvZGU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFzc2lnbihlcnIsIHByb3BzKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHByb3BzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgcHJvcHMuc3RhY2sgPSBlcnIuc3RhY2s7XG5cbiAgICAgICAgY29uc3QgRXJyQ2xhc3MgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICBFcnJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihlcnIpKTtcblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGFzc2lnbihuZXcgRXJyQ2xhc3MoKSwgcHJvcHMpO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB3b3JkID0gJ1thLWZBLUZcXFxcZDpdJztcbmNvbnN0IGIgPSBvcHRpb25zID0+IG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlQm91bmRhcmllcyA/XG5cdGAoPzooPzw9XFxcXHN8XikoPz0ke3dvcmR9KXwoPzw9JHt3b3JkfSkoPz1cXFxcc3wkKSlgIDpcblx0Jyc7XG5cbmNvbnN0IHY0ID0gJyg/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkpezN9JztcblxuY29uc3QgdjZzZWcgPSAnW2EtZkEtRlxcXFxkXXsxLDR9JztcbmNvbnN0IHY2ID0gYFxuKD86XG4oPzoke3Y2c2VnfTopezd9KD86JHt2NnNlZ318Oil8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMToyOjM6NDo1OjY6Nzo6ICAxOjI6Mzo0OjU6Njo3Ojhcbig/OiR7djZzZWd9Oil7Nn0oPzoke3Y0fXw6JHt2NnNlZ318Oil8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxOjI6Mzo0OjU6Njo6ICAgIDE6MjozOjQ6NTo2Ojo4ICAgMToyOjM6NDo1OjY6OjggIDE6MjozOjQ6NTo2OjoxLjIuMy40XG4oPzoke3Y2c2VnfTopezV9KD86OiR7djR9fCg/Ojoke3Y2c2VnfSl7MSwyfXw6KXwgICAgICAgICAgICAgICAgICAgLy8gMToyOjM6NDo1OjogICAgICAxOjI6Mzo0OjU6Ojc6OCAgIDE6MjozOjQ6NTo6OCAgICAxOjI6Mzo0OjU6Ojc6MS4yLjMuNFxuKD86JHt2NnNlZ306KXs0fSg/Oig/Ojoke3Y2c2VnfSl7MCwxfToke3Y0fXwoPzo6JHt2NnNlZ30pezEsM318Oil8IC8vIDE6MjozOjQ6OiAgICAgICAgMToyOjM6NDo6Njo3OjggICAxOjI6Mzo0Ojo4ICAgICAgMToyOjM6NDo6Njo3OjEuMi4zLjRcbig/OiR7djZzZWd9Oil7M30oPzooPzo6JHt2NnNlZ30pezAsMn06JHt2NH18KD86OiR7djZzZWd9KXsxLDR9fDopfCAvLyAxOjI6Mzo6ICAgICAgICAgIDE6MjozOjo1OjY6Nzo4ICAgMToyOjM6OjggICAgICAgIDE6MjozOjo1OjY6NzoxLjIuMy40XG4oPzoke3Y2c2VnfTopezJ9KD86KD86OiR7djZzZWd9KXswLDN9OiR7djR9fCg/Ojoke3Y2c2VnfSl7MSw1fXw6KXwgLy8gMToyOjogICAgICAgICAgICAxOjI6OjQ6NTo2Ojc6OCAgIDE6Mjo6OCAgICAgICAgICAxOjI6OjQ6NTo2Ojc6MS4yLjMuNFxuKD86JHt2NnNlZ306KXsxfSg/Oig/Ojoke3Y2c2VnfSl7MCw0fToke3Y0fXwoPzo6JHt2NnNlZ30pezEsNn18Oil8IC8vIDE6OiAgICAgICAgICAgICAgMTo6Mzo0OjU6Njo3OjggICAxOjo4ICAgICAgICAgICAgMTo6Mzo0OjU6Njo3OjEuMi4zLjRcbig/OjooPzooPzo6JHt2NnNlZ30pezAsNX06JHt2NH18KD86OiR7djZzZWd9KXsxLDd9fDopKSAgICAgICAgICAgICAvLyA6OjI6Mzo0OjU6Njo3OjggIDo6MjozOjQ6NTo2Ojc6OCAgOjo4ICAgICAgICAgICAgIDo6MS4yLjMuNFxuKSg/OiVbMC05YS16QS1aXXsxLH0pPyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICVldGgwICAgICAgICAgICAgJTFcbmAucmVwbGFjZSgvXFxzKlxcL1xcLy4qJC9nbSwgJycpLnJlcGxhY2UoL1xcbi9nLCAnJykudHJpbSgpO1xuXG4vLyBQcmUtY29tcGlsZSBvbmx5IHRoZSBleGFjdCByZWdleGVzIGJlY2F1c2UgYWRkaW5nIGEgZ2xvYmFsIGZsYWcgbWFrZSByZWdleGVzIHN0YXRlZnVsXG5jb25zdCB2NDZFeGFjdCA9IG5ldyBSZWdFeHAoYCg/Ol4ke3Y0fSQpfCg/Ol4ke3Y2fSQpYCk7XG5jb25zdCB2NGV4YWN0ID0gbmV3IFJlZ0V4cChgXiR7djR9JGApO1xuY29uc3QgdjZleGFjdCA9IG5ldyBSZWdFeHAoYF4ke3Y2fSRgKTtcblxuY29uc3QgaXAgPSBvcHRpb25zID0+IG9wdGlvbnMgJiYgb3B0aW9ucy5leGFjdCA/XG5cdHY0NkV4YWN0IDpcblx0bmV3IFJlZ0V4cChgKD86JHtiKG9wdGlvbnMpfSR7djR9JHtiKG9wdGlvbnMpfSl8KD86JHtiKG9wdGlvbnMpfSR7djZ9JHtiKG9wdGlvbnMpfSlgLCAnZycpO1xuXG5pcC52NCA9IG9wdGlvbnMgPT4gb3B0aW9ucyAmJiBvcHRpb25zLmV4YWN0ID8gdjRleGFjdCA6IG5ldyBSZWdFeHAoYCR7YihvcHRpb25zKX0ke3Y0fSR7YihvcHRpb25zKX1gLCAnZycpO1xuaXAudjYgPSBvcHRpb25zID0+IG9wdGlvbnMgJiYgb3B0aW9ucy5leGFjdCA/IHY2ZXhhY3QgOiBuZXcgUmVnRXhwKGAke2Iob3B0aW9ucyl9JHt2Nn0ke2Iob3B0aW9ucyl9YCwgJ2cnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpcDtcbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgaXNFbGVjdHJvbiA9IHJlcXVpcmUoJ2lzLWVsZWN0cm9uJylcblxuY29uc3QgSVNfRU5WX1dJVEhfRE9NID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRvY3VtZW50ID09PSAnb2JqZWN0JyAmJiBkb2N1bWVudC5ub2RlVHlwZSA9PT0gOVxuLy8gQHRzLWlnbm9yZVxuY29uc3QgSVNfRUxFQ1RST04gPSBpc0VsZWN0cm9uKClcbmNvbnN0IElTX0JST1dTRVIgPSBJU19FTlZfV0lUSF9ET00gJiYgIUlTX0VMRUNUUk9OXG5jb25zdCBJU19FTEVDVFJPTl9NQUlOID0gSVNfRUxFQ1RST04gJiYgIUlTX0VOVl9XSVRIX0RPTVxuY29uc3QgSVNfRUxFQ1RST05fUkVOREVSRVIgPSBJU19FTEVDVFJPTiAmJiBJU19FTlZfV0lUSF9ET01cbmNvbnN0IElTX05PREUgPSB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MucmVsZWFzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5yZWxlYXNlLm5hbWUgPT09ICdub2RlJyAmJiAhSVNfRUxFQ1RST05cbi8vIEB0cy1pZ25vcmUgLSB3ZSBlaXRoZXIgaWdub3JlIHdvcmtlciBzY29wZSBvciBkb20gc2NvcGVcbmNvbnN0IElTX1dFQldPUktFUiA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZVxuY29uc3QgSVNfVEVTVCA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2Vzcy5lbnYgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCdcbmNvbnN0IElTX1JFQUNUX05BVElWRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1Rlc3Q6IElTX1RFU1QsXG4gIGlzRWxlY3Ryb246IElTX0VMRUNUUk9OLFxuICBpc0VsZWN0cm9uTWFpbjogSVNfRUxFQ1RST05fTUFJTixcbiAgaXNFbGVjdHJvblJlbmRlcmVyOiBJU19FTEVDVFJPTl9SRU5ERVJFUixcbiAgaXNOb2RlOiBJU19OT0RFLFxuICAvKipcbiAgICogRGV0ZWN0cyBicm93c2VyIG1haW4gdGhyZWFkICAqKk5PVCoqIHdlYiB3b3JrZXIgb3Igc2VydmljZSB3b3JrZXJcbiAgICovXG4gIGlzQnJvd3NlcjogSVNfQlJPV1NFUixcbiAgaXNXZWJXb3JrZXI6IElTX1dFQldPUktFUixcbiAgaXNFbnZXaXRoRG9tOiBJU19FTlZfV0lUSF9ET00sXG4gIGlzUmVhY3ROYXRpdmU6IElTX1JFQUNUX05BVElWRVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgaXNFbGVjdHJvbk1haW4gfSA9IHJlcXVpcmUoJy4vZW52JylcblxuaWYgKGlzRWxlY3Ryb25NYWluKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZWxlY3Ryb24tZmV0Y2gnKVxufSBlbHNlIHtcbi8vIHVzZSB3aW5kb3cuZmV0Y2ggaWYgaXQgaXMgYXZhaWxhYmxlLCBmYWxsIGJhY2sgdG8gbm9kZS1mZXRjaCBpZiBub3RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCduYXRpdmUtZmV0Y2gnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEhUVFAgPSByZXF1aXJlKCcuLi9odHRwJylcblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90eXBlc1wiKS5IVFRQT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7eyBwYXRoOiBzdHJpbmc7IGNvbnRlbnQ/OiBBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+IH19XG4gKi9cbmNvbnN0IHVybFNvdXJjZSA9ICh1cmwsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBkZWNvZGVVUklDb21wb25lbnQobmV3IFVSTCh1cmwpLnBhdGhuYW1lLnNwbGl0KCcvJykucG9wKCkgfHwgJycpLFxuICAgIGNvbnRlbnQ6IHJlYWRVUkxDb250ZW50KHVybCwgb3B0aW9ucylcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3R5cGVzXCIpLkhUVFBPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+fVxuICovXG5hc3luYyBmdW5jdGlvbiAqIHJlYWRVUkxDb250ZW50ICh1cmwsIG9wdGlvbnMpIHtcbiAgY29uc3QgaHR0cCA9IG5ldyBIVFRQKClcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwLmdldCh1cmwsIG9wdGlvbnMpXG5cbiAgeWllbGQgKiByZXNwb25zZS5pdGVyYXRvcigpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdXJsU291cmNlXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZmV0Y2gsIFJlcXVlc3QsIEhlYWRlcnMgfSA9IHJlcXVpcmUoJy4vaHR0cC9mZXRjaCcpXG5jb25zdCB7IFRpbWVvdXRFcnJvciwgSFRUUEVycm9yIH0gPSByZXF1aXJlKCcuL2h0dHAvZXJyb3InKVxuY29uc3QgbWVyZ2UgPSByZXF1aXJlKCdtZXJnZS1vcHRpb25zJykuYmluZCh7IGlnbm9yZVVuZGVmaW5lZDogdHJ1ZSB9KVxuY29uc3QgeyBVUkwsIFVSTFNlYXJjaFBhcmFtcyB9ID0gcmVxdWlyZSgnaXNvLXVybCcpXG5jb25zdCB7IEFib3J0Q29udHJvbGxlciB9ID0gcmVxdWlyZSgnbmF0aXZlLWFib3J0LWNvbnRyb2xsZXInKVxuY29uc3QgYW55U2lnbmFsID0gcmVxdWlyZSgnYW55LXNpZ25hbCcpXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnc3RyZWFtJykuUmVhZGFibGV9IE5vZGVSZWFkYWJsZVN0cmVhbVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcycpLkhUVFBPcHRpb25zfSBIVFRQT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcycpLkV4dGVuZGVkUmVzcG9uc2V9IEV4dGVuZGVkUmVzcG9uc2VcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUUmVzcG9uc2VcbiAqIEBwYXJhbSB7UHJvbWlzZTxUUmVzcG9uc2U+fSBwcm9taXNlXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gbXNcbiAqIEBwYXJhbSB7QWJvcnRDb250cm9sbGVyfSBhYm9ydENvbnRyb2xsZXJcbiAqIEByZXR1cm5zIHtQcm9taXNlPFRSZXNwb25zZT59XG4gKi9cbmNvbnN0IHRpbWVvdXQgPSAocHJvbWlzZSwgbXMsIGFib3J0Q29udHJvbGxlcikgPT4ge1xuICBpZiAobXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBjb25zdCBzdGFydCA9IERhdGUubm93KClcblxuICBjb25zdCB0aW1lZE91dCA9ICgpID0+IHtcbiAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0XG5cbiAgICByZXR1cm4gdGltZSA+PSBtc1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aW1lZE91dCgpKSB7XG4gICAgICAgIHJlamVjdChuZXcgVGltZW91dEVycm9yKCkpXG4gICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpXG4gICAgICB9XG4gICAgfSwgbXMpXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyh2YWx1ZTogYW55KSA9PiB2b2lkIH0gbmV4dFxuICAgICAqL1xuICAgIGNvbnN0IGFmdGVyID0gKG5leHQpID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHthbnl9IHJlc1xuICAgICAgICovXG4gICAgICBjb25zdCBmbiA9IChyZXMpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRClcblxuICAgICAgICBpZiAodGltZWRPdXQoKSkge1xuICAgICAgICAgIHJlamVjdChuZXcgVGltZW91dEVycm9yKCkpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KHJlcylcbiAgICAgIH1cbiAgICAgIHJldHVybiBmblxuICAgIH1cblxuICAgIHByb21pc2VcbiAgICAgIC50aGVuKGFmdGVyKHJlc29sdmUpLCBhZnRlcihyZWplY3QpKVxuICB9KVxufVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgdGhyb3dIdHRwRXJyb3JzOiB0cnVlLFxuICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ1xufVxuXG5jbGFzcyBIVFRQIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7SFRUUE9wdGlvbnN9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zID0ge30pIHtcbiAgICAvKiogQHR5cGUge0hUVFBPcHRpb25zfSAqL1xuICAgIHRoaXMub3B0cyA9IG1lcmdlKGRlZmF1bHRzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgUmVxdWVzdH0gcmVzb3VyY2VcbiAgICogQHBhcmFtIHtIVFRQT3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFeHRlbmRlZFJlc3BvbnNlPn1cbiAgICovXG4gIGFzeW5jIGZldGNoIChyZXNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLyoqIEB0eXBlIHtIVFRQT3B0aW9uc30gKi9cbiAgICBjb25zdCBvcHRzID0gbWVyZ2UodGhpcy5vcHRzLCBvcHRpb25zKVxuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRzLmhlYWRlcnMpXG5cbiAgICAvLyB2YWxpZGF0ZSByZXNvdXJjZSB0eXBlXG4gICAgaWYgKHR5cGVvZiByZXNvdXJjZSAhPT0gJ3N0cmluZycgJiYgIShyZXNvdXJjZSBpbnN0YW5jZW9mIFVSTCB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgcmVzb3VyY2VgIG11c3QgYmUgYSBzdHJpbmcsIFVSTCwgb3IgUmVxdWVzdCcpXG4gICAgfVxuXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXNvdXJjZS50b1N0cmluZygpLCBvcHRzLmJhc2UpXG5cbiAgICBjb25zdCB7XG4gICAgICBzZWFyY2hQYXJhbXMsXG4gICAgICB0cmFuc2Zvcm1TZWFyY2hQYXJhbXMsXG4gICAgICBqc29uXG4gICAgfSA9IG9wdHNcblxuICAgIGlmIChzZWFyY2hQYXJhbXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtU2VhcmNoUGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdXJsLnNlYXJjaCA9IHRyYW5zZm9ybVNlYXJjaFBhcmFtcyhuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdHMuc2VhcmNoUGFyYW1zKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdXJsLnNlYXJjaCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0cy5zZWFyY2hQYXJhbXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGpzb24pIHtcbiAgICAgIG9wdHMuYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdHMuanNvbilcbiAgICAgIGhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpXG4gICAgfVxuXG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHNpZ25hbCA9IGFueVNpZ25hbChbYWJvcnRDb250cm9sbGVyLnNpZ25hbCwgb3B0cy5zaWduYWxdKVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aW1lb3V0KFxuICAgICAgZmV0Y2goXG4gICAgICAgIHVybC50b1N0cmluZygpLFxuICAgICAgICB7XG4gICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG9wdHMudGltZW91dCxcbiAgICAgIGFib3J0Q29udHJvbGxlclxuICAgIClcblxuICAgIGlmICghcmVzcG9uc2Uub2sgJiYgb3B0cy50aHJvd0h0dHBFcnJvcnMpIHtcbiAgICAgIGlmIChvcHRzLmhhbmRsZUVycm9yKSB7XG4gICAgICAgIGF3YWl0IG9wdHMuaGFuZGxlRXJyb3IocmVzcG9uc2UpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgSFRUUEVycm9yKHJlc3BvbnNlKVxuICAgIH1cblxuICAgIHJlc3BvbnNlLml0ZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZyb21TdHJlYW0ocmVzcG9uc2UuYm9keSlcbiAgICB9XG5cbiAgICByZXNwb25zZS5uZGpzb24gPSBhc3luYyBmdW5jdGlvbiAqICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgbmRqc29uKHJlc3BvbnNlLml0ZXJhdG9yKCkpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnRyYW5zZm9ybSkge1xuICAgICAgICAgIHlpZWxkIG9wdGlvbnMudHJhbnNmb3JtKGNodW5rKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIGNodW5rXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFJlcXVlc3R9IHJlc291cmNlXG4gICAqIEBwYXJhbSB7SFRUUE9wdGlvbnN9IG9wdGlvbnNcbiAgICovXG4gIHBvc3QgKHJlc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaChyZXNvdXJjZSwgeyAuLi5vcHRpb25zLCBtZXRob2Q6ICdQT1NUJyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgUmVxdWVzdH0gcmVzb3VyY2VcbiAgICogQHBhcmFtIHtIVFRQT3B0aW9uc30gb3B0aW9uc1xuICAgKi9cbiAgZ2V0IChyZXNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2gocmVzb3VyY2UsIHsgLi4ub3B0aW9ucywgbWV0aG9kOiAnR0VUJyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgUmVxdWVzdH0gcmVzb3VyY2VcbiAgICogQHBhcmFtIHtIVFRQT3B0aW9uc30gb3B0aW9uc1xuICAgKi9cbiAgcHV0IChyZXNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2gocmVzb3VyY2UsIHsgLi4ub3B0aW9ucywgbWV0aG9kOiAnUFVUJyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgUmVxdWVzdH0gcmVzb3VyY2VcbiAgICogQHBhcmFtIHtIVFRQT3B0aW9uc30gb3B0aW9uc1xuICAgKi9cbiAgZGVsZXRlIChyZXNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2gocmVzb3VyY2UsIHsgLi4ub3B0aW9ucywgbWV0aG9kOiAnREVMRVRFJyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgUmVxdWVzdH0gcmVzb3VyY2VcbiAgICogQHBhcmFtIHtIVFRQT3B0aW9uc30gb3B0aW9uc1xuICAgKi9cbiAgb3B0aW9ucyAocmVzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmZldGNoKHJlc291cmNlLCB7IC4uLm9wdGlvbnMsIG1ldGhvZDogJ09QVElPTlMnIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgTkRKU09OIGNodW5rcyBmcm9tIGFuIGl0ZXJhdG9yXG4gKlxuICogQHBhcmFtIHtBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+fSBzb3VyY2VcbiAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPGFueT59XG4gKi9cbmNvbnN0IG5kanNvbiA9IGFzeW5jIGZ1bmN0aW9uICogKHNvdXJjZSkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbiAgbGV0IGJ1ZiA9ICcnXG5cbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzb3VyY2UpIHtcbiAgICBidWYgKz0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgY29uc3QgbGluZXMgPSBidWYuc3BsaXQoL1xccj9cXG4vKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IGwgPSBsaW5lc1tpXS50cmltKClcbiAgICAgIGlmIChsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgeWllbGQgSlNPTi5wYXJzZShsKVxuICAgICAgfVxuICAgIH1cbiAgICBidWYgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXVxuICB9XG4gIGJ1ZiArPSBkZWNvZGVyLmRlY29kZSgpXG4gIGJ1ZiA9IGJ1Zi50cmltKClcbiAgaWYgKGJ1Zi5sZW5ndGggIT09IDApIHtcbiAgICB5aWVsZCBKU09OLnBhcnNlKGJ1ZilcbiAgfVxufVxuXG4vKipcbiAqIFN0cmVhbSB0byBBc3luY0l0ZXJhYmxlXG4gKlxuICogQHRlbXBsYXRlIFRDaHVua1xuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbTxUQ2h1bms+IHwgTm9kZVJlYWRhYmxlU3RyZWFtIHwgbnVsbH0gc291cmNlXG4gKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxUQ2h1bms+fVxuICovXG5jb25zdCBmcm9tU3RyZWFtID0gKHNvdXJjZSkgPT4ge1xuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy83NjZcbiAgaWYgKGlzTm9kZVJlYWRhYmxlU3RyZWFtKHNvdXJjZSkpIHtcbiAgICBjb25zdCBpdGVyID0gc291cmNlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpXG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5leHQ6IGl0ZXIubmV4dC5iaW5kKGl0ZXIpLFxuICAgICAgICAgIHJldHVybiAodmFsdWUpIHtcbiAgICAgICAgICAgIHNvdXJjZS5kZXN0cm95KClcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlci5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZXIucmV0dXJuKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZSB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc1dlYlJlYWRhYmxlU3RyZWFtKHNvdXJjZSkpIHtcbiAgICBjb25zdCByZWFkZXIgPSBzb3VyY2UuZ2V0UmVhZGVyKClcbiAgICByZXR1cm4gKGFzeW5jIGZ1bmN0aW9uICogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAvLyBSZWFkIGZyb20gdGhlIHN0cmVhbVxuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcbiAgICAgICAgICAvLyBFeGl0IGlmIHdlJ3JlIGRvbmVcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICAgICAgLy8gRWxzZSB5aWVsZCB0aGUgY2h1bmtcbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHlpZWxkIHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKVxuICAgICAgfVxuICAgIH0pKClcbiAgfVxuXG4gIGlmIChpc0FzeW5jSXRlcmFibGUoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2VcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgY2FuXFwndCBiZSBjb252ZXJ0ZWQgdG8gQXN5bmNJdGVyYWJsZScpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgaXQncyBhbiBBc3luY0l0ZXJhYmxlXG4gKlxuICogQHRlbXBsYXRlIHt1bmtub3dufSBUQ2h1bmtcbiAqIEB0ZW1wbGF0ZSB7YW55fSBPdGhlclxuICogQHBhcmFtIHtPdGhlcnxBc3luY0l0ZXJhYmxlPFRDaHVuaz59IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgQXN5bmNJdGVyYWJsZTxUQ2h1bms+fVxuICovXG5jb25zdCBpc0FzeW5jSXRlcmFibGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgdmFsdWUgIT09IG51bGwgJiZcbiAgdHlwZW9mIC8qKiBAdHlwZSB7YW55fSAqLyh2YWx1ZSlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nXG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIHdlYiByZWFkYWJsZSBzdHJlYW1cbiAqXG4gKiBAdGVtcGxhdGUge3Vua25vd259IFRDaHVua1xuICogQHRlbXBsYXRlIHthbnl9IE90aGVyXG4gKiBAcGFyYW0ge090aGVyfFJlYWRhYmxlU3RyZWFtPFRDaHVuaz59IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgUmVhZGFibGVTdHJlYW08VENodW5rPn1cbiAqL1xuY29uc3QgaXNXZWJSZWFkYWJsZVN0cmVhbSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIC8qKiBAdHlwZSB7YW55fSAqLyh2YWx1ZSkuZ2V0UmVhZGVyID09PSAnZnVuY3Rpb24nXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgTm9kZVJlYWRhYmxlU3RyZWFtfVxuICovXG5jb25zdCBpc05vZGVSZWFkYWJsZVN0cmVhbSA9ICh2YWx1ZSkgPT5cbiAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAncmVhZGFibGUnKSAmJlxuICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICd3cml0YWJsZScpXG5cbkhUVFAuSFRUUEVycm9yID0gSFRUUEVycm9yXG5IVFRQLlRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvclxuSFRUUC5zdHJlYW1Ub0FzeW5jSXRlcmF0b3IgPSBmcm9tU3RyZWFtXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmcgfCBSZXF1ZXN0fSByZXNvdXJjZVxuICogQHBhcmFtIHtIVFRQT3B0aW9uc30gW29wdGlvbnNdXG4gKi9cbkhUVFAucG9zdCA9IChyZXNvdXJjZSwgb3B0aW9ucykgPT4gbmV3IEhUVFAob3B0aW9ucykucG9zdChyZXNvdXJjZSwgb3B0aW9ucylcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IFJlcXVlc3R9IHJlc291cmNlXG4gKiBAcGFyYW0ge0hUVFBPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xuSFRUUC5nZXQgPSAocmVzb3VyY2UsIG9wdGlvbnMpID0+IG5ldyBIVFRQKG9wdGlvbnMpLmdldChyZXNvdXJjZSwgb3B0aW9ucylcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IFJlcXVlc3R9IHJlc291cmNlXG4gKiBAcGFyYW0ge0hUVFBPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xuSFRUUC5wdXQgPSAocmVzb3VyY2UsIG9wdGlvbnMpID0+IG5ldyBIVFRQKG9wdGlvbnMpLnB1dChyZXNvdXJjZSwgb3B0aW9ucylcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IFJlcXVlc3R9IHJlc291cmNlXG4gKiBAcGFyYW0ge0hUVFBPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xuSFRUUC5kZWxldGUgPSAocmVzb3VyY2UsIG9wdGlvbnMpID0+IG5ldyBIVFRQKG9wdGlvbnMpLmRlbGV0ZShyZXNvdXJjZSwgb3B0aW9ucylcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IFJlcXVlc3R9IHJlc291cmNlXG4gKiBAcGFyYW0ge0hUVFBPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xuSFRUUC5vcHRpb25zID0gKHJlc291cmNlLCBvcHRpb25zKSA9PiBuZXcgSFRUUChvcHRpb25zKS5vcHRpb25zKHJlc291cmNlLCBvcHRpb25zKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhUVFBcbiIsIid1c2Ugc3RyaWN0J1xuXG5jbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlID0gJ1JlcXVlc3QgdGltZWQgb3V0Jykge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcidcbiAgfVxufVxuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3JcblxuY2xhc3MgQWJvcnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UgPSAnVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcidcbiAgfVxufVxuZXhwb3J0cy5BYm9ydEVycm9yID0gQWJvcnRFcnJvclxuXG5jbGFzcyBIVFRQRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJlc3BvbnNlKSB7XG4gICAgc3VwZXIocmVzcG9uc2Uuc3RhdHVzVGV4dClcbiAgICB0aGlzLm5hbWUgPSAnSFRUUEVycm9yJ1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZVxuICB9XG59XG5leHBvcnRzLkhUVFBFcnJvciA9IEhUVFBFcnJvclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgVGltZW91dEVycm9yLCBBYm9ydEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9yJylcbmNvbnN0IHsgUmVzcG9uc2UsIFJlcXVlc3QsIEhlYWRlcnMsIGRlZmF1bHQ6IGZldGNoIH0gPSByZXF1aXJlKCcuLi9mZXRjaCcpXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5GZXRjaE9wdGlvbnN9IEZldGNoT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMnKS5Qcm9ncmVzc0ZufSBQcm9ncmVzc0ZuXG4gKi9cblxuLyoqXG4gKiBGZXRjaCB3aXRoIHByb2dyZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBSZXF1ZXN0fSB1cmxcbiAqIEBwYXJhbSB7RmV0Y2hPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3BvbnNlV2l0aFVSTD59XG4gKi9cbmNvbnN0IGZldGNoV2l0aFByb2dyZXNzID0gKHVybCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICByZXF1ZXN0Lm9wZW4ob3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsIHVybC50b1N0cmluZygpLCB0cnVlKVxuXG4gIGNvbnN0IHsgdGltZW91dCwgaGVhZGVycyB9ID0gb3B0aW9uc1xuXG4gIGlmICh0aW1lb3V0ICYmIHRpbWVvdXQgPiAwICYmIHRpbWVvdXQgPCBJbmZpbml0eSkge1xuICAgIHJlcXVlc3QudGltZW91dCA9IHRpbWVvdXRcbiAgfVxuXG4gIGlmIChvcHRpb25zLm92ZXJyaWRlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZShvcHRpb25zLm92ZXJyaWRlTWltZVR5cGUpXG4gIH1cblxuICBpZiAoaGVhZGVycykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBuZXcgSGVhZGVycyhoZWFkZXJzKSkge1xuICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgIG9wdGlvbnMuc2lnbmFsLm9uYWJvcnQgPSAoKSA9PiByZXF1ZXN0LmFib3J0KClcbiAgfVxuXG4gIGlmIChvcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICByZXF1ZXN0LnVwbG9hZC5vbnByb2dyZXNzID0gb3B0aW9ucy5vblVwbG9hZFByb2dyZXNzXG4gIH1cblxuICAvLyBOb3RlOiBOZWVkIHRvIHVzZSBgYXJyYXlidWZmZXJgIGhlcmUgaW5zdGVhZCBvZiBgYmxvYmAgYmVjYXVzZSBgQmxvYmBcbiAgLy8gaW5zdGFuY2VzIGNvbWluZyBmcm9tIEpTRE9NIGFyZSBub3QgY29tcGF0aWJsZSB3aXRoIGBSZXNwb25zZWAgZnJvbVxuICAvLyBub2RlLWZldGNoICh3aGljaCBpcyB0aGUgc2V0dXAgd2UgZ2V0IHdoZW4gdGVzdGluZyB3aXRoIGplc3QgYmVjYXVzZVxuICAvLyBpdCB1c2VzIEpTRE9NIHdoaWNoIGRvZXMgbm90IHByb3ZpZGUgYSBnbG9iYWwgZmV0Y2hcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pzZG9tL2pzZG9tL2lzc3Vlcy8xNzI0KVxuICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcidcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgY29uc3QgaGFuZGxlRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlICdlcnJvcic6IHtcbiAgICAgICAgICByZXNvbHZlKFJlc3BvbnNlLmVycm9yKCkpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsb2FkJzoge1xuICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICBuZXcgUmVzcG9uc2VXaXRoVVJMKHJlcXVlc3QucmVzcG9uc2VVUkwsIHJlcXVlc3QucmVzcG9uc2UsIHtcbiAgICAgICAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGltZW91dCc6IHtcbiAgICAgICAgICByZWplY3QobmV3IFRpbWVvdXRFcnJvcigpKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYWJvcnQnOiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBBYm9ydEVycm9yKCkpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBoYW5kbGVFdmVudFxuICAgIHJlcXVlc3Qub25sb2FkID0gaGFuZGxlRXZlbnRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGhhbmRsZUV2ZW50XG4gICAgcmVxdWVzdC5vbmFib3J0ID0gaGFuZGxlRXZlbnRcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igb3B0aW9ucy5ib2R5IGNhbiBiZSBhIG5vZGUgcmVhZGFibGUgc3RyZWFtLCB3aGljaCBpc24ndCBjb21wYXRpYmxlIHdpdGggWEhSLCBidXQgdGhpc1xuICAgIC8vIGZpbGUgaXMgYSBicm93c2VyIG92ZXJyaWRlIHNvIHlvdSB3b24ndCBnZXQgYSBub2RlIHJlYWRhYmxlIHN0cmVhbSBzbyBpZ25vcmUgdGhlIGVycm9yXG4gICAgcmVxdWVzdC5zZW5kKG9wdGlvbnMuYm9keSlcbiAgfSlcbn1cblxuY29uc3QgZmV0Y2hXaXRoU3RyZWFtaW5nID0gZmV0Y2hcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IFJlcXVlc3R9IHVybFxuICogQHBhcmFtIHtGZXRjaE9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuY29uc3QgZmV0Y2hXaXRoID0gKHVybCwgb3B0aW9ucyA9IHt9KSA9PlxuICAob3B0aW9ucy5vblVwbG9hZFByb2dyZXNzICE9IG51bGwpXG4gICAgPyBmZXRjaFdpdGhQcm9ncmVzcyh1cmwsIG9wdGlvbnMpXG4gICAgOiBmZXRjaFdpdGhTdHJlYW1pbmcodXJsLCBvcHRpb25zKVxuXG4vKipcbiAqIFBhcnNlIEhlYWRlcnMgZnJvbSBhIFhNTEh0dHBSZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcmV0dXJucyB7SGVhZGVyc31cbiAqL1xuY29uc3QgcGFyc2VIZWFkZXJzID0gKGlucHV0KSA9PiB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gIGZvciAoY29uc3QgbGluZSBvZiBpbnB1dC50cmltKCkuc3BsaXQoL1tcXHJcXG5dKy8pKSB7XG4gICAgY29uc3QgaW5kZXggPSBsaW5lLmluZGV4T2YoJzogJylcbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICBoZWFkZXJzLnNldChsaW5lLnNsaWNlKDAsIGluZGV4KSwgbGluZS5zbGljZShpbmRleCArIDEpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbmNsYXNzIFJlc3BvbnNlV2l0aFVSTCBleHRlbmRzIFJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHtCb2R5SW5pdH0gYm9keVxuICAgKiBAcGFyYW0ge1Jlc3BvbnNlSW5pdH0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHVybCwgYm9keSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGJvZHksIG9wdGlvbnMpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd1cmwnLCB7IHZhbHVlOiB1cmwgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmV0Y2g6IGZldGNoV2l0aCxcbiAgUmVxdWVzdCxcbiAgSGVhZGVyc1xufVxuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uL2VsZWN0cm9uL2lzc3Vlcy8yMjg4XG5mdW5jdGlvbiBpc0VsZWN0cm9uKCkge1xuICAgIC8vIFJlbmRlcmVyIHByb2Nlc3NcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5wcm9jZXNzID09PSAnb2JqZWN0JyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE1haW4gcHJvY2Vzc1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgPT09ICdvYmplY3QnICYmICEhcHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBEZXRlY3QgdGhlIHVzZXIgYWdlbnQgd2hlbiB0aGUgYG5vZGVJbnRlZ3JhdGlvbmAgb3B0aW9uIGlzIHNldCB0byB0cnVlXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VsZWN0cm9uJykgPj0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFbGVjdHJvbjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGlwUmVnZXggPSByZXF1aXJlKCdpcC1yZWdleCcpO1xuXG5jb25zdCBpc0lwID0gc3RyaW5nID0+IGlwUmVnZXgoe2V4YWN0OiB0cnVlfSkudGVzdChzdHJpbmcpO1xuaXNJcC52NCA9IHN0cmluZyA9PiBpcFJlZ2V4LnY0KHtleGFjdDogdHJ1ZX0pLnRlc3Qoc3RyaW5nKTtcbmlzSXAudjYgPSBzdHJpbmcgPT4gaXBSZWdleC52Nih7ZXhhY3Q6IHRydWV9KS50ZXN0KHN0cmluZyk7XG5pc0lwLnZlcnNpb24gPSBzdHJpbmcgPT4gaXNJcChzdHJpbmcpID8gKGlzSXAudjQoc3RyaW5nKSA/IDQgOiA2KSA6IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0lwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlID0+IHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Y29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcblx0cmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgVVJMV2l0aExlZ2FjeVN1cHBvcnQsXG4gIGZvcm1hdCxcbiAgVVJMU2VhcmNoUGFyYW1zLFxuICBkZWZhdWx0QmFzZVxufSA9IHJlcXVpcmUoJy4vc3JjL3VybCcpXG5jb25zdCByZWxhdGl2ZSA9IHJlcXVpcmUoJy4vc3JjL3JlbGF0aXZlJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFVSTDogVVJMV2l0aExlZ2FjeVN1cHBvcnQsXG4gIFVSTFNlYXJjaFBhcmFtcyxcbiAgZm9ybWF0LFxuICByZWxhdGl2ZSxcbiAgZGVmYXVsdEJhc2Vcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFVSTFdpdGhMZWdhY3lTdXBwb3J0LCBmb3JtYXQgfSA9IHJlcXVpcmUoJy4vdXJsJylcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdXJsXG4gKiBAcGFyYW0ge2FueX0gW2xvY2F0aW9uXVxuICogQHBhcmFtIHthbnl9IFtwcm90b2NvbE1hcF1cbiAqIEBwYXJhbSB7YW55fSBbZGVmYXVsdFByb3RvY29sXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICh1cmwsIGxvY2F0aW9uID0ge30sIHByb3RvY29sTWFwID0ge30sIGRlZmF1bHRQcm90b2NvbCkgPT4ge1xuICBsZXQgcHJvdG9jb2wgPSBsb2NhdGlvbi5wcm90b2NvbFxuICAgID8gbG9jYXRpb24ucHJvdG9jb2wucmVwbGFjZSgnOicsICcnKVxuICAgIDogJ2h0dHAnXG5cbiAgLy8gQ2hlY2sgcHJvdG9jb2wgbWFwXG4gIHByb3RvY29sID0gKHByb3RvY29sTWFwW3Byb3RvY29sXSB8fCBkZWZhdWx0UHJvdG9jb2wgfHwgcHJvdG9jb2wpICsgJzonXG4gIGxldCB1cmxQYXJzZWRcblxuICB0cnkge1xuICAgIHVybFBhcnNlZCA9IG5ldyBVUkxXaXRoTGVnYWN5U3VwcG9ydCh1cmwpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHVybFBhcnNlZCA9IHt9XG4gIH1cblxuICBjb25zdCBiYXNlID0gT2JqZWN0LmFzc2lnbih7fSwgbG9jYXRpb24sIHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wgfHwgdXJsUGFyc2VkLnByb3RvY29sLFxuICAgIGhvc3Q6IGxvY2F0aW9uLmhvc3QgfHwgdXJsUGFyc2VkLmhvc3RcbiAgfSlcblxuICByZXR1cm4gbmV3IFVSTFdpdGhMZWdhY3lTdXBwb3J0KHVybCwgZm9ybWF0KGJhc2UpKS50b1N0cmluZygpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgaXNSZWFjdE5hdGl2ZSA9XG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJ1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0QmFzZSAoKSB7XG4gIGlmIChpc1JlYWN0TmF0aXZlKSB7XG4gICAgcmV0dXJuICdodHRwOi8vbG9jYWxob3N0J1xuICB9XG4gIC8vIGluIHNvbWUgZW52aXJvbm1lbnRzIGkuZS4gY2xvdWRmbGFyZSB3b3JrZXJzIGxvY2F0aW9uIGlzIG5vdCBhdmFpbGFibGVcbiAgaWYgKCFzZWxmLmxvY2F0aW9uKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICByZXR1cm4gc2VsZi5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBzZWxmLmxvY2F0aW9uLmhvc3Rcbn1cblxuY29uc3QgVVJMID0gc2VsZi5VUkxcbmNvbnN0IGRlZmF1bHRCYXNlID0gZ2V0RGVmYXVsdEJhc2UoKVxuXG5jbGFzcyBVUkxXaXRoTGVnYWN5U3VwcG9ydCB7XG4gIGNvbnN0cnVjdG9yICh1cmwgPSAnJywgYmFzZSA9IGRlZmF1bHRCYXNlKSB7XG4gICAgdGhpcy5zdXBlciA9IG5ldyBVUkwodXJsLCBiYXNlKVxuICAgIHRoaXMucGF0aCA9IHRoaXMucGF0aG5hbWUgKyB0aGlzLnNlYXJjaFxuICAgIHRoaXMuYXV0aCA9XG4gICAgICAgICAgICB0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmRcbiAgICAgICAgICAgICAgPyB0aGlzLnVzZXJuYW1lICsgJzonICsgdGhpcy5wYXNzd29yZFxuICAgICAgICAgICAgICA6IG51bGxcblxuICAgIHRoaXMucXVlcnkgPVxuICAgICAgICAgICAgdGhpcy5zZWFyY2ggJiYgdGhpcy5zZWFyY2guc3RhcnRzV2l0aCgnPycpXG4gICAgICAgICAgICAgID8gdGhpcy5zZWFyY2guc2xpY2UoMSlcbiAgICAgICAgICAgICAgOiBudWxsXG4gIH1cblxuICBnZXQgaGFzaCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VwZXIuaGFzaFxuICB9XG5cbiAgZ2V0IGhvc3QgKCkge1xuICAgIHJldHVybiB0aGlzLnN1cGVyLmhvc3RcbiAgfVxuXG4gIGdldCBob3N0bmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VwZXIuaG9zdG5hbWVcbiAgfVxuXG4gIGdldCBocmVmICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBlci5ocmVmXG4gIH1cblxuICBnZXQgb3JpZ2luICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBlci5vcmlnaW5cbiAgfVxuXG4gIGdldCBwYXNzd29yZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VwZXIucGFzc3dvcmRcbiAgfVxuXG4gIGdldCBwYXRobmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VwZXIucGF0aG5hbWVcbiAgfVxuXG4gIGdldCBwb3J0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBlci5wb3J0XG4gIH1cblxuICBnZXQgcHJvdG9jb2wgKCkge1xuICAgIHJldHVybiB0aGlzLnN1cGVyLnByb3RvY29sXG4gIH1cblxuICBnZXQgc2VhcmNoICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBlci5zZWFyY2hcbiAgfVxuXG4gIGdldCBzZWFyY2hQYXJhbXMgKCkge1xuICAgIHJldHVybiB0aGlzLnN1cGVyLnNlYXJjaFBhcmFtc1xuICB9XG5cbiAgZ2V0IHVzZXJuYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBlci51c2VybmFtZVxuICB9XG5cbiAgc2V0IGhhc2ggKGhhc2gpIHtcbiAgICB0aGlzLnN1cGVyLmhhc2ggPSBoYXNoXG4gIH1cblxuICBzZXQgaG9zdCAoaG9zdCkge1xuICAgIHRoaXMuc3VwZXIuaG9zdCA9IGhvc3RcbiAgfVxuXG4gIHNldCBob3N0bmFtZSAoaG9zdG5hbWUpIHtcbiAgICB0aGlzLnN1cGVyLmhvc3RuYW1lID0gaG9zdG5hbWVcbiAgfVxuXG4gIHNldCBocmVmIChocmVmKSB7XG4gICAgdGhpcy5zdXBlci5ocmVmID0gaHJlZlxuICB9XG5cbiAgc2V0IHBhc3N3b3JkIChwYXNzd29yZCkge1xuICAgIHRoaXMuc3VwZXIucGFzc3dvcmQgPSBwYXNzd29yZFxuICB9XG5cbiAgc2V0IHBhdGhuYW1lIChwYXRobmFtZSkge1xuICAgIHRoaXMuc3VwZXIucGF0aG5hbWUgPSBwYXRobmFtZVxuICB9XG5cbiAgc2V0IHBvcnQgKHBvcnQpIHtcbiAgICB0aGlzLnN1cGVyLnBvcnQgPSBwb3J0XG4gIH1cblxuICBzZXQgcHJvdG9jb2wgKHByb3RvY29sKSB7XG4gICAgdGhpcy5zdXBlci5wcm90b2NvbCA9IHByb3RvY29sXG4gIH1cblxuICBzZXQgc2VhcmNoIChzZWFyY2gpIHtcbiAgICB0aGlzLnN1cGVyLnNlYXJjaCA9IHNlYXJjaFxuICB9XG5cbiAgc2V0IHVzZXJuYW1lICh1c2VybmFtZSkge1xuICAgIHRoaXMuc3VwZXIudXNlcm5hbWUgPSB1c2VybmFtZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBvXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlT2JqZWN0VVJMIChvKSB7XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb1xuICAgKi9cbiAgc3RhdGljIHJldm9rZU9iamVjdFVSTCAobykge1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwobylcbiAgfVxuXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VwZXIudG9KU09OKClcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBlci50b1N0cmluZygpXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nIHwgaW1wb3J0KCd1cmwnKS5VcmxPYmplY3R9IG9ialxuICovXG5mdW5jdGlvbiBmb3JtYXQgKG9iaikge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKG9iailcblxuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKVxuICB9XG5cbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIGNvbnN0IHVzZXJQYXNzID1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgaXRzIG5vdCBzdXBwb3J0ZWQgaW4gbm9kZSBidXQgd2Ugbm9ybWFsaXNlXG4gICAgICAgICAgICBvYmoudXNlcm5hbWUgJiYgb2JqLnBhc3N3b3JkXG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgaXRzIG5vdCBzdXBwb3J0ZWQgaW4gbm9kZSBidXQgd2Ugbm9ybWFsaXNlXG4gICAgICAgICAgICAgID8gYCR7b2JqLnVzZXJuYW1lfToke29iai5wYXNzd29yZH1AYFxuICAgICAgICAgICAgICA6ICcnXG4gICAgY29uc3QgYXV0aCA9IG9iai5hdXRoID8gb2JqLmF1dGggKyAnQCcgOiAnJ1xuICAgIGNvbnN0IHBvcnQgPSBvYmoucG9ydCA/ICc6JyArIG9iai5wb3J0IDogJydcbiAgICBjb25zdCBwcm90b2NvbCA9IG9iai5wcm90b2NvbCA/IG9iai5wcm90b2NvbCArICcvLycgOiAnJ1xuICAgIGNvbnN0IGhvc3QgPSBvYmouaG9zdCB8fCAnJ1xuICAgIGNvbnN0IGhvc3RuYW1lID0gb2JqLmhvc3RuYW1lIHx8ICcnXG4gICAgY29uc3Qgc2VhcmNoID0gb2JqLnNlYXJjaCB8fCAob2JqLnF1ZXJ5ID8gJz8nICsgb2JqLnF1ZXJ5IDogJycpXG4gICAgY29uc3QgaGFzaCA9IG9iai5oYXNoIHx8ICcnXG4gICAgY29uc3QgcGF0aG5hbWUgPSBvYmoucGF0aG5hbWUgfHwgJydcbiAgICAvLyBAdHMtaWdub3JlIC0gcGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIG5vZGUgYnV0IHdlIG5vcm1hbGlzZVxuICAgIGNvbnN0IHBhdGggPSBvYmoucGF0aCB8fCBwYXRobmFtZSArIHNlYXJjaFxuXG4gICAgcmV0dXJuIGAke3Byb3RvY29sfSR7dXNlclBhc3MgfHwgYXV0aH0ke1xuICAgICAgICAgICAgaG9zdCB8fCBob3N0bmFtZSArIHBvcnRcbiAgICAgICAgfSR7cGF0aH0ke2hhc2h9YFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBVUkxXaXRoTGVnYWN5U3VwcG9ydCxcbiAgVVJMU2VhcmNoUGFyYW1zOiBzZWxmLlVSTFNlYXJjaFBhcmFtcyxcbiAgZGVmYXVsdEJhc2UsXG4gIGZvcm1hdFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQ29sbGVjdHMgYWxsIHZhbHVlcyBmcm9tIGFuIChhc3luYykgaXRlcmFibGUgaW50byBhbiBhcnJheSBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBc3luY0l0ZXJhYmxlPFQ+fEl0ZXJhYmxlPFQ+fSBzb3VyY2VcbiAqL1xuY29uc3QgYWxsID0gYXN5bmMgKHNvdXJjZSkgPT4ge1xuICBjb25zdCBhcnIgPSBbXVxuXG4gIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2Ygc291cmNlKSB7XG4gICAgYXJyLnB1c2goZW50cnkpXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWxsXG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCByZXN1bHQgZnJvbSBhbiAoYXN5bmMpIGl0ZXJhYmxlLCB1bmxlc3MgZW1wdHksIGluIHdoaWNoXG4gKiBjYXNlIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxUPnxJdGVyYWJsZTxUPn0gc291cmNlXG4gKi9cbmNvbnN0IGZpcnN0ID0gYXN5bmMgKHNvdXJjZSkgPT4ge1xuICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVucmVhY2hhYmxlLWxvb3BcbiAgICByZXR1cm4gZW50cnlcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaXJzdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBpdGVtIG9mIGFuIChhc3luYykgaXRlcmFibGUsIHVubGVzcyBlbXB0eSwgaW4gd2hpY2ggY2FzZVxuICogcmV0dXJuIGB1bmRlZmluZWRgLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FzeW5jSXRlcmFibGU8VD58SXRlcmFibGU8VD59IHNvdXJjZVxuICovXG5jb25zdCBsYXN0ID0gYXN5bmMgKHNvdXJjZSkgPT4ge1xuICBsZXQgcmVzXG5cbiAgZm9yIGF3YWl0IChjb25zdCBlbnRyeSBvZiBzb3VyY2UpIHtcbiAgICByZXMgPSBlbnRyeVxuICB9XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxhc3RcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFRha2VzIGFuIChhc3luYykgaXRlcmFibGUgYW5kIHJldHVybnMgb25lIHdpdGggZWFjaCBpdGVtIG1hcHBlZCBieSB0aGUgcGFzc2VkXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgSSxPXG4gKiBAcGFyYW0ge0FzeW5jSXRlcmFibGU8ST58SXRlcmFibGU8ST59IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbihJKTpPfFByb21pc2U8Tz59IGZ1bmNcbiAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPE8+fVxuICovXG5jb25zdCBtYXAgPSBhc3luYyBmdW5jdGlvbiAqIChzb3VyY2UsIGZ1bmMpIHtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2Ygc291cmNlKSB7XG4gICAgeWllbGQgZnVuYyh2YWwpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQZWVrXG4gKiBAcHJvcGVydHkgeygpID0+IEl0ZXJhdG9yUmVzdWx0PFQsIHZvaWQ+fSBwZWVrXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge09iamVjdH0gQXN5bmNQZWVrXG4gKiBAcHJvcGVydHkgeygpID0+IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8VCwgdm9pZD4+fSBwZWVrXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge09iamVjdH0gUHVzaFxuICogQHByb3BlcnR5IHsodmFsdWU6VCkgPT4gdm9pZH0gcHVzaFxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtJdGVyYWJsZTxUPiAmIFBlZWs8VD4gJiBQdXNoPFQ+ICYgSXRlcmF0b3I8VD59IFBlZWthYmxlPFQ+XG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge0FzeW5jSXRlcmFibGU8VD4gJiBBc3luY1BlZWs8VD4gJiBQdXNoPFQ+ICYgQXN5bmNJdGVyYXRvcjxUPn0gQXN5bmNQZWVrYWJsZTxUPlxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtJdGVyYWJsZTxhbnk+IHwgQXN5bmNJdGVyYWJsZTxhbnk+fSBJXG4gKiBAcGFyYW0ge0l9IGl0ZXJhYmxlXG4gKiBAcmV0dXJucyB7SSBleHRlbmRzIEl0ZXJhYmxlPGluZmVyIFQ+XG4gKiAgPyBQZWVrYWJsZTxUPlxuICogIDogSSBleHRlbmRzIEFzeW5jSXRlcmFibGU8aW5mZXIgVD5cbiAqICA/IEFzeW5jUGVla2FibGU8VD5cbiAqICA6IG5ldmVyXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHBlZWthYmxlSXRlcmF0b3IgKGl0ZXJhYmxlKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgW2l0ZXJhdG9yLCBzeW1ib2xdID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgID8gW2l0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpLCBTeW1ib2wuYXN5bmNJdGVyYXRvcl1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgOiBbaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpLCBTeW1ib2wuaXRlcmF0b3JdXG5cbiAgLyoqIEB0eXBlIHthbnlbXX0gKi9cbiAgY29uc3QgcXVldWUgPSBbXVxuXG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIHtcbiAgICBwZWVrOiAoKSA9PiB7XG4gICAgICByZXR1cm4gaXRlcmF0b3IubmV4dCgpXG4gICAgfSxcbiAgICBwdXNoOiAodmFsdWUpID0+IHtcbiAgICAgIHF1ZXVlLnB1c2godmFsdWUpXG4gICAgfSxcbiAgICBuZXh0OiAoKSA9PiB7XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IHF1ZXVlLnNoaWZ0KClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlcmF0b3IubmV4dCgpXG4gICAgfSxcbiAgICBbc3ltYm9sXSAoKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlZWthYmxlSXRlcmF0b3JcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGlzT3B0aW9uT2JqZWN0ID0gcmVxdWlyZSgnaXMtcGxhaW4tb2JqJyk7XG5cbmNvbnN0IHtoYXNPd25Qcm9wZXJ0eX0gPSBPYmplY3QucHJvdG90eXBlO1xuY29uc3Qge3Byb3BlcnR5SXNFbnVtZXJhYmxlfSA9IE9iamVjdDtcbmNvbnN0IGRlZmluZVByb3BlcnR5ID0gKG9iamVjdCwgbmFtZSwgdmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0dmFsdWUsXG5cdHdyaXRhYmxlOiB0cnVlLFxuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5jb25zdCBnbG9iYWxUaGlzID0gdGhpcztcbmNvbnN0IGRlZmF1bHRNZXJnZU9wdGlvbnMgPSB7XG5cdGNvbmNhdEFycmF5czogZmFsc2UsXG5cdGlnbm9yZVVuZGVmaW5lZDogZmFsc2Vcbn07XG5cbmNvbnN0IGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMgPSB2YWx1ZSA9PiB7XG5cdGNvbnN0IGtleXMgPSBbXTtcblxuXHRmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG5cdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHR9XG5cdH1cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cblx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSk7XG5cblx0XHRmb3IgKGNvbnN0IHN5bWJvbCBvZiBzeW1ib2xzKSB7XG5cdFx0XHRpZiAocHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgc3ltYm9sKSkge1xuXHRcdFx0XHRrZXlzLnB1c2goc3ltYm9sKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ga2V5cztcbn07XG5cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdHJldHVybiBjbG9uZUFycmF5KHZhbHVlKTtcblx0fVxuXG5cdGlmIChpc09wdGlvbk9iamVjdCh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gY2xvbmVPcHRpb25PYmplY3QodmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjbG9uZUFycmF5KGFycmF5KSB7XG5cdGNvbnN0IHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIDApO1xuXG5cdGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoYXJyYXkpLmZvckVhY2goa2V5ID0+IHtcblx0XHRkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgY2xvbmUoYXJyYXlba2V5XSkpO1xuXHR9KTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjbG9uZU9wdGlvbk9iamVjdChvYmplY3QpIHtcblx0Y29uc3QgcmVzdWx0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG5cblx0Z2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyhvYmplY3QpLmZvckVhY2goa2V5ID0+IHtcblx0XHRkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgY2xvbmUob2JqZWN0W2tleV0pKTtcblx0fSk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IG1lcmdlZCBhbHJlYWR5IGNsb25lZFxuICogQHBhcmFtIHsqfSBzb3VyY2Ugc29tZXRoaW5nIHRvIG1lcmdlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlzIGtleXMgdG8gbWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlnIE9iamVjdFxuICogQHJldHVybnMgeyp9IGNsb25lZCBPYmplY3RcbiAqL1xuY29uc3QgbWVyZ2VLZXlzID0gKG1lcmdlZCwgc291cmNlLCBrZXlzLCBjb25maWcpID0+IHtcblx0a2V5cy5mb3JFYWNoKGtleSA9PiB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Vba2V5XSA9PT0gJ3VuZGVmaW5lZCcgJiYgY29uZmlnLmlnbm9yZVVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERvIG5vdCByZWN1cnNlIGludG8gcHJvdG90eXBlIGNoYWluIG9mIG1lcmdlZFxuXHRcdGlmIChrZXkgaW4gbWVyZ2VkICYmIG1lcmdlZFtrZXldICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobWVyZ2VkKSkge1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkobWVyZ2VkLCBrZXksIG1lcmdlKG1lcmdlZFtrZXldLCBzb3VyY2Vba2V5XSwgY29uZmlnKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlZmluZVByb3BlcnR5KG1lcmdlZCwga2V5LCBjbG9uZShzb3VyY2Vba2V5XSkpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIG1lcmdlZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsqfSBtZXJnZWQgYWxyZWFkeSBjbG9uZWRcbiAqIEBwYXJhbSB7Kn0gc291cmNlIHNvbWV0aGluZyB0byBtZXJnZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWcgT2JqZWN0XG4gKiBAcmV0dXJucyB7Kn0gY2xvbmVkIE9iamVjdFxuICpcbiAqIHNlZSBbQXJyYXkucHJvdG90eXBlLmNvbmNhdCAoIC4uLmFyZ3VtZW50cyApXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdClcbiAqL1xuY29uc3QgY29uY2F0QXJyYXlzID0gKG1lcmdlZCwgc291cmNlLCBjb25maWcpID0+IHtcblx0bGV0IHJlc3VsdCA9IG1lcmdlZC5zbGljZSgwLCAwKTtcblx0bGV0IHJlc3VsdEluZGV4ID0gMDtcblxuXHRbbWVyZ2VkLCBzb3VyY2VdLmZvckVhY2goYXJyYXkgPT4ge1xuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblxuXHRcdC8vIGByZXN1bHQuY29uY2F0KGFycmF5KWAgd2l0aCBjbG9uaW5nXG5cdFx0Zm9yIChsZXQgayA9IDA7IGsgPCBhcnJheS5sZW5ndGg7IGsrKykge1xuXHRcdFx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBrKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aW5kaWNlcy5wdXNoKFN0cmluZyhrKSk7XG5cblx0XHRcdGlmIChhcnJheSA9PT0gbWVyZ2VkKSB7XG5cdFx0XHRcdC8vIEFscmVhZHkgY2xvbmVkXG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc3VsdCwgcmVzdWx0SW5kZXgrKywgYXJyYXlba10pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkocmVzdWx0LCByZXN1bHRJbmRleCsrLCBjbG9uZShhcnJheVtrXSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE1lcmdlIG5vbi1pbmRleCBrZXlzXG5cdFx0cmVzdWx0ID0gbWVyZ2VLZXlzKHJlc3VsdCwgYXJyYXksIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoYXJyYXkpLmZpbHRlcihrZXkgPT4gIWluZGljZXMuaW5jbHVkZXMoa2V5KSksIGNvbmZpZyk7XG5cdH0pO1xuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gbWVyZ2VkIGFscmVhZHkgY2xvbmVkXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBzb21ldGhpbmcgdG8gbWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlnIE9iamVjdFxuICogQHJldHVybnMgeyp9IGNsb25lZCBPYmplY3RcbiAqL1xuZnVuY3Rpb24gbWVyZ2UobWVyZ2VkLCBzb3VyY2UsIGNvbmZpZykge1xuXHRpZiAoY29uZmlnLmNvbmNhdEFycmF5cyAmJiBBcnJheS5pc0FycmF5KG1lcmdlZCkgJiYgQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG5cdFx0cmV0dXJuIGNvbmNhdEFycmF5cyhtZXJnZWQsIHNvdXJjZSwgY29uZmlnKTtcblx0fVxuXG5cdGlmICghaXNPcHRpb25PYmplY3Qoc291cmNlKSB8fCAhaXNPcHRpb25PYmplY3QobWVyZ2VkKSkge1xuXHRcdHJldHVybiBjbG9uZShzb3VyY2UpO1xuXHR9XG5cblx0cmV0dXJuIG1lcmdlS2V5cyhtZXJnZWQsIHNvdXJjZSwgZ2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyhzb3VyY2UpLCBjb25maWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICguLi5vcHRpb25zKSB7XG5cdGNvbnN0IGNvbmZpZyA9IG1lcmdlKGNsb25lKGRlZmF1bHRNZXJnZU9wdGlvbnMpLCAodGhpcyAhPT0gZ2xvYmFsVGhpcyAmJiB0aGlzKSB8fCB7fSwgZGVmYXVsdE1lcmdlT3B0aW9ucyk7XG5cdGxldCBtZXJnZWQgPSB7Xzoge319O1xuXG5cdGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICghaXNPcHRpb25PYmplY3Qob3B0aW9uKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYCcgKyBvcHRpb24gKyAnYCBpcyBub3QgYW4gT3B0aW9uIE9iamVjdCcpO1xuXHRcdH1cblxuXHRcdG1lcmdlZCA9IG1lcmdlKG1lcmdlZCwge186IG9wdGlvbn0sIGNvbmZpZyk7XG5cdH1cblxuXHRyZXR1cm4gbWVyZ2VkLl87XG59O1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCJjb25zdCB7IE11bHRpYWRkciB9ID0gcmVxdWlyZSgnbXVsdGlhZGRyJylcblxuY29uc3QgcmVkdWNlVmFsdWUgPSAoXywgdikgPT4gdlxuY29uc3QgdGNwVXJpID0gKHN0ciwgcG9ydCwgcGFydHMsIG9wdHMpID0+IHtcbiAgLy8gcmV0dXJuIHRjcCB3aGVuIGV4cGxpY2l0bHkgcmVxdWVzdGVkXG4gIGlmIChvcHRzICYmIG9wdHMuYXNzdW1lSHR0cCA9PT0gZmFsc2UpIHJldHVybiBgdGNwOi8vJHtzdHJ9OiR7cG9ydH1gXG4gIC8vIGNoZWNrIGlmIHRjcCBpcyB0aGUgbGFzdCBwcm90b2NvbCBpbiBtdWx0aWFkZHJcbiAgbGV0IHByb3RvY29sID0gJ3RjcCdcbiAgbGV0IGV4cGxpY2l0UG9ydCA9IGA6JHtwb3J0fWBcbiAgY29uc3QgbGFzdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXG4gIGlmIChsYXN0LnByb3RvY29sID09PSAndGNwJykge1xuICAgIC8vIGFzc3VtZSBodHRwIGFuZCBwcm9kdWNlIGNsZWFuIHVybHNcbiAgICBwcm90b2NvbCA9IHBvcnQgPT09ICc0NDMnID8gJ2h0dHBzJyA6ICdodHRwJ1xuICAgIGV4cGxpY2l0UG9ydCA9IHBvcnQgPT09ICc0NDMnIHx8IHBvcnQgPT09ICc4MCcgPyAnJyA6IGV4cGxpY2l0UG9ydFxuICB9XG4gIHJldHVybiBgJHtwcm90b2NvbH06Ly8ke3N0cn0ke2V4cGxpY2l0UG9ydH1gXG59XG5cbmNvbnN0IFJlZHVjZXJzID0ge1xuICBpcDQ6IHJlZHVjZVZhbHVlLFxuICBpcDY6IChzdHIsIGNvbnRlbnQsIGksIHBhcnRzKSA9PiAoXG4gICAgcGFydHMubGVuZ3RoID09PSAxICYmIHBhcnRzWzBdLnByb3RvY29sID09PSAnaXA2J1xuICAgICAgPyBjb250ZW50XG4gICAgICA6IGBbJHtjb250ZW50fV1gXG4gICksXG4gIHRjcDogKHN0ciwgY29udGVudCwgaSwgcGFydHMsIG9wdHMpID0+IChcbiAgICBwYXJ0cy5zb21lKHAgPT4gWydodHRwJywgJ2h0dHBzJywgJ3dzJywgJ3dzcyddLmluY2x1ZGVzKHAucHJvdG9jb2wpKVxuICAgICAgPyBgJHtzdHJ9OiR7Y29udGVudH1gXG4gICAgICA6IHRjcFVyaShzdHIsIGNvbnRlbnQsIHBhcnRzLCBvcHRzKVxuICApLFxuICB1ZHA6IChzdHIsIGNvbnRlbnQpID0+IGB1ZHA6Ly8ke3N0cn06JHtjb250ZW50fWAsXG4gIGRuc2FkZHI6IHJlZHVjZVZhbHVlLFxuICBkbnM0OiByZWR1Y2VWYWx1ZSxcbiAgZG5zNjogcmVkdWNlVmFsdWUsXG4gIGlwZnM6IChzdHIsIGNvbnRlbnQpID0+IGAke3N0cn0vaXBmcy8ke2NvbnRlbnR9YCxcbiAgcDJwOiAoc3RyLCBjb250ZW50KSA9PiBgJHtzdHJ9L3AycC8ke2NvbnRlbnR9YCxcbiAgaHR0cDogc3RyID0+IGBodHRwOi8vJHtzdHJ9YCxcbiAgaHR0cHM6IHN0ciA9PiBgaHR0cHM6Ly8ke3N0cn1gLFxuICB3czogc3RyID0+IGB3czovLyR7c3RyfWAsXG4gIHdzczogc3RyID0+IGB3c3M6Ly8ke3N0cn1gLFxuICAncDJwLXdlYnNvY2tldC1zdGFyJzogc3RyID0+IGAke3N0cn0vcDJwLXdlYnNvY2tldC1zdGFyYCxcbiAgJ3AycC13ZWJydGMtc3Rhcic6IHN0ciA9PiBgJHtzdHJ9L3AycC13ZWJydGMtc3RhcmAsXG4gICdwMnAtd2VicnRjLWRpcmVjdCc6IHN0ciA9PiBgJHtzdHJ9L3AycC13ZWJydGMtZGlyZWN0YFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChtdWx0aWFkZHIsIG9wdHMpID0+IHtcbiAgY29uc3QgbWEgPSBuZXcgTXVsdGlhZGRyKG11bHRpYWRkcilcbiAgY29uc3QgcGFydHMgPSBtdWx0aWFkZHIudG9TdHJpbmcoKS5zcGxpdCgnLycpLnNsaWNlKDEpXG4gIHJldHVybiBtYVxuICAgIC50dXBsZXMoKVxuICAgIC5tYXAodHVwbGUgPT4gKHtcbiAgICAgIHByb3RvY29sOiBwYXJ0cy5zaGlmdCgpLFxuICAgICAgY29udGVudDogdHVwbGVbMV0gPyBwYXJ0cy5zaGlmdCgpIDogbnVsbFxuICAgIH0pKVxuICAgIC5yZWR1Y2UoKHN0ciwgcGFydCwgaSwgcGFydHMpID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZSA9IFJlZHVjZXJzW3BhcnQucHJvdG9jb2xdXG4gICAgICBpZiAoIXJlZHVjZSkgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm90b2NvbCAke3BhcnQucHJvdG9jb2x9YClcbiAgICAgIHJldHVybiByZWR1Y2Uoc3RyLCBwYXJ0LmNvbnRlbnQsIGksIHBhcnRzLCBvcHRzKVxuICAgIH0sICcnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbnZlcnQgPSByZXF1aXJlKCcuL2NvbnZlcnQnKVxuY29uc3QgcHJvdG9jb2xzID0gcmVxdWlyZSgnLi9wcm90b2NvbHMtdGFibGUnKVxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IHsgY29uY2F0OiB1aW50OEFycmF5Q29uY2F0IH0gPSByZXF1aXJlKCd1aW50OGFycmF5cy9jb25jYXQnKVxuY29uc3QgeyB0b1N0cmluZzogdWludDhBcnJheVRvU3RyaW5nIH0gPSByZXF1aXJlKCd1aW50OGFycmF5cy90by1zdHJpbmcnKVxuXG4vLyBleHBvcnQgY29kZWNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmdUb1N0cmluZ1R1cGxlcyxcbiAgc3RyaW5nVHVwbGVzVG9TdHJpbmcsXG5cbiAgdHVwbGVzVG9TdHJpbmdUdXBsZXMsXG4gIHN0cmluZ1R1cGxlc1RvVHVwbGVzLFxuXG4gIGJ5dGVzVG9UdXBsZXMsXG4gIHR1cGxlc1RvQnl0ZXMsXG5cbiAgYnl0ZXNUb1N0cmluZyxcbiAgc3RyaW5nVG9CeXRlcyxcblxuICBmcm9tU3RyaW5nLFxuICBmcm9tQnl0ZXMsXG4gIHZhbGlkYXRlQnl0ZXMsXG4gIGlzVmFsaWRCeXRlcyxcbiAgY2xlYW5QYXRoLFxuXG4gIFBhcnNlRXJyb3IsXG4gIHByb3RvRnJvbVR1cGxlLFxuXG4gIHNpemVGb3JBZGRyXG59XG5cbi8vIHN0cmluZyAtPiBbW3N0ciBuYW1lLCBzdHIgYWRkcl0uLi4gXVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvU3RyaW5nVHVwbGVzIChzdHIpIHtcbiAgY29uc3QgdHVwbGVzID0gW11cbiAgY29uc3QgcGFydHMgPSBzdHIuc3BsaXQoJy8nKS5zbGljZSgxKSAvLyBza2lwIGZpcnN0IGVtcHR5IGVsZW1cbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSAmJiBwYXJ0c1swXSA9PT0gJycpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIGZvciAobGV0IHAgPSAwOyBwIDwgcGFydHMubGVuZ3RoOyBwKyspIHtcbiAgICBjb25zdCBwYXJ0ID0gcGFydHNbcF1cbiAgICBjb25zdCBwcm90byA9IHByb3RvY29scyhwYXJ0KVxuXG4gICAgaWYgKHByb3RvLnNpemUgPT09IDApIHtcbiAgICAgIHR1cGxlcy5wdXNoKFtwYXJ0XSlcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgcCsrIC8vIGFkdmFuY2UgYWRkciBwYXJ0XG4gICAgaWYgKHAgPj0gcGFydHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBQYXJzZUVycm9yKCdpbnZhbGlkIGFkZHJlc3M6ICcgKyBzdHIpXG4gICAgfVxuXG4gICAgLy8gaWYgaXQncyBhIHBhdGggcHJvdG8sIHRha2UgdGhlIHJlc3RcbiAgICBpZiAocHJvdG8ucGF0aCkge1xuICAgICAgdHVwbGVzLnB1c2goW1xuICAgICAgICBwYXJ0LFxuICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2UgbmVlZCB0byBjaGVjayBlYWNoIHBhdGggcGFydCB0byBzZWUgaWYgaXQncyBhIHByb3RvP1xuICAgICAgICAvLyBUaGlzIHdvdWxkIGFsbG93IGZvciBvdGhlciBwcm90b2NvbHMgdG8gYmUgYWRkZWQgYWZ0ZXIgYSB1bml4IHBhdGgsXG4gICAgICAgIC8vIGhvd2V2ZXIgaXQgd291bGQgaGF2ZSBpc3N1ZXMgaWYgdGhlIHBhdGggaGFkIGEgcHJvdG9jb2wgbmFtZSBpbiB0aGUgcGF0aFxuICAgICAgICBjbGVhblBhdGgocGFydHMuc2xpY2UocCkuam9pbignLycpKVxuICAgICAgXSlcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgdHVwbGVzLnB1c2goW3BhcnQsIHBhcnRzW3BdXSlcbiAgfVxuXG4gIHJldHVybiB0dXBsZXNcbn1cblxuLy8gW1tzdHIgbmFtZSwgc3RyIGFkZHJdLi4uIF0gLT4gc3RyaW5nXG4vKipcbiAqIEBwYXJhbSB7W251bWJlciwgc3RyaW5nP11bXX0gdHVwbGVzXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1R1cGxlc1RvU3RyaW5nICh0dXBsZXMpIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmcgfCB1bmRlZmluZWQ+fSAqL1xuICBjb25zdCBwYXJ0cyA9IFtdXG4gIHR1cGxlcy5tYXAoKHR1cCkgPT4ge1xuICAgIGNvbnN0IHByb3RvID0gcHJvdG9Gcm9tVHVwbGUodHVwKVxuICAgIHBhcnRzLnB1c2gocHJvdG8ubmFtZSlcbiAgICBpZiAodHVwLmxlbmd0aCA+IDEpIHtcbiAgICAgIHBhcnRzLnB1c2godHVwWzFdKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9KVxuXG4gIHJldHVybiBjbGVhblBhdGgocGFydHMuam9pbignLycpKVxufVxuXG4vLyBbW3N0ciBuYW1lLCBzdHIgYWRkcl0uLi4gXSAtPiBbW2ludCBjb2RlLCBVaW50OEFycmF5XS4uLiBdXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nW10gfCBzdHJpbmcgPn0gdHVwbGVzXG4gKiBAcmV0dXJucyB7W251bWJlciAsIFVpbnQ4QXJyYXk/XVtdfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUdXBsZXNUb1R1cGxlcyAodHVwbGVzKSB7XG4gIHJldHVybiB0dXBsZXMubWFwKCh0dXApID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHVwKSkge1xuICAgICAgdHVwID0gW3R1cF1cbiAgICB9XG4gICAgY29uc3QgcHJvdG8gPSBwcm90b0Zyb21UdXBsZSh0dXApXG4gICAgaWYgKHR1cC5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gW3Byb3RvLmNvZGUsIGNvbnZlcnQudG9CeXRlcyhwcm90by5jb2RlLCB0dXBbMV0pXVxuICAgIH1cbiAgICByZXR1cm4gW3Byb3RvLmNvZGVdXG4gIH0pXG59XG5cbi8qKlxuICogQ29udmVydCB0dXBsZXMgdG8gc3RyaW5nIHR1cGxlc1xuICpcbiAqIFtbaW50IGNvZGUsIFVpbnQ4QXJyYXldLi4uIF0gLT4gW1tpbnQgY29kZSwgc3RyIGFkZHJdLi4uIF1cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFtudW1iZXIsIFVpbnQ4QXJyYXk/XT59IHR1cGxlc1xuICogQHJldHVybnMge0FycmF5PFtudW1iZXIsIHN0cmluZz9dPn1cbiAqL1xuXG5mdW5jdGlvbiB0dXBsZXNUb1N0cmluZ1R1cGxlcyAodHVwbGVzKSB7XG4gIHJldHVybiB0dXBsZXMubWFwKHR1cCA9PiB7XG4gICAgY29uc3QgcHJvdG8gPSBwcm90b0Zyb21UdXBsZSh0dXApXG4gICAgaWYgKHR1cFsxXSkge1xuICAgICAgcmV0dXJuIFtwcm90by5jb2RlLCBjb252ZXJ0LnRvU3RyaW5nKHByb3RvLmNvZGUsIHR1cFsxXSldXG4gICAgfVxuICAgIHJldHVybiBbcHJvdG8uY29kZV1cbiAgfSlcbn1cblxuLy8gW1tpbnQgY29kZSwgVWludDhBcnJheSBdLi4uIF0gLT4gVWludDhBcnJheVxuLyoqXG4gKiBAcGFyYW0ge1tudW1iZXIsIFVpbnQ4QXJyYXk/XVtdfSB0dXBsZXNcbiAqL1xuZnVuY3Rpb24gdHVwbGVzVG9CeXRlcyAodHVwbGVzKSB7XG4gIHJldHVybiBmcm9tQnl0ZXModWludDhBcnJheUNvbmNhdCh0dXBsZXMubWFwKCgvKiogQHR5cGUge2FueVtdfSAqLyB0dXApID0+IHtcbiAgICBjb25zdCBwcm90byA9IHByb3RvRnJvbVR1cGxlKHR1cClcbiAgICBsZXQgYnVmID0gVWludDhBcnJheS5mcm9tKHZhcmludC5lbmNvZGUocHJvdG8uY29kZSkpXG5cbiAgICBpZiAodHVwLmxlbmd0aCA+IDEpIHtcbiAgICAgIGJ1ZiA9IHVpbnQ4QXJyYXlDb25jYXQoW2J1ZiwgdHVwWzFdXSkgLy8gYWRkIGFkZHJlc3MgYnVmZmVyXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZlxuICB9KSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3R5cGVzXCIpLlByb3RvY29sfSBwXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBudW1iZXJbXX0gYWRkclxuICovXG5mdW5jdGlvbiBzaXplRm9yQWRkciAocCwgYWRkcikge1xuICBpZiAocC5zaXplID4gMCkge1xuICAgIHJldHVybiBwLnNpemUgLyA4XG4gIH0gZWxzZSBpZiAocC5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIDBcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzaXplID0gdmFyaW50LmRlY29kZShhZGRyKVxuICAgIHJldHVybiBzaXplICsgdmFyaW50LmRlY29kZS5ieXRlc1xuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJucyB7QXJyYXk8W251bWJlciwgVWludDhBcnJheT9dPn1cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1R1cGxlcyAoYnVmKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8W251bWJlciwgVWludDhBcnJheT9dPn0gKi9cbiAgY29uc3QgdHVwbGVzID0gW11cbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgYnVmLmxlbmd0aCkge1xuICAgIGNvbnN0IGNvZGUgPSB2YXJpbnQuZGVjb2RlKGJ1ZiwgaSlcbiAgICBjb25zdCBuID0gdmFyaW50LmRlY29kZS5ieXRlc1xuXG4gICAgY29uc3QgcCA9IHByb3RvY29scyhjb2RlKVxuXG4gICAgY29uc3Qgc2l6ZSA9IHNpemVGb3JBZGRyKHAsIGJ1Zi5zbGljZShpICsgbikpXG5cbiAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgdHVwbGVzLnB1c2goW2NvZGVdKVxuICAgICAgaSArPSBuXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IGFkZHIgPSBidWYuc2xpY2UoaSArIG4sIGkgKyBuICsgc2l6ZSlcblxuICAgIGkgKz0gKHNpemUgKyBuKVxuXG4gICAgaWYgKGkgPiBidWYubGVuZ3RoKSB7IC8vIGRpZCBub3QgZW5kIF9leGFjdGx5XyBhdCBidWZmZXIubGVuZ3RoXG4gICAgICB0aHJvdyBQYXJzZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MgVWludDhBcnJheTogJyArIHVpbnQ4QXJyYXlUb1N0cmluZyhidWYsICdiYXNlMTYnKSlcbiAgICB9XG5cbiAgICAvLyBvaywgdHVwbGUgc2VlbXMgZ29vZC5cbiAgICB0dXBsZXMucHVzaChbY29kZSwgYWRkcl0pXG4gIH1cblxuICByZXR1cm4gdHVwbGVzXG59XG5cbi8vIFVpbnQ4QXJyYXkgLT4gU3RyaW5nXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcgKGJ1Zikge1xuICBjb25zdCBhID0gYnl0ZXNUb1R1cGxlcyhidWYpXG4gIGNvbnN0IGIgPSB0dXBsZXNUb1N0cmluZ1R1cGxlcyhhKVxuICByZXR1cm4gc3RyaW5nVHVwbGVzVG9TdHJpbmcoYilcbn1cblxuLy8gU3RyaW5nIC0+IFVpbnQ4QXJyYXlcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzIChzdHIpIHtcbiAgc3RyID0gY2xlYW5QYXRoKHN0cilcbiAgY29uc3QgYSA9IHN0cmluZ1RvU3RyaW5nVHVwbGVzKHN0cilcbiAgY29uc3QgYiA9IHN0cmluZ1R1cGxlc1RvVHVwbGVzKGEpXG5cbiAgcmV0dXJuIHR1cGxlc1RvQnl0ZXMoYilcbn1cblxuLy8gU3RyaW5nIC0+IFVpbnQ4QXJyYXlcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0cmluZ1RvQnl0ZXMoc3RyKVxufVxuXG4vLyBVaW50OEFycmF5IC0+IFVpbnQ4QXJyYXlcbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqL1xuZnVuY3Rpb24gZnJvbUJ5dGVzIChidWYpIHtcbiAgY29uc3QgZXJyID0gdmFsaWRhdGVCeXRlcyhidWYpXG4gIGlmIChlcnIpIHRocm93IGVyclxuICByZXR1cm4gVWludDhBcnJheS5mcm9tKGJ1ZikgLy8gY29weVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQnl0ZXMgKGJ1Zikge1xuICB0cnkge1xuICAgIGJ5dGVzVG9UdXBsZXMoYnVmKSAvLyB0cnkgdG8gcGFyc2UuIHdpbGwgdGhyb3cgaWYgYnJlYWtzXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBlcnJcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRCeXRlcyAoYnVmKSB7XG4gIHJldHVybiB2YWxpZGF0ZUJ5dGVzKGJ1ZikgPT09IHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqL1xuZnVuY3Rpb24gY2xlYW5QYXRoIChzdHIpIHtcbiAgcmV0dXJuICcvJyArIHN0ci50cmltKCkuc3BsaXQoJy8nKS5maWx0ZXIoKC8qKiBAdHlwZSB7YW55fSAqLyBhKSA9PiBhKS5qb2luKCcvJylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIFBhcnNlRXJyb3IgKHN0cikge1xuICByZXR1cm4gbmV3IEVycm9yKCdFcnJvciBwYXJzaW5nIGFkZHJlc3M6ICcgKyBzdHIpXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnlbXX0gdHVwXG4gKi9cbmZ1bmN0aW9uIHByb3RvRnJvbVR1cGxlICh0dXApIHtcbiAgY29uc3QgcHJvdG8gPSBwcm90b2NvbHModHVwWzBdKVxuICByZXR1cm4gcHJvdG9cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBpcCA9IHJlcXVpcmUoJy4vaXAnKVxuY29uc3QgcHJvdG9jb2xzID0gcmVxdWlyZSgnLi9wcm90b2NvbHMtdGFibGUnKVxuY29uc3QgeyBDSUQgfSA9IHJlcXVpcmUoJ211bHRpZm9ybWF0cy9jaWQnKVxuY29uc3QgeyBiYXNlMzIgfSA9IHJlcXVpcmUoJ211bHRpZm9ybWF0cy9iYXNlcy9iYXNlMzInKVxuY29uc3QgeyBiYXNlNThidGMgfSA9IHJlcXVpcmUoJ211bHRpZm9ybWF0cy9iYXNlcy9iYXNlNTgnKVxuY29uc3QgRGlnZXN0ID0gcmVxdWlyZSgnbXVsdGlmb3JtYXRzL2hhc2hlcy9kaWdlc3QnKVxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IHsgdG9TdHJpbmc6IHVpbnQ4QXJyYXlUb1N0cmluZyB9ID0gcmVxdWlyZSgndWludDhhcnJheXMvdG8tc3RyaW5nJylcbmNvbnN0IHsgZnJvbVN0cmluZzogdWludDhBcnJheUZyb21TdHJpbmcgfSA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nJylcbmNvbnN0IHsgY29uY2F0OiB1aW50OEFycmF5Q29uY2F0IH0gPSByZXF1aXJlKCd1aW50OGFycmF5cy9jb25jYXQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnZlcnRcblxuLy8gY29udmVydHMgKHNlcmlhbGl6ZXMpIGFkZHJlc3Nlc1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9cbiAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gYVxuICovXG5mdW5jdGlvbiBDb252ZXJ0IChwcm90bywgYSkge1xuICBpZiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gQ29udmVydC50b1N0cmluZyhwcm90bywgYSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQ29udmVydC50b0J5dGVzKHByb3RvLCBhKVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBbY29kZSxVaW50OEFycmF5XSB0byBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHByb3RvXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuQ29udmVydC50b1N0cmluZyA9IGZ1bmN0aW9uIGNvbnZlcnRUb1N0cmluZyAocHJvdG8sIGJ1Zikge1xuICBjb25zdCBwcm90b2NvbCA9IHByb3RvY29scyhwcm90bylcbiAgc3dpdGNoIChwcm90b2NvbC5jb2RlKSB7XG4gICAgY2FzZSA0OiAvLyBpcHY0XG4gICAgY2FzZSA0MTogLy8gaXB2NlxuICAgICAgcmV0dXJuIGJ5dGVzMmlwKGJ1ZilcblxuICAgIGNhc2UgNjogLy8gdGNwXG4gICAgY2FzZSAyNzM6IC8vIHVkcFxuICAgIGNhc2UgMzM6IC8vIGRjY3BcbiAgICBjYXNlIDEzMjogLy8gc2N0cFxuICAgICAgcmV0dXJuIGJ5dGVzMnBvcnQoYnVmKS50b1N0cmluZygpXG5cbiAgICBjYXNlIDUzOiAvLyBkbnNcbiAgICBjYXNlIDU0OiAvLyBkbnM0XG4gICAgY2FzZSA1NTogLy8gZG5zNlxuICAgIGNhc2UgNTY6IC8vIGRuc2FkZHJcbiAgICBjYXNlIDQwMDogLy8gdW5peFxuICAgIGNhc2UgNzc3OiAvLyBtZW1vcnlcbiAgICAgIHJldHVybiBieXRlczJzdHIoYnVmKVxuXG4gICAgY2FzZSA0MjE6IC8vIGlwZnNcbiAgICAgIHJldHVybiBieXRlczJtaChidWYpXG4gICAgY2FzZSA0NDQ6IC8vIG9uaW9uXG4gICAgICByZXR1cm4gYnl0ZXMyb25pb24oYnVmKVxuICAgIGNhc2UgNDQ1OiAvLyBvbmlvbjNcbiAgICAgIHJldHVybiBieXRlczJvbmlvbihidWYpXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1aW50OEFycmF5VG9TdHJpbmcoYnVmLCAnYmFzZTE2JykgLy8gbm8gY2x1ZS4gY29udmVydCB0byBoZXhcbiAgfVxufVxuXG5Db252ZXJ0LnRvQnl0ZXMgPSBmdW5jdGlvbiBjb252ZXJ0VG9CeXRlcyAoLyoqIEB0eXBlIHtzdHJpbmcgfCBudW1iZXIgfSAqLyBwcm90bywgLyoqIEB0eXBlIHtzdHJpbmd9ICovIHN0cikge1xuICBjb25zdCBwcm90b2NvbCA9IHByb3RvY29scyhwcm90bylcbiAgc3dpdGNoIChwcm90b2NvbC5jb2RlKSB7XG4gICAgY2FzZSA0OiAvLyBpcHY0XG4gICAgICByZXR1cm4gaXAyYnl0ZXMoc3RyKVxuICAgIGNhc2UgNDE6IC8vIGlwdjZcbiAgICAgIHJldHVybiBpcDJieXRlcyhzdHIpXG5cbiAgICBjYXNlIDY6IC8vIHRjcFxuICAgIGNhc2UgMjczOiAvLyB1ZHBcbiAgICBjYXNlIDMzOiAvLyBkY2NwXG4gICAgY2FzZSAxMzI6IC8vIHNjdHBcbiAgICAgIHJldHVybiBwb3J0MmJ5dGVzKHBhcnNlSW50KHN0ciwgMTApKVxuXG4gICAgY2FzZSA1MzogLy8gZG5zXG4gICAgY2FzZSA1NDogLy8gZG5zNFxuICAgIGNhc2UgNTU6IC8vIGRuczZcbiAgICBjYXNlIDU2OiAvLyBkbnNhZGRyXG4gICAgY2FzZSA0MDA6IC8vIHVuaXhcbiAgICBjYXNlIDc3NzogLy8gbWVtb3J5XG4gICAgICByZXR1cm4gc3RyMmJ5dGVzKHN0cilcblxuICAgIGNhc2UgNDIxOiAvLyBpcGZzXG4gICAgICByZXR1cm4gbWgyYnl0ZXMoc3RyKVxuICAgIGNhc2UgNDQ0OiAvLyBvbmlvblxuICAgICAgcmV0dXJuIG9uaW9uMmJ5dGVzKHN0cilcbiAgICBjYXNlIDQ0NTogLy8gb25pb24zXG4gICAgICByZXR1cm4gb25pb24zMmJ5dGVzKHN0cilcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKHN0ciwgJ2Jhc2UxNicpIC8vIG5vIGNsdWUuIGNvbnZlcnQgZnJvbSBoZXhcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpcFN0cmluZ1xuICovXG5mdW5jdGlvbiBpcDJieXRlcyAoaXBTdHJpbmcpIHtcbiAgaWYgKCFpcC5pc0lQKGlwU3RyaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpcCBhZGRyZXNzJylcbiAgfVxuICByZXR1cm4gaXAudG9CeXRlcyhpcFN0cmluZylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlwQnVmZlxuICovXG5mdW5jdGlvbiBieXRlczJpcCAoaXBCdWZmKSB7XG4gIGNvbnN0IGlwU3RyaW5nID0gaXAudG9TdHJpbmcoaXBCdWZmKVxuICBpZiAoIWlwU3RyaW5nIHx8ICFpcC5pc0lQKGlwU3RyaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpcCBhZGRyZXNzJylcbiAgfVxuICByZXR1cm4gaXBTdHJpbmdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcG9ydFxuICovXG5mdW5jdGlvbiBwb3J0MmJ5dGVzIChwb3J0KSB7XG4gIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigyKVxuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZilcbiAgdmlldy5zZXRVaW50MTYoMCwgcG9ydClcblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzMnBvcnQgKGJ1Zikge1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIpXG4gIHJldHVybiB2aWV3LmdldFVpbnQxNihidWYuYnl0ZU9mZnNldClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIHN0cjJieXRlcyAoc3RyKSB7XG4gIGNvbnN0IGJ1ZiA9IHVpbnQ4QXJyYXlGcm9tU3RyaW5nKHN0cilcbiAgY29uc3Qgc2l6ZSA9IFVpbnQ4QXJyYXkuZnJvbSh2YXJpbnQuZW5jb2RlKGJ1Zi5sZW5ndGgpKVxuICByZXR1cm4gdWludDhBcnJheUNvbmNhdChbc2l6ZSwgYnVmXSwgc2l6ZS5sZW5ndGggKyBidWYubGVuZ3RoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzMnN0ciAoYnVmKSB7XG4gIGNvbnN0IHNpemUgPSB2YXJpbnQuZGVjb2RlKGJ1ZilcbiAgYnVmID0gYnVmLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG5cbiAgaWYgKGJ1Zi5sZW5ndGggIT09IHNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29uc2lzdGVudCBsZW5ndGhzJylcbiAgfVxuXG4gIHJldHVybiB1aW50OEFycmF5VG9TdHJpbmcoYnVmKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIC0gYmFzZTU4YnRjIHN0cmluZ1xuICovXG5mdW5jdGlvbiBtaDJieXRlcyAoaGFzaCkge1xuICBsZXQgbWhcblxuICBpZiAoaGFzaFswXSA9PT0gJ1EnIHx8IGhhc2hbMF0gPT09ICcxJykge1xuICAgIG1oID0gRGlnZXN0LmRlY29kZShiYXNlNThidGMuZGVjb2RlKGB6JHtoYXNofWApKS5ieXRlc1xuICB9IGVsc2Uge1xuICAgIG1oID0gQ0lELnBhcnNlKGhhc2gpLm11bHRpaGFzaC5ieXRlc1xuICB9XG5cbiAgLy8gdGhlIGFkZHJlc3MgaXMgYSB2YXJpbnQgcHJlZml4ZWQgbXVsdGloYXNoIHN0cmluZyByZXByZXNlbnRhdGlvblxuICBjb25zdCBzaXplID0gVWludDhBcnJheS5mcm9tKHZhcmludC5lbmNvZGUobWgubGVuZ3RoKSlcbiAgcmV0dXJuIHVpbnQ4QXJyYXlDb25jYXQoW3NpemUsIG1oXSwgc2l6ZS5sZW5ndGggKyBtaC5sZW5ndGgpXG59XG5cbi8qKlxuICogQ29udmVydHMgYnl0ZXMgdG8gYmFzNThidGMgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGJhc2U1OGJ0YyBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYnl0ZXMybWggKGJ1Zikge1xuICBjb25zdCBzaXplID0gdmFyaW50LmRlY29kZShidWYpXG4gIGNvbnN0IGFkZHJlc3MgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcblxuICBpZiAoYWRkcmVzcy5sZW5ndGggIT09IHNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29uc2lzdGVudCBsZW5ndGhzJylcbiAgfVxuXG4gIHJldHVybiB1aW50OEFycmF5VG9TdHJpbmcoYWRkcmVzcywgJ2Jhc2U1OGJ0YycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiBvbmlvbjJieXRlcyAoc3RyKSB7XG4gIGNvbnN0IGFkZHIgPSBzdHIuc3BsaXQoJzonKVxuICBpZiAoYWRkci5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBvbmlvbiBhZGRyOiAnICsgYWRkciArICcgZG9lcyBub3QgY29udGFpbiBhIHBvcnQgbnVtYmVyJylcbiAgfVxuICBpZiAoYWRkclswXS5sZW5ndGggIT09IDE2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gcGFyc2Ugb25pb24gYWRkcjogJyArIGFkZHJbMF0gKyAnIG5vdCBhIFRvciBvbmlvbiBhZGRyZXNzLicpXG4gIH1cblxuICAvLyBvbmlvbiBhZGRyZXNzZXMgZG8gbm90IGluY2x1ZGUgdGhlIG11bHRpYmFzZSBwcmVmaXgsIGFkZCBpdCBiZWZvcmUgZGVjb2RpbmdcbiAgY29uc3QgYnVmID0gYmFzZTMyLmRlY29kZSgnYicgKyBhZGRyWzBdKVxuXG4gIC8vIG9uaW9uIHBvcnQgbnVtYmVyXG4gIGNvbnN0IHBvcnQgPSBwYXJzZUludChhZGRyWzFdLCAxMClcbiAgaWYgKHBvcnQgPCAxIHx8IHBvcnQgPiA2NTUzNikge1xuICAgIHRocm93IG5ldyBFcnJvcignUG9ydCBudW1iZXIgaXMgbm90IGluIHJhbmdlKDEsIDY1NTM2KScpXG4gIH1cbiAgY29uc3QgcG9ydEJ1ZiA9IHBvcnQyYnl0ZXMocG9ydClcbiAgcmV0dXJuIHVpbnQ4QXJyYXlDb25jYXQoW2J1ZiwgcG9ydEJ1Zl0sIGJ1Zi5sZW5ndGggKyBwb3J0QnVmLmxlbmd0aClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIG9uaW9uMzJieXRlcyAoc3RyKSB7XG4gIGNvbnN0IGFkZHIgPSBzdHIuc3BsaXQoJzonKVxuICBpZiAoYWRkci5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBvbmlvbiBhZGRyOiAnICsgYWRkciArICcgZG9lcyBub3QgY29udGFpbiBhIHBvcnQgbnVtYmVyJylcbiAgfVxuICBpZiAoYWRkclswXS5sZW5ndGggIT09IDU2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gcGFyc2Ugb25pb24gYWRkcjogJyArIGFkZHJbMF0gKyAnIG5vdCBhIFRvciBvbmlvbjMgYWRkcmVzcy4nKVxuICB9XG4gIC8vIG9uaW9uIGFkZHJlc3NlcyBkbyBub3QgaW5jbHVkZSB0aGUgbXVsdGliYXNlIHByZWZpeCwgYWRkIGl0IGJlZm9yZSBkZWNvZGluZ1xuICBjb25zdCBidWYgPSBiYXNlMzIuZGVjb2RlKCdiJyArIGFkZHJbMF0pXG5cbiAgLy8gb25pb24gcG9ydCBudW1iZXJcbiAgY29uc3QgcG9ydCA9IHBhcnNlSW50KGFkZHJbMV0sIDEwKVxuICBpZiAocG9ydCA8IDEgfHwgcG9ydCA+IDY1NTM2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0IG51bWJlciBpcyBub3QgaW4gcmFuZ2UoMSwgNjU1MzYpJylcbiAgfVxuICBjb25zdCBwb3J0QnVmID0gcG9ydDJieXRlcyhwb3J0KVxuICByZXR1cm4gdWludDhBcnJheUNvbmNhdChbYnVmLCBwb3J0QnVmXSwgYnVmLmxlbmd0aCArIHBvcnRCdWYubGVuZ3RoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzMm9uaW9uIChidWYpIHtcbiAgY29uc3QgYWRkckJ5dGVzID0gYnVmLnNsaWNlKDAsIGJ1Zi5sZW5ndGggLSAyKVxuICBjb25zdCBwb3J0Qnl0ZXMgPSBidWYuc2xpY2UoYnVmLmxlbmd0aCAtIDIpXG4gIGNvbnN0IGFkZHIgPSB1aW50OEFycmF5VG9TdHJpbmcoYWRkckJ5dGVzLCAnYmFzZTMyJylcbiAgY29uc3QgcG9ydCA9IGJ5dGVzMnBvcnQocG9ydEJ5dGVzKVxuICByZXR1cm4gYWRkciArICc6JyArIHBvcnRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb2RlYyA9IHJlcXVpcmUoJy4vY29kZWMnKVxuY29uc3QgcHJvdG9jb2xzID0gcmVxdWlyZSgnLi9wcm90b2NvbHMtdGFibGUnKVxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IHsgQ0lEIH0gPSByZXF1aXJlKCdtdWx0aWZvcm1hdHMvY2lkJylcbmNvbnN0IHsgYmFzZTU4YnRjIH0gPSByZXF1aXJlKCdtdWx0aWZvcm1hdHMvYmFzZXMvYmFzZTU4JylcbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCBpbnNwZWN0ID0gU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKVxuY29uc3QgeyB0b1N0cmluZzogdWludDhBcnJheVRvU3RyaW5nIH0gPSByZXF1aXJlKCd1aW50OGFycmF5cy90by1zdHJpbmcnKVxuY29uc3QgeyBlcXVhbHM6IHVpbnQ4QXJyYXlFcXVhbHMgfSA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2VxdWFscycpXG5cbi8qKlxuICogQHR5cGVkZWYgeyhhZGRyOiBNdWx0aWFkZHIpID0+IFByb21pc2U8c3RyaW5nW10+fSBSZXNvbHZlclxuICogQHR5cGVkZWYge3N0cmluZyB8IE11bHRpYWRkciB8IFVpbnQ4QXJyYXkgfCBudWxsfSBNdWx0aWFkZHJJbnB1dFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcycpLk11bHRpYWRkck9iamVjdH0gTXVsdGlhZGRyT2JqZWN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzJykuUHJvdG9jb2x9IFByb3RvY29sXG4gKi9cblxuLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBSZXNvbHZlcj59ICovXG5jb25zdCByZXNvbHZlcnMgPSBuZXcgTWFwKClcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ0BtdWx0aWZvcm1hdHMvanMtbXVsdGlhZGRyL211bHRpYWRkcicpXG5cbi8qKlxuICogQ3JlYXRlcyBhIFttdWx0aWFkZHJdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGlhZGRyKSBmcm9tXG4gKiBhIFVpbnQ4QXJyYXksIFN0cmluZyBvciBhbm90aGVyIE11bHRpYWRkciBpbnN0YW5jZVxuICogcHVibGljIGtleS5cbiAqXG4gKi9cbmNsYXNzIE11bHRpYWRkciB7XG4gIC8qKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBuZXcgTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpXG4gICAqIC8vIDxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPlxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aWFkZHJJbnB1dH0gW2FkZHJdIC0gSWYgU3RyaW5nIG9yIFVpbnQ4QXJyYXksIG5lZWRzIHRvIGFkaGVyZSB0byB0aGUgYWRkcmVzcyBmb3JtYXQgb2YgYSBbbXVsdGlhZGRyXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYWRkciNzdHJpbmctZm9ybWF0KVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGFkZHIpIHtcbiAgICAvLyBkZWZhdWx0XG4gICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgYWRkciA9ICcnXG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHN5bWJvbFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBzeW1ib2wsIHsgdmFsdWU6IHRydWUgfSlcblxuICAgIGlmIChhZGRyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgLyoqIEB0eXBlIHtVaW50OEFycmF5fSAtIFRoZSByYXcgYnl0ZXMgcmVwcmVzZW50aW5nIHRoaXMgbXVsdGlhZGRyZXNzICovXG4gICAgICB0aGlzLmJ5dGVzID0gY29kZWMuZnJvbUJ5dGVzKGFkZHIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYWRkciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChhZGRyLmxlbmd0aCA+IDAgJiYgYWRkci5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpYWRkciBcIiR7YWRkcn1cIiBtdXN0IHN0YXJ0IHdpdGggYSBcIi9cImApXG4gICAgICB9XG4gICAgICB0aGlzLmJ5dGVzID0gY29kZWMuZnJvbVN0cmluZyhhZGRyKVxuICAgIH0gZWxzZSBpZiAoTXVsdGlhZGRyLmlzTXVsdGlhZGRyKGFkZHIpKSB7IC8vIE11bHRpYWRkclxuICAgICAgdGhpcy5ieXRlcyA9IGNvZGVjLmZyb21CeXRlcyhhZGRyLmJ5dGVzKSAvLyB2YWxpZGF0ZSArIGNvcHkgYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWRkciBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIG9yIGFub3RoZXIgTXVsdGlhZGRyJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBNdWx0aWFkZHIgYXMgYSBTdHJpbmdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogbmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKS50b1N0cmluZygpXG4gICAqIC8vICcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMSdcbiAgICogYGBgXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIGNvZGVjLmJ5dGVzVG9TdHJpbmcodGhpcy5ieXRlcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE11bHRpYWRkciBhcyBhIEpTT04gZW5jb2RlZCBvYmplY3RcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogSlNPTi5zdHJpbmdpZnkobmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKSlcbiAgICogLy8gJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJ1xuICAgKiBgYGBcbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTXVsdGlhZGRyIGFzIGEgY29udmluaWVudCBvcHRpb25zIG9iamVjdCB0byBiZSB1c2VkIHdpdGggbmV0LmNyZWF0ZUNvbm5lY3Rpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogbmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKS50b09wdGlvbnMoKVxuICAgKiAvLyB7IGZhbWlseTogNCwgaG9zdDogJzEyNy4wLjAuMScsIHRyYW5zcG9ydDogJ3RjcCcsIHBvcnQ6IDQwMDEgfVxuICAgKiBgYGBcbiAgICovXG4gIHRvT3B0aW9ucyAoKSB7XG4gICAgLyoqIEB0eXBlIHtNdWx0aWFkZHJPYmplY3R9ICovXG4gICAgY29uc3Qgb3B0cyA9IHt9XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy50b1N0cmluZygpLnNwbGl0KCcvJylcbiAgICBvcHRzLmZhbWlseSA9IHBhcnNlZFsxXSA9PT0gJ2lwNCcgPyA0IDogNlxuICAgIG9wdHMuaG9zdCA9IHBhcnNlZFsyXVxuICAgIG9wdHMudHJhbnNwb3J0ID0gcGFyc2VkWzNdXG4gICAgb3B0cy5wb3J0ID0gcGFyc2VJbnQocGFyc2VkWzRdKVxuICAgIHJldHVybiBvcHRzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvdG9jb2xzIHRoZSBNdWx0aWFkZHIgaXMgZGVmaW5lZCB3aXRoLCBhcyBhbiBhcnJheSBvZiBvYmplY3RzLCBpblxuICAgKiBsZWZ0LXRvLXJpZ2h0IG9yZGVyLiBFYWNoIG9iamVjdCBjb250YWlucyB0aGUgcHJvdG9jb2wgY29kZSwgcHJvdG9jb2wgbmFtZSxcbiAgICogYW5kIHRoZSBzaXplIG9mIGl0cyBhZGRyZXNzIHNwYWNlIGluIGJpdHMuXG4gICAqIFtTZWUgbGlzdCBvZiBwcm90b2NvbHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGlhZGRyL2Jsb2IvbWFzdGVyL3Byb3RvY29scy5jc3YpXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIG5ldyBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJykucHJvdG9zKClcbiAgICogLy8gWyB7IGNvZGU6IDQsIHNpemU6IDMyLCBuYW1lOiAnaXA0JyB9LFxuICAgKiAvLyAgIHsgY29kZTogNiwgc2l6ZTogMTYsIG5hbWU6ICd0Y3AnIH0gXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMge1Byb3RvY29sW119IHByb3RvY29scyAtIEFsbCB0aGUgcHJvdG9jb2xzIHRoZSBhZGRyZXNzIGlzIGNvbXBvc2VkIG9mXG4gICAqL1xuICBwcm90b3MgKCkge1xuICAgIHJldHVybiB0aGlzLnByb3RvQ29kZXMoKS5tYXAoY29kZSA9PiBPYmplY3QuYXNzaWduKHt9LCBwcm90b2NvbHMoY29kZSkpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvZGVzIG9mIHRoZSBwcm90b2NvbHMgaW4gbGVmdC10by1yaWdodCBvcmRlci5cbiAgICogW1NlZSBsaXN0IG9mIHByb3RvY29sc10oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWFkZHIvYmxvYi9tYXN0ZXIvcHJvdG9jb2xzLmNzdilcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpLnByb3RvQ29kZXMoKVxuICAgKiAvLyBbIDQsIDYgXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcltdfSBwcm90b2NvbCBjb2Rlc1xuICAgKi9cbiAgcHJvdG9Db2RlcyAoKSB7XG4gICAgY29uc3QgY29kZXMgPSBbXVxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuYnl0ZXNcbiAgICBsZXQgaSA9IDBcbiAgICB3aGlsZSAoaSA8IGJ1Zi5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB2YXJpbnQuZGVjb2RlKGJ1ZiwgaSlcbiAgICAgIGNvbnN0IG4gPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG5cbiAgICAgIGNvbnN0IHAgPSBwcm90b2NvbHMoY29kZSlcbiAgICAgIGNvbnN0IHNpemUgPSBjb2RlYy5zaXplRm9yQWRkcihwLCBidWYuc2xpY2UoaSArIG4pKVxuXG4gICAgICBpICs9IChzaXplICsgbilcbiAgICAgIGNvZGVzLnB1c2goY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gY29kZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lcyBvZiB0aGUgcHJvdG9jb2xzIGluIGxlZnQtdG8tcmlnaHQgb3JkZXIuXG4gICAqIFtTZWUgbGlzdCBvZiBwcm90b2NvbHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGlhZGRyL2Jsb2IvbWFzdGVyL3Byb3RvY29scy5jc3YpXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIG5ldyBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJykucHJvdG9OYW1lcygpXG4gICAqIC8vIFsgJ2lwNCcsICd0Y3AnIF1cbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gcHJvdG9jb2wgbmFtZXNcbiAgICovXG4gIHByb3RvTmFtZXMgKCkge1xuICAgIHJldHVybiB0aGlzLnByb3RvcygpLm1hcChwcm90byA9PiBwcm90by5uYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB0dXBsZSBvZiBwYXJ0c1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBuZXcgTXVsdGlhZGRyKFwiL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDFcIikudHVwbGVzKClcbiAgICogLy8gWyBbIDQsIDxCdWZmZXIgN2YgMDAgMDAgMDE+IF0sIFsgNiwgPEJ1ZmZlciAwZiBhMT4gXSBdXG4gICAqIGBgYFxuICAgKi9cbiAgdHVwbGVzICgpIHtcbiAgICByZXR1cm4gY29kZWMuYnl0ZXNUb1R1cGxlcyh0aGlzLmJ5dGVzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB0dXBsZSBvZiBzdHJpbmcvbnVtYmVyIHBhcnRzXG4gICAqIC0gdHVwbGVzW11bMF0gPSBjb2RlIG9mIHByb3RvY29sXG4gICAqIC0gdHVwbGVzW11bMV0gPSBjb250ZW50cyBvZiBhZGRyZXNzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIG5ldyBNdWx0aWFkZHIoXCIvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMVwiKS5zdHJpbmdUdXBsZXMoKVxuICAgKiAvLyBbIFsgNCwgJzEyNy4wLjAuMScgXSwgWyA2LCAnNDAwMScgXSBdXG4gICAqIGBgYFxuICAgKi9cbiAgc3RyaW5nVHVwbGVzICgpIHtcbiAgICBjb25zdCB0ID0gY29kZWMuYnl0ZXNUb1R1cGxlcyh0aGlzLmJ5dGVzKVxuICAgIHJldHVybiBjb2RlYy50dXBsZXNUb1N0cmluZ1R1cGxlcyh0KVxuICB9XG5cbiAgLyoqXG4gICAqIEVuY2Fwc3VsYXRlcyBhIE11bHRpYWRkciBpbiBhbm90aGVyIE11bHRpYWRkclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBtaDEgPSBuZXcgTXVsdGlhZGRyKCcvaXA0LzguOC44LjgvdGNwLzEwODAnKVxuICAgKiAvLyA8TXVsdGlhZGRyIDA0MDgwODA4MDgwNjA0MzggLSAvaXA0LzguOC44LjgvdGNwLzEwODA+XG4gICAqXG4gICAqIGNvbnN0IG1oMiA9IG5ldyBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJylcbiAgICogLy8gPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gICAqXG4gICAqIGNvbnN0IG1oMyA9IG1oMS5lbmNhcHN1bGF0ZShtaDIpXG4gICAqIC8vIDxNdWx0aWFkZHIgMDQwODA4MDgwODA2MDQzODA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzguOC44LjgvdGNwLzEwODAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT5cbiAgICpcbiAgICogbWgzLnRvU3RyaW5nKClcbiAgICogLy8gJy9pcDQvOC44LjguOC90Y3AvMTA4MC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJ1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aWFkZHJJbnB1dH0gYWRkciAtIE11bHRpYWRkciB0byBhZGQgaW50byB0aGlzIE11bHRpYWRkclxuICAgKi9cbiAgZW5jYXBzdWxhdGUgKGFkZHIpIHtcbiAgICBhZGRyID0gbmV3IE11bHRpYWRkcihhZGRyKVxuICAgIHJldHVybiBuZXcgTXVsdGlhZGRyKHRoaXMudG9TdHJpbmcoKSArIGFkZHIudG9TdHJpbmcoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNhcHN1bGF0ZXMgYSBNdWx0aWFkZHIgZnJvbSBhbm90aGVyIE11bHRpYWRkclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBtaDEgPSBuZXcgTXVsdGlhZGRyKCcvaXA0LzguOC44LjgvdGNwLzEwODAnKVxuICAgKiAvLyA8TXVsdGlhZGRyIDA0MDgwODA4MDgwNjA0MzggLSAvaXA0LzguOC44LjgvdGNwLzEwODA+XG4gICAqXG4gICAqIGNvbnN0IG1oMiA9IG5ldyBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJylcbiAgICogLy8gPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gICAqXG4gICAqIGNvbnN0IG1oMyA9IG1oMS5lbmNhcHN1bGF0ZShtaDIpXG4gICAqIC8vIDxNdWx0aWFkZHIgMDQwODA4MDgwODA2MDQzODA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzguOC44LjgvdGNwLzEwODAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT5cbiAgICpcbiAgICogbWgzLmRlY2Fwc3VsYXRlKG1oMikudG9TdHJpbmcoKVxuICAgKiAvLyAnL2lwNC84LjguOC44L3RjcC8xMDgwJ1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aWFkZHIgfCBzdHJpbmd9IGFkZHIgLSBNdWx0aWFkZHIgdG8gcmVtb3ZlIGZyb20gdGhpcyBNdWx0aWFkZHJcbiAgICogQHJldHVybnMge011bHRpYWRkcn1cbiAgICovXG4gIGRlY2Fwc3VsYXRlIChhZGRyKSB7XG4gICAgY29uc3QgYWRkclN0cmluZyA9IGFkZHIudG9TdHJpbmcoKVxuICAgIGNvbnN0IHMgPSB0aGlzLnRvU3RyaW5nKClcbiAgICBjb25zdCBpID0gcy5sYXN0SW5kZXhPZihhZGRyU3RyaW5nKVxuICAgIGlmIChpIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRyZXNzICcgKyB0aGlzICsgJyBkb2VzIG5vdCBjb250YWluIHN1YmFkZHJlc3M6ICcgKyBhZGRyKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IE11bHRpYWRkcihzLnNsaWNlKDAsIGkpKVxuICB9XG5cbiAgLyoqXG4gICAqIEEgbW9yZSByZWxpYWJsZSB2ZXJzaW9uIG9mIGBkZWNhcHN1bGF0ZWAgaWYgeW91IGFyZSB0YXJnZXRpbmcgYVxuICAgKiBzcGVjaWZpYyBjb2RlLCBzdWNoIGFzIDQyMSAodGhlIGBwMnBgIHByb3RvY29sIGNvZGUpLiBUaGUgbGFzdCBpbmRleCBvZiB0aGUgY29kZVxuICAgKiB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgYE11bHRpYWRkcmAsIGFuZCBhIG5ldyBpbnN0YW5jZSB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBJZiB0aGUgY29kZSBpcyBub3QgcHJlc2VudCwgdGhlIG9yaWdpbmFsIGBNdWx0aWFkZHJgIGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBhZGRyID0gbmV3IE11bHRpYWRkcignL2lwNC8wLjAuMC4wL3RjcC84MDgwL3AycC9RbWNncHN5V2dIOFk4YWpKejFDdTcyS25TNXVvMkFhMkxwelU3a2luU3VwTktDJylcbiAgICogLy8gPE11bHRpYWRkciAwNDAwLi4uIC0gL2lwNC8wLjAuMC4wL3RjcC84MDgwL3AycC9RbWNncHN5V2dIOFk4YWpKejFDdTcyS25TNXVvMkFhMkxwelU3a2luU3VwTktDPlxuICAgKlxuICAgKiBhZGRyLmRlY2Fwc3VsYXRlQ29kZSg0MjEpLnRvU3RyaW5nKClcbiAgICogLy8gJy9pcDQvMC4wLjAuMC90Y3AvODA4MCdcbiAgICpcbiAgICogbmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzgwODAnKS5kZWNhcHN1bGF0ZUNvZGUoNDIxKS50b1N0cmluZygpXG4gICAqIC8vICcvaXA0LzEyNy4wLjAuMS90Y3AvODA4MCdcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIC0gVGhlIGNvZGUgb2YgdGhlIHByb3RvY29sIHRvIGRlY2Fwc3VsYXRlIGZyb20gdGhpcyBNdWx0aWFkZHJcbiAgICogQHJldHVybnMge011bHRpYWRkcn1cbiAgICovXG4gIGRlY2Fwc3VsYXRlQ29kZSAoY29kZSkge1xuICAgIGNvbnN0IHR1cGxlcyA9IHRoaXMudHVwbGVzKClcbiAgICBmb3IgKGxldCBpID0gdHVwbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodHVwbGVzW2ldWzBdID09PSBjb2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlhZGRyKGNvZGVjLnR1cGxlc1RvQnl0ZXModHVwbGVzLnNsaWNlKDAsIGkpKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBwZWVySWQgaWYgdGhlIG11bHRpYWRkciBjb250YWlucyBvbmVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgbWgxID0gbmV3IE11bHRpYWRkcignL2lwNC84LjguOC44L3RjcC8xMDgwL2lwZnMvUW1WYWxpZEJhc2U1OHN0cmluZycpXG4gICAqIC8vIDxNdWx0aWFkZHIgMDQwODA4MDgwODA2MDQzOCAtIC9pcDQvOC44LjguOC90Y3AvMTA4MC9pcGZzL1FtVmFsaWRCYXNlNThzdHJpbmc+XG4gICAqXG4gICAqIC8vIHNob3VsZCByZXR1cm4gUW1WYWxpZEJhc2U1OHN0cmluZyBvciBudWxsIGlmIHRoZSBpZCBpcyBtaXNzaW5nIG9yIGludmFsaWRcbiAgICogY29uc3QgcGVlcklkID0gbWgxLmdldFBlZXJJZCgpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH0gcGVlcklkIC0gVGhlIGlkIG9mIHRoZSBwZWVyIG9yIG51bGwgaWYgaW52YWxpZCBvciBtaXNzaW5nIGZyb20gdGhlIG1hXG4gICAqL1xuICBnZXRQZWVySWQgKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0dXBsZXMgPSB0aGlzLnN0cmluZ1R1cGxlcygpLmZpbHRlcigodHVwbGUpID0+IHtcbiAgICAgICAgaWYgKHR1cGxlWzBdID09PSBwcm90b2NvbHMubmFtZXMuaXBmcy5jb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0pXG5cbiAgICAgIC8vIEdldCB0aGUgbGFzdCBpcGZzIHR1cGxlIFsnaXBmcycsICdwZWVyaWQgc3RyaW5nJ11cbiAgICAgIGNvbnN0IHR1cGxlID0gdHVwbGVzLnBvcCgpXG4gICAgICBpZiAodHVwbGUgJiYgdHVwbGVbMV0pIHtcbiAgICAgICAgY29uc3QgcGVlcklkU3RyID0gdHVwbGVbMV1cblxuICAgICAgICAvLyBwZWVyIGlkIGlzIGJhc2U1OGJ0YyBlbmNvZGVkIHN0cmluZyBidXQgbm90IG11bHRpYmFzZSBlbmNvZGVkIHNvIGFkZCB0aGUgYHpgXG4gICAgICAgIC8vIHByZWZpeCBzbyB3ZSBjYW4gdmFsaWRhdGUgdGhhdCBpdCBpcyBjb3JyZWN0bHkgZW5jb2RlZFxuICAgICAgICBpZiAocGVlcklkU3RyWzBdID09PSAnUScgfHwgcGVlcklkU3RyWzBdID09PSAnMScpIHtcbiAgICAgICAgICByZXR1cm4gdWludDhBcnJheVRvU3RyaW5nKGJhc2U1OGJ0Yy5kZWNvZGUoYHoke3BlZXJJZFN0cn1gKSwgJ2Jhc2U1OGJ0YycpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgdG8gcGFyc2UgcGVlciBpZCBhcyBDSURcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb1N0cmluZyhDSUQucGFyc2UocGVlcklkU3RyKS5tdWx0aWhhc2guYnl0ZXMsICdiYXNlNThidGMnKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIHBhdGggaWYgdGhlIG11bHRpYWRkciBjb250YWlucyBvbmVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgbWgxID0gbmV3IE11bHRpYWRkcignL2lwNC84LjguOC44L3RjcC8xMDgwL3VuaXgvdG1wL3AycC5zb2NrJylcbiAgICogLy8gPE11bHRpYWRkciAwNDA4MDgwODA4MDYwNDM4IC0gL2lwNC84LjguOC44L3RjcC8xMDgwL3VuaXgvdG1wL3AycC5zb2NrPlxuICAgKlxuICAgKiAvLyBzaG91bGQgcmV0dXJuIHV0Zjggc3RyaW5nIG9yIG51bGwgaWYgdGhlIGlkIGlzIG1pc3Npbmcgb3IgaW52YWxpZFxuICAgKiBjb25zdCBwYXRoID0gbWgxLmdldFBhdGgoKVxuICAgKiBgYGBqc1xuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH0gcGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBtdWx0aWFkZHIsIG9yIG51bGwgaWYgbm8gcGF0aCBwcm90b2NvbCBpcyBwcmVzZW50XG4gICAqL1xuICBnZXRQYXRoICgpIHtcbiAgICBsZXQgcGF0aCA9IG51bGxcbiAgICB0cnkge1xuICAgICAgcGF0aCA9IHRoaXMuc3RyaW5nVHVwbGVzKCkuZmlsdGVyKCh0dXBsZSkgPT4ge1xuICAgICAgICBjb25zdCBwcm90byA9IHByb3RvY29scyh0dXBsZVswXSlcbiAgICAgICAgaWYgKHByb3RvLnBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSlbMF1bMV1cblxuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHBhdGggPSBudWxsXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcGF0aCA9IG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdHdvIE11bHRpYWRkcnMgYXJlIHRoZSBzYW1lXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IG1oMSA9IG5ldyBNdWx0aWFkZHIoJy9pcDQvOC44LjguOC90Y3AvMTA4MCcpXG4gICAqIC8vIDxNdWx0aWFkZHIgMDQwODA4MDgwODA2MDQzOCAtIC9pcDQvOC44LjguOC90Y3AvMTA4MD5cbiAgICpcbiAgICogY29uc3QgbWgyID0gbmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKVxuICAgKiAvLyA8TXVsdGlhZGRyIDA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT5cbiAgICpcbiAgICogbWgxLmVxdWFscyhtaDEpXG4gICAqIC8vIHRydWVcbiAgICpcbiAgICogbWgxLmVxdWFscyhtaDIpXG4gICAqIC8vIGZhbHNlXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpYWRkcn0gYWRkclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyAoYWRkcikge1xuICAgIHJldHVybiB1aW50OEFycmF5RXF1YWxzKHRoaXMuYnl0ZXMsIGFkZHIuYnl0ZXMpXG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSBtdWx0aWFkZHIgaWYgY29udGFpbmluZyByZXNvbHZhYmxlIGhvc3RuYW1lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBNdWx0aWFkZHIucmVzb2x2ZXJzLnNldCgnZG5zYWRkcicsIHJlc29sdmVyRnVuY3Rpb24pXG4gICAqIGNvbnN0IG1oMSA9IG5ldyBNdWx0aWFkZHIoJy9kbnNhZGRyL2Jvb3RzdHJhcC5saWJwMnAuaW8vcDJwL1FtYkxIQW5Nb0pQV1NDUjVaaHR4NkJISlg5S2lLTk42dHB2YlVjcWFuajc1TmInKVxuICAgKiBjb25zdCByZXNvbHZlZE11bHRpYWRkcnMgPSBhd2FpdCBtaDEucmVzb2x2ZSgpXG4gICAqIC8vIFtcbiAgICogLy8gICA8TXVsdGlhZGRyIDA0OTM0YjUzNTMwNjBmYTFhNTAzMjIxMjIwYzEwZjkzMTlkYWMzNWMyNzBhNmI3NGNkNjQ0Y2IzYWNmYzFmNmVmYzhjODIxZjhlYjI4MjU5OWZkMTgxNGY2NCAtIC9pcDQvMTQ3Ljc1LjgzLjgzL3RjcC80MDAxL3AycC9RbWJMSEFuTW9KUFdTQ1I1Wmh0eDZCSEpYOUtpS05ONnRwdmJVY3Fhbmo3NU5iPixcbiAgICogLy8gICA8TXVsdGlhZGRyIDA0OTM0YjUzNTMwNjAxYmJkZTAzYTUwMzIyMTIyMGMxMGY5MzE5ZGFjMzVjMjcwYTZiNzRjZDY0NGNiM2FjZmMxZjZlZmM4YzgyMWY4ZWIyODI1OTlmZDE4MTRmNjQgLSAvaXA0LzE0Ny43NS44My44My90Y3AvNDQzL3dzcy9wMnAvUW1iTEhBbk1vSlBXU0NSNVpodHg2QkhKWDlLaUtOTjZ0cHZiVWNxYW5qNzVOYj4sXG4gICAqIC8vICAgPE11bHRpYWRkciAwNDkzNGI1MzUzOTEwMjBmYTFjYzAzYTUwMzIyMTIyMGMxMGY5MzE5ZGFjMzVjMjcwYTZiNzRjZDY0NGNiM2FjZmMxZjZlZmM4YzgyMWY4ZWIyODI1OTlmZDE4MTRmNjQgLSAvaXA0LzE0Ny43NS44My44My91ZHAvNDAwMS9xdWljL3AycC9RbWJMSEFuTW9KUFdTQ1I1Wmh0eDZCSEpYOUtpS05ONnRwdmJVY3Fhbmo3NU5iPlxuICAgKiAvLyBdXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxNdWx0aWFkZHI+Pn1cbiAgICovXG4gIGFzeW5jIHJlc29sdmUgKCkge1xuICAgIGNvbnN0IHJlc29sdmFibGVQcm90byA9IHRoaXMucHJvdG9zKCkuZmluZCgocCkgPT4gcC5yZXNvbHZhYmxlKVxuXG4gICAgLy8gTXVsdGlhZGRyIGlzIG5vdCByZXNvbHZhYmxlP1xuICAgIGlmICghcmVzb2x2YWJsZVByb3RvKSB7XG4gICAgICByZXR1cm4gW3RoaXNdXG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x2ZXIgPSByZXNvbHZlcnMuZ2V0KHJlc29sdmFibGVQcm90by5uYW1lKVxuICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGBubyBhdmFpbGFibGUgcmVzb2x2ZXIgZm9yICR7cmVzb2x2YWJsZVByb3RvLm5hbWV9YCksICdFUlJfTk9fQVZBSUxBQkxFX1JFU09MVkVSJylcbiAgICB9XG5cbiAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCByZXNvbHZlcih0aGlzKVxuICAgIHJldHVybiBhZGRyZXNzZXMubWFwKChhKSA9PiBuZXcgTXVsdGlhZGRyKGEpKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBNdWx0aWFkZHJzIG5vZGUtZnJpZW5kbHkgYWRkcmVzcyBvYmplY3QuIE5vdGUgdGhhdCBwcm90b2NvbCBpbmZvcm1hdGlvblxuICAgKiBpcyBsZWZ0IG91dDogaW4gTm9kZSAoYW5kIG1vc3QgbmV0d29yayBzeXN0ZW1zKSB0aGUgcHJvdG9jb2wgaXMgdW5rbm93YWJsZVxuICAgKiBnaXZlbiBvbmx5IHRoZSBhZGRyZXNzLlxuICAgKlxuICAgKiBIYXMgdG8gYmUgYSBUaGluV2Fpc3QgQWRkcmVzcywgb3RoZXJ3aXNlIHRocm93cyBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBuZXcgTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpLm5vZGVBZGRyZXNzKClcbiAgICogLy8ge2ZhbWlseTogNCwgYWRkcmVzczogJzEyNy4wLjAuMScsIHBvcnQ6IDQwMDF9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyB7e2ZhbWlseTogNCB8IDYsIGFkZHJlc3M6IHN0cmluZywgcG9ydDogbnVtYmVyfX1cbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93cyBlcnJvciBpZiBNdWx0aWFkZHIgaXMgbm90IGEgVGhpbiBXYWlzdCBhZGRyZXNzXG4gICAqL1xuICBub2RlQWRkcmVzcyAoKSB7XG4gICAgY29uc3QgY29kZXMgPSB0aGlzLnByb3RvQ29kZXMoKVxuICAgIGNvbnN0IG5hbWVzID0gdGhpcy5wcm90b05hbWVzKClcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdCgnLycpLnNsaWNlKDEpXG5cbiAgICBpZiAocGFydHMubGVuZ3RoIDwgNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWFkZHIgbXVzdCBoYXZlIGEgdmFsaWQgZm9ybWF0OiBcIi97aXA0LCBpcDYsIGRuczQsIGRuczZ9L3thZGRyZXNzfS97dGNwLCB1ZHB9L3twb3J0fVwiLicpXG4gICAgfSBlbHNlIGlmIChjb2Rlc1swXSAhPT0gNCAmJiBjb2Rlc1swXSAhPT0gNDEgJiYgY29kZXNbMF0gIT09IDU0ICYmIGNvZGVzWzBdICE9PSA1NSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBwcm90b2NvbCB3aXRoIG5hbWU6IFwiJyR7bmFtZXNbMF19J1wiLiBNdXN0IGhhdmUgYSB2YWxpZCBmYW1pbHkgbmFtZTogXCJ7aXA0LCBpcDYsIGRuczQsIGRuczZ9XCIuYClcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzJdICE9PSAndGNwJyAmJiBwYXJ0c1syXSAhPT0gJ3VkcCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gcHJvdG9jb2wgd2l0aCBuYW1lOiBcIicke25hbWVzWzFdfSdcIi4gTXVzdCBoYXZlIGEgdmFsaWQgdHJhbnNwb3J0IHByb3RvY29sOiBcInt0Y3AsIHVkcH1cIi5gKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmYW1pbHk6IChjb2Rlc1swXSA9PT0gNDEgfHwgY29kZXNbMF0gPT09IDU1KSA/IDYgOiA0LFxuICAgICAgYWRkcmVzczogcGFydHNbMV0sXG4gICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1szXSkgLy8gdGNwIG9yIHVkcCBwb3J0XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgYSBNdWx0aWFkZHIgaXMgYSBUaGluIFdhaXN0IGFkZHJlc3Mgb3Igbm90LlxuICAgKlxuICAgKiBUaGluIFdhaXN0IGlzIGlmIGEgTXVsdGlhZGRyIGFkaGVyZXMgdG8gdGhlIHN0YW5kYXJkIGNvbWJpbmF0aW9uIG9mOlxuICAgKlxuICAgKiBge0lQdjQsIElQdjZ9L3tUQ1AsIFVEUH1gXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IG1oMSA9IG5ldyBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJylcbiAgICogLy8gPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gICAqIGNvbnN0IG1oMiA9IG5ldyBNdWx0aWFkZHIoJy9pcDQvMTkyLjE2OC4yLjEvdGNwLzUwMDEnKVxuICAgKiAvLyA8TXVsdGlhZGRyIDA0YzBhODAyMDEwNjEzODkgLSAvaXA0LzE5Mi4xNjguMi4xL3RjcC81MDAxPlxuICAgKiBjb25zdCBtaDMgPSBtaDEuZW5jYXBzdWxhdGUobWgyKVxuICAgKiAvLyA8TXVsdGlhZGRyIDA0N2YwMDAwMDEwNjBmYTEwNGMwYTgwMjAxMDYxMzg5IC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEvaXA0LzE5Mi4xNjguMi4xL3RjcC81MDAxPlxuICAgKiBjb25zdCBtaDQgPSBuZXcgTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvMjAwMC93c3MvcDJwLXdlYnJ0Yy1zdGFyL3AycC9RbWNncHN5V2dIOFk4YWpKejFDdTcyS25TNXVvMkFhMkxwelU3a2luU29vbzJhJylcbiAgICogLy8gPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwN2QwZGUwMzkzMDJhNTAzMjIxMjIwZDUyZWJiODlkODViMDJhMjg0OTQ4MjAzYTYyZmYyODM4OWM1N2M5ZjQyYmVlYzRlYzIwZGI3NmE2NDgzNTg0MyAtIC9pcDQvMTI3LjAuMC4xL3RjcC8yMDAwL3dzcy9wMnAtd2VicnRjLXN0YXIvcDJwL1FtY2dwc3lXZ0g4WThhakp6MUN1NzJLblM1dW8yQWEyTHB6VTdraW5Tb29vMmE+XG4gICAqIG1oMS5pc1RoaW5XYWlzdEFkZHJlc3MoKVxuICAgKiAvLyB0cnVlXG4gICAqIG1oMi5pc1RoaW5XYWlzdEFkZHJlc3MoKVxuICAgKiAvLyB0cnVlXG4gICAqIG1oMy5pc1RoaW5XYWlzdEFkZHJlc3MoKVxuICAgKiAvLyBmYWxzZVxuICAgKiBtaDQuaXNUaGluV2Fpc3RBZGRyZXNzKClcbiAgICogLy8gZmFsc2VcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGlhZGRyfSBbYWRkcl0gLSBEZWZhdWx0cyB0byB1c2luZyBgdGhpc2AgaW5zdGFuY2VcbiAgICovXG4gIGlzVGhpbldhaXN0QWRkcmVzcyAoYWRkcikge1xuICAgIGNvbnN0IHByb3RvcyA9IChhZGRyIHx8IHRoaXMpLnByb3RvcygpXG5cbiAgICBpZiAocHJvdG9zLmxlbmd0aCAhPT0gMikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHByb3Rvc1swXS5jb2RlICE9PSA0ICYmIHByb3Rvc1swXS5jb2RlICE9PSA0MSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChwcm90b3NbMV0uY29kZSAhPT0gNiAmJiBwcm90b3NbMV0uY29kZSAhPT0gMjczKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTXVsdGlhZGRyIGZyb20gYSBub2RlLWZyaWVuZGx5IGFkZHJlc3Mgb2JqZWN0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIE11bHRpYWRkci5mcm9tTm9kZUFkZHJlc3Moe2FkZHJlc3M6ICcxMjcuMC4wLjEnLCBwb3J0OiAnNDAwMSd9LCAndGNwJylcbiAgICogLy8gPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3tmYW1pbHk6IDQgfCA2LCBhZGRyZXNzOiBzdHJpbmcsIHBvcnQ6IG51bWJlcn19IGFkZHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zcG9ydFxuICAgKi9cbiAgc3RhdGljIGZyb21Ob2RlQWRkcmVzcyAoYWRkciwgdHJhbnNwb3J0KSB7XG4gICAgaWYgKCFhZGRyKSB7IHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMgbm9kZSBhZGRyZXNzIG9iamVjdCcpIH1cbiAgICBpZiAoIXRyYW5zcG9ydCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIHRyYW5zcG9ydCBwcm90b2NvbCcpIH1cbiAgICBsZXQgaXBcbiAgICBzd2l0Y2ggKGFkZHIuZmFtaWx5KSB7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGlwID0gJ2lwNCdcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgaXAgPSAnaXA2J1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgYWRkciBmYW1pbHkuIEdvdCAnJHthZGRyLmZhbWlseX0nIGluc3RlYWQgb2YgNCBvciA2YClcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNdWx0aWFkZHIoJy8nICsgW2lwLCBhZGRyLmFkZHJlc3MsIHRyYW5zcG9ydCwgYWRkci5wb3J0XS5qb2luKCcvJykpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiBzb21ldGhpbmcgaXMgYSBNdWx0aWFkZHIgdGhhdCBpcyBhIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aWFkZHJ9IGFkZHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IGlzTmFtZVxuICAgKi9cbiAgc3RhdGljIGlzTmFtZSAoYWRkcikge1xuICAgIGlmICghTXVsdGlhZGRyLmlzTXVsdGlhZGRyKGFkZHIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBpZiBhIHBhcnQgb2YgdGhlIG11bHRpYWRkciBpcyByZXNvbHZhYmxlLCB0aGVuIHJldHVybiB0cnVlXG4gICAgcmV0dXJuIGFkZHIucHJvdG9zKCkuc29tZSgocHJvdG8pID0+IHByb3RvLnJlc29sdmFibGUpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgb2JqZWN0IGlzIGEgQ0lEIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7dmFsdWUgaXMgTXVsdGlhZGRyfVxuICAgKi9cbiAgc3RhdGljIGlzTXVsdGlhZGRyICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE11bHRpYWRkciB8fCBCb29sZWFuKHZhbHVlICYmIHZhbHVlW3N5bWJvbF0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBNdWx0aWFkZHIgYXMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcuXG4gICAqIEZvciBwb3N0IE5vZGUuanMgdjEwLjAuMC5cbiAgICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9kZXByZWNhdGlvbnMuaHRtbCNkZXByZWNhdGlvbnNfZGVwMDA3OV9jdXN0b21faW5zcGVjdGlvbl9mdW5jdGlvbl9vbl9vYmplY3RzX3ZpYV9pbnNwZWN0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnNvbGUubG9nKG5ldyBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJykpXG4gICAqIC8vICc8TXVsdGlhZGRyIDA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT4nXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgW2luc3BlY3RdICgpIHtcbiAgICByZXR1cm4gJzxNdWx0aWFkZHIgJyArXG4gICAgdWludDhBcnJheVRvU3RyaW5nKHRoaXMuYnl0ZXMsICdiYXNlMTYnKSArICcgLSAnICtcbiAgICBjb2RlYy5ieXRlc1RvU3RyaW5nKHRoaXMuYnl0ZXMpICsgJz4nXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBNdWx0aWFkZHIgYXMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcuXG4gICAqIEZhbGxiYWNrIGZvciBwcmUgTm9kZS5qcyB2MTAuMC4wLlxuICAgKiBodHRwczovL25vZGVqcy5vcmcvYXBpL2RlcHJlY2F0aW9ucy5odG1sI2RlcHJlY2F0aW9uc19kZXAwMDc5X2N1c3RvbV9pbnNwZWN0aW9uX2Z1bmN0aW9uX29uX29iamVjdHNfdmlhX2luc3BlY3RcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogbmV3IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKS5pbnNwZWN0KClcbiAgICogLy8gJzxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPidcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBpbnNwZWN0ICgpIHtcbiAgICByZXR1cm4gJzxNdWx0aWFkZHIgJyArXG4gICAgICB1aW50OEFycmF5VG9TdHJpbmcodGhpcy5ieXRlcywgJ2Jhc2UxNicpICsgJyAtICcgK1xuICAgICAgY29kZWMuYnl0ZXNUb1N0cmluZyh0aGlzLmJ5dGVzKSArICc+J1xuICB9XG59XG5cbi8qKlxuICogT2JqZWN0IGNvbnRhaW5pbmcgdGFibGUsIG5hbWVzIGFuZCBjb2RlcyBvZiBhbGwgc3VwcG9ydGVkIHByb3RvY29scy5cbiAqIFRvIGdldCB0aGUgcHJvdG9jb2wgdmFsdWVzIGZyb20gYSBNdWx0aWFkZHIsIHlvdSBjYW4gdXNlXG4gKiBbYC5wcm90b3MoKWBdKCNtdWx0aWFkZHJwcm90b3MpLFxuICogW2AucHJvdG9Db2RlcygpYF0oI211bHRpYWRkcnByb3RvY29kZXMpIG9yXG4gKiBbYC5wcm90b05hbWVzKClgXSgjbXVsdGlhZGRycHJvdG9uYW1lcylcbiAqXG4gKiBAcmV0dXJucyB7e3RhYmxlOiBBcnJheSwgbmFtZXM6IE9iamVjdCwgY29kZXM6IE9iamVjdH19XG4gKi9cbk11bHRpYWRkci5wcm90b2NvbHMgPSBwcm90b2NvbHNcblxuTXVsdGlhZGRyLnJlc29sdmVycyA9IHJlc29sdmVyc1xuXG4vKipcbiAqIFN0YXRpYyBmYWN0b3J5XG4gKlxuICogQHBhcmFtIHtNdWx0aWFkZHJJbnB1dH0gYWRkclxuICovXG5mdW5jdGlvbiBtdWx0aWFkZHIgKGFkZHIpIHtcbiAgcmV0dXJuIG5ldyBNdWx0aWFkZHIoYWRkcilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IE11bHRpYWRkciwgbXVsdGlhZGRyLCBwcm90b2NvbHMsIHJlc29sdmVycyB9XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgaXNJcCA9IHJlcXVpcmUoJ2lzLWlwJylcbmNvbnN0IHsgdG9TdHJpbmc6IHVpbnQ4QXJyYXlUb1N0cmluZyB9ID0gcmVxdWlyZSgndWludDhhcnJheXMvdG8tc3RyaW5nJylcblxuY29uc3QgaXNJUCA9IGlzSXBcbmNvbnN0IGlzVjQgPSBpc0lwLnY0XG5jb25zdCBpc1Y2ID0gaXNJcC52NlxuXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ub2RlLWlwL2Jsb2IvbWFzdGVyL2xpYi9pcC5qcyNMN1xuLy8gQHRzLWlnbm9yZSAtIHRoaXMgaXMgY29waWVkIGZyb20gdGhlIGxpbmsgYWJvdmUgYmV0dGVyIHRvIGtlZXAgaXQgdGhlIHNhbWVcbmNvbnN0IHRvQnl0ZXMgPSBmdW5jdGlvbiAoaXAsIGJ1ZmYsIG9mZnNldCkge1xuICBvZmZzZXQgPSB+fm9mZnNldFxuXG4gIGxldCByZXN1bHRcblxuICBpZiAoaXNWNChpcCkpIHtcbiAgICByZXN1bHQgPSBidWZmIHx8IG5ldyBVaW50OEFycmF5KG9mZnNldCArIDQpXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICBpcC5zcGxpdCgvXFwuL2cpLm1hcChmdW5jdGlvbiAoYnl0ZSkge1xuICAgICAgcmVzdWx0W29mZnNldCsrXSA9IHBhcnNlSW50KGJ5dGUsIDEwKSAmIDB4ZmZcbiAgICB9KVxuICB9IGVsc2UgaWYgKGlzVjYoaXApKSB7XG4gICAgY29uc3Qgc2VjdGlvbnMgPSBpcC5zcGxpdCgnOicsIDgpXG5cbiAgICBsZXQgaVxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXN2NCA9IGlzVjQoc2VjdGlvbnNbaV0pXG4gICAgICBsZXQgdjRCdWZmZXJcblxuICAgICAgaWYgKGlzdjQpIHtcbiAgICAgICAgdjRCdWZmZXIgPSB0b0J5dGVzKHNlY3Rpb25zW2ldKVxuICAgICAgICBzZWN0aW9uc1tpXSA9IHVpbnQ4QXJyYXlUb1N0cmluZyh2NEJ1ZmZlci5zbGljZSgwLCAyKSwgJ2Jhc2UxNicpXG4gICAgICB9XG5cbiAgICAgIGlmICh2NEJ1ZmZlciAmJiArK2kgPCA4KSB7XG4gICAgICAgIHNlY3Rpb25zLnNwbGljZShpLCAwLCB1aW50OEFycmF5VG9TdHJpbmcodjRCdWZmZXIuc2xpY2UoMiwgNCksICdiYXNlMTYnKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VjdGlvbnNbMF0gPT09ICcnKSB7XG4gICAgICB3aGlsZSAoc2VjdGlvbnMubGVuZ3RoIDwgOCkgc2VjdGlvbnMudW5zaGlmdCgnMCcpXG4gICAgfSBlbHNlIGlmIChzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgIHdoaWxlIChzZWN0aW9ucy5sZW5ndGggPCA4KSBzZWN0aW9ucy5wdXNoKCcwJylcbiAgICB9IGVsc2UgaWYgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGggJiYgc2VjdGlvbnNbaV0gIT09ICcnOyBpKyspO1xuICAgICAgY29uc3QgYXJndiA9IFtpLCAnMSddXG4gICAgICBmb3IgKGkgPSA5IC0gc2VjdGlvbnMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGFyZ3YucHVzaCgnMCcpXG4gICAgICB9XG4gICAgICBzZWN0aW9ucy5zcGxpY2UuYXBwbHkoc2VjdGlvbnMsIGFyZ3YpXG4gICAgfVxuXG4gICAgcmVzdWx0ID0gYnVmZiB8fCBuZXcgVWludDhBcnJheShvZmZzZXQgKyAxNilcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHdvcmQgPSBwYXJzZUludChzZWN0aW9uc1tpXSwgMTYpXG4gICAgICByZXN1bHRbb2Zmc2V0KytdID0gKHdvcmQgPj4gOCkgJiAweGZmXG4gICAgICByZXN1bHRbb2Zmc2V0KytdID0gd29yZCAmIDB4ZmZcbiAgICB9XG4gIH1cblxuICBpZiAoIXJlc3VsdCkge1xuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGlwIGFkZHJlc3M6ICcgKyBpcClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvbm9kZS1pcC9ibG9iL21hc3Rlci9saWIvaXAuanMjTDYzXG4vLyBAdHMtaWdub3JlIC0gdGhpcyBpcyBjb3BpZWQgZnJvbSB0aGUgbGluayBhYm92ZSBiZXR0ZXIgdG8ga2VlcCBpdCB0aGUgc2FtZVxuY29uc3QgdG9TdHJpbmcgPSBmdW5jdGlvbiAoYnVmZiwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gfn5vZmZzZXRcbiAgbGVuZ3RoID0gbGVuZ3RoIHx8IChidWZmLmxlbmd0aCAtIG9mZnNldClcblxuICBjb25zdCByZXN1bHQgPSBbXVxuICBsZXQgc3RyaW5nXG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIpXG4gIGlmIChsZW5ndGggPT09IDQpIHtcbiAgICAvLyBJUHY0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goYnVmZltvZmZzZXQgKyBpXSlcbiAgICB9XG4gICAgc3RyaW5nID0gcmVzdWx0LmpvaW4oJy4nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gMTYpIHtcbiAgICAvLyBJUHY2XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgcmVzdWx0LnB1c2godmlldy5nZXRVaW50MTYob2Zmc2V0ICsgaSkudG9TdHJpbmcoMTYpKVxuICAgIH1cbiAgICBzdHJpbmcgPSByZXN1bHQuam9pbignOicpXG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoLyhefDopMCg6MCkqOjAoOnwkKS8sICckMTo6JDMnKVxuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC86ezMsNH0vLCAnOjonKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNJUCxcbiAgaXNWNCxcbiAgaXNWNixcbiAgdG9CeXRlcyxcbiAgdG9TdHJpbmdcbn1cbiIsIid1c2Ugc3RyaWN0J1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzXCIpLlByb3RvY29sfSBQcm90b2NvbCAqL1xuXG4vKipcbiAqIFByb3RvY29sc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nfSBwcm90b1xuICogQHJldHVybnMge1Byb3RvY29sfVxuICovXG5mdW5jdGlvbiBQcm90b2NvbHMgKHByb3RvKSB7XG4gIGlmICh0eXBlb2YgKHByb3RvKSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoUHJvdG9jb2xzLmNvZGVzW3Byb3RvXSkge1xuICAgICAgcmV0dXJuIFByb3RvY29scy5jb2Rlc1twcm90b11cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByb3RvY29sIHdpdGggY29kZTogJyArIHByb3RvKVxuICB9IGVsc2UgaWYgKHR5cGVvZiAocHJvdG8pID09PSAnc3RyaW5nJykge1xuICAgIGlmIChQcm90b2NvbHMubmFtZXNbcHJvdG9dKSB7XG4gICAgICByZXR1cm4gUHJvdG9jb2xzLm5hbWVzW3Byb3RvXVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJvdG9jb2wgd2l0aCBuYW1lOiAnICsgcHJvdG8pXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJvdG9jb2wgaWQgdHlwZTogJyArIHByb3RvKVxufVxuXG5jb25zdCBWID0gLTFcblByb3RvY29scy5sZW5ndGhQcmVmaXhlZFZhclNpemUgPSBWXG5Qcm90b2NvbHMuViA9IFZcblxuLyoqIEB0eXBlIHtBcnJheTxbbnVtYmVyLCBudW1iZXIsIHN0cmluZywgKHN0cmluZ3xib29sZWFuKT8sIHN0cmluZz9dPn0gKi9cblByb3RvY29scy50YWJsZSA9IFtcbiAgWzQsIDMyLCAnaXA0J10sXG4gIFs2LCAxNiwgJ3RjcCddLFxuICBbMzMsIDE2LCAnZGNjcCddLFxuICBbNDEsIDEyOCwgJ2lwNiddLFxuICBbNDIsIFYsICdpcDZ6b25lJ10sXG4gIFs1MywgViwgJ2RucycsICdyZXNvbHZhYmxlJ10sXG4gIFs1NCwgViwgJ2RuczQnLCAncmVzb2x2YWJsZSddLFxuICBbNTUsIFYsICdkbnM2JywgJ3Jlc29sdmFibGUnXSxcbiAgWzU2LCBWLCAnZG5zYWRkcicsICdyZXNvbHZhYmxlJ10sXG4gIFsxMzIsIDE2LCAnc2N0cCddLFxuICBbMjczLCAxNiwgJ3VkcCddLFxuICBbMjc1LCAwLCAncDJwLXdlYnJ0Yy1zdGFyJ10sXG4gIFsyNzYsIDAsICdwMnAtd2VicnRjLWRpcmVjdCddLFxuICBbMjc3LCAwLCAncDJwLXN0YXJkdXN0J10sXG4gIFsyOTAsIDAsICdwMnAtY2lyY3VpdCddLFxuICBbMzAxLCAwLCAndWR0J10sXG4gIFszMDIsIDAsICd1dHAnXSxcbiAgWzQwMCwgViwgJ3VuaXgnLCBmYWxzZSwgJ3BhdGgnXSxcbiAgLy8gYGlwZnNgIGlzIGFkZGVkIGJlZm9yZSBgcDJwYCBmb3IgbGVnYWN5IHN1cHBvcnQuXG4gIC8vIEFsbCB0ZXh0IHJlcHJlc2VudGF0aW9ucyB3aWxsIGRlZmF1bHQgdG8gYHAycGAsIGJ1dCBgaXBmc2Agd2lsbFxuICAvLyBzdGlsbCBiZSBzdXBwb3J0ZWRcbiAgWzQyMSwgViwgJ2lwZnMnXSxcbiAgLy8gYHAycGAgaXMgdGhlIHByZWZlcnJlZCBuYW1lIGZvciA0MjEsIGFuZCBpcyBub3cgdGhlIGRlZmF1bHRcbiAgWzQyMSwgViwgJ3AycCddLFxuICBbNDQzLCAwLCAnaHR0cHMnXSxcbiAgWzQ0NCwgOTYsICdvbmlvbiddLFxuICBbNDQ1LCAyOTYsICdvbmlvbjMnXSxcbiAgWzQ0NiwgViwgJ2dhcmxpYzY0J10sXG4gIFs0NjAsIDAsICdxdWljJ10sXG4gIFs0NzcsIDAsICd3cyddLFxuICBbNDc4LCAwLCAnd3NzJ10sXG4gIFs0NzksIDAsICdwMnAtd2Vic29ja2V0LXN0YXInXSxcbiAgWzQ4MCwgMCwgJ2h0dHAnXSxcbiAgWzc3NywgViwgJ21lbW9yeSddXG5dXG4vKiogQHR5cGUge1JlY29yZDxzdHJpbmcsUHJvdG9jb2w+fSAqL1xuUHJvdG9jb2xzLm5hbWVzID0ge31cbi8qKiBAdHlwZSB7UmVjb3JkPG51bWJlcixQcm90b2NvbD59ICovXG5Qcm90b2NvbHMuY29kZXMgPSB7fVxuXG4vLyBwb3B1bGF0ZSB0YWJsZXNcblByb3RvY29scy50YWJsZS5tYXAocm93ID0+IHtcbiAgY29uc3QgcHJvdG8gPSBwLmFwcGx5KG51bGwsIHJvdylcbiAgUHJvdG9jb2xzLmNvZGVzW3Byb3RvLmNvZGVdID0gcHJvdG9cbiAgUHJvdG9jb2xzLm5hbWVzW3Byb3RvLm5hbWVdID0gcHJvdG9cbiAgcmV0dXJuIG51bGxcbn0pXG5cblByb3RvY29scy5vYmplY3QgPSBwXG5cbi8qKlxuICpcbiAqIENyZWF0ZSBhIHByb3RvY29sXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHthbnl9IFtyZXNvbHZhYmxlXVxuICogQHBhcmFtIHthbnl9IFtwYXRoXVxuICogQHJldHVybnMge1Byb3RvY29sfVxuICovXG5mdW5jdGlvbiBwIChjb2RlLCBzaXplLCBuYW1lLCByZXNvbHZhYmxlLCBwYXRoKSB7XG4gIHJldHVybiB7XG4gICAgY29kZSxcbiAgICBzaXplLFxuICAgIG5hbWUsXG4gICAgcmVzb2x2YWJsZTogQm9vbGVhbihyZXNvbHZhYmxlKSxcbiAgICBwYXRoOiBCb29sZWFuKHBhdGgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm90b2NvbHNcbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgaW1wbFxuXG5pZiAoZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIgJiYgZ2xvYmFsVGhpcy5BYm9ydFNpZ25hbCkge1xuICBpbXBsID0gZ2xvYmFsVGhpc1xufSBlbHNlIHtcbiAgaW1wbCA9IHJlcXVpcmUoJ2Fib3J0LWNvbnRyb2xsZXInKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5BYm9ydFNpZ25hbCA9IGltcGwuQWJvcnRTaWduYWxcbm1vZHVsZS5leHBvcnRzLkFib3J0Q29udHJvbGxlciA9IGltcGwuQWJvcnRDb250cm9sbGVyXG4iLCIndXNlIHN0cmljdCdcblxuaWYgKGdsb2JhbFRoaXMuZmV0Y2ggJiYgZ2xvYmFsVGhpcy5IZWFkZXJzICYmIGdsb2JhbFRoaXMuUmVxdWVzdCAmJiBnbG9iYWxUaGlzLlJlc3BvbnNlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRlZmF1bHQ6IGdsb2JhbFRoaXMuZmV0Y2gsXG4gICAgSGVhZGVyczogZ2xvYmFsVGhpcy5IZWFkZXJzLFxuICAgIFJlcXVlc3Q6IGdsb2JhbFRoaXMuUmVxdWVzdCxcbiAgICBSZXNwb25zZTogZ2xvYmFsVGhpcy5SZXNwb25zZVxuICB9XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZWZhdWx0OiByZXF1aXJlKCdub2RlLWZldGNoJykuZGVmYXVsdCxcbiAgICBIZWFkZXJzOiByZXF1aXJlKCdub2RlLWZldGNoJykuSGVhZGVycyxcbiAgICBSZXF1ZXN0OiByZXF1aXJlKCdub2RlLWZldGNoJykuUmVxdWVzdCxcbiAgICBSZXNwb25zZTogcmVxdWlyZSgnbm9kZS1mZXRjaCcpLlJlc3BvbnNlXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gdGhlIG9ubHkgcmVsaWFibGUgbWVhbnMgdG8gZ2V0IHRoZSBnbG9iYWwgb2JqZWN0IGlzXG5cdC8vIGBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpYFxuXHQvLyBIb3dldmVyLCB0aGlzIGNhdXNlcyBDU1AgdmlvbGF0aW9ucyBpbiBDaHJvbWUgYXBwcy5cblx0aWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gc2VsZjsgfVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHdpbmRvdzsgfVxuXHRpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGdsb2JhbDsgfVxuXHR0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCcpO1xufVxuXG52YXIgZ2xvYmFsID0gZ2V0R2xvYmFsKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGdsb2JhbC5mZXRjaDtcblxuLy8gTmVlZGVkIGZvciBUeXBlU2NyaXB0IGFuZCBXZWJwYWNrLlxuaWYgKGdsb2JhbC5mZXRjaCkge1xuXHRleHBvcnRzLmRlZmF1bHQgPSBnbG9iYWwuZmV0Y2guYmluZChnbG9iYWwpO1xufVxuXG5leHBvcnRzLkhlYWRlcnMgPSBnbG9iYWwuSGVhZGVycztcbmV4cG9ydHMuUmVxdWVzdCA9IGdsb2JhbC5SZXF1ZXN0O1xuZXhwb3J0cy5SZXNwb25zZSA9IGdsb2JhbC5SZXNwb25zZTsiLCIvLyBtaW5pbWFsIGxpYnJhcnkgZW50cnkgcG9pbnQuXG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zcmMvaW5kZXgtbWluaW1hbFwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyUmVhZGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYnVmID0gYnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XG59XG5cbnZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlX2FycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9KShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogY3JlYXRlX2FycmF5O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fEJ1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxuICovXG5SZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cblJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcbiAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xuICAgIC8vIHRlbmRzIHRvIGRlb3B0IHdpdGggbG9jYWwgdmFycyBmb3Igb2N0ZXQgZXRjLlxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAobG8pXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDV0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+ICA0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyAxc3QuLjN0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDR0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChoaSlcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3VpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcbiAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XVxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxuICAgICAgICAgIHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XG5cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjc2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLFxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSkgLy8gcGxhaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBzdGFydCA9PT0gZW5kIC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXG4gICAgICAgID8gbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApXG4gICAgICAgIDogdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBpZiBrbm93biwgb3RoZXJ3aXNlIGEgdmFyaW50IGlzIGFzc3VtZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFdpcmUgdHlwZSByZWNlaXZlZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuXG4gICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFwidG9OdW1iZXJcIjtcbiAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcblxuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XG5cbi8vIGV4dGVuZHMgUmVhZGVyXG52YXIgUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xuKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgcmVhZGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgUmVhZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XG4gICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEBuYW1lIEJ1ZmZlclJlYWRlciNidWZcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgICAqL1xufVxuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh1dGlsLkJ1ZmZlcilcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpOyAvLyBtb2RpZmllcyBwb3NcbiAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlXG4gICAgICAgID8gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpXG4gICAgICAgIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIEJ1ZmZlclJlYWRlciNieXRlc1xuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBWYWx1ZSByZWFkXG4gKi9cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBOYW1lZCByb290cy5cbiAqIFRoaXMgaXMgd2hlcmUgcGJqcyBzdG9yZXMgZ2VuZXJhdGVkIHN0cnVjdHVyZXMgKHRoZSBvcHRpb24gYC1yLCAtLXJvb3RgIHNwZWNpZmllcyBhIG5hbWUpLlxuICogQ2FuIGFsc28gYmUgdXNlZCBtYW51YWxseSB0byBtYWtlIHJvb3RzIGF2YWlsYWJsZSBhY2Nyb3NzIG1vZHVsZXMuXG4gKiBAbmFtZSByb290c1xuICogQHR5cGUge09iamVjdC48c3RyaW5nLFJvb3Q+fVxuICogQGV4YW1wbGVcbiAqIC8vIHBianMgLXIgbXlyb290IC1vIGNvbXBpbGVkLmpzIC4uLlxuICpcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxuICogcmVxdWlyZShcIi4vY29tcGlsZWQuanNcIik7XG4gKlxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxuICogdmFyIHJvb3QgPSBwcm90b2J1Zi5yb290c1tcIm15cm9vdFwiXTtcbiAqL1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogU3RyZWFtaW5nIFJQQyBoZWxwZXJzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgcnBjID0gZXhwb3J0cztcblxuLyoqXG4gKiBSUEMgaW1wbGVtZW50YXRpb24gcGFzc2VkIHRvIHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0gcGVyZm9ybWluZyBhIHNlcnZpY2UgcmVxdWVzdCBvbiBuZXR3b3JrIGxldmVsLCBpLmUuIGJ5IHV0aWxpemluZyBodHRwIHJlcXVlc3RzIG9yIHdlYnNvY2tldHMuXG4gKiBAdHlwZWRlZiBSUENJbXBsXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxNZXNzYWdlPHt9PixNZXNzYWdlPHt9Pj59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZCBiZWluZyBjYWxsZWRcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVxdWVzdERhdGEgUmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge1JQQ0ltcGxDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gcnBjSW1wbChtZXRob2QsIHJlcXVlc3REYXRhLCBjYWxsYmFjaykge1xuICogICAgIGlmIChwcm90b2J1Zi51dGlsLmxjRmlyc3QobWV0aG9kLm5hbWUpICE9PSBcIm15TWV0aG9kXCIpIC8vIGNvbXBhdGlibGUgd2l0aCBzdGF0aWMgY29kZVxuICogICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggbWV0aG9kXCIpO1xuICogICAgIGFzeW5jaHJvbm91c2x5T2J0YWluQVJlc3BvbnNlKHJlcXVlc3REYXRhLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlRGF0YSkge1xuICogICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlRGF0YSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKi9cblxuLyoqXG4gKiBOb2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIFJQQ0ltcGx9LlxuICogQHR5cGVkZWYgUlBDSW1wbENhbGxiYWNrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcbiAqIEBwYXJhbSB7VWludDhBcnJheXxudWxsfSBbcmVzcG9uc2VdIFJlc3BvbnNlIGRhdGEgb3IgYG51bGxgIHRvIHNpZ25hbCBlbmQgb2Ygc3RyZWFtLCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5ycGMuU2VydmljZSA9IHJlcXVpcmUoXCIuL3JwYy9zZXJ2aWNlXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLy8gRXh0ZW5kcyBFdmVudEVtaXR0ZXJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXG4gKlxuICogRGlmZmVycyBmcm9tIHtAbGluayBSUENJbXBsQ2FsbGJhY2t9IGluIHRoYXQgaXQgaXMgYW4gYWN0dWFsIGNhbGxiYWNrIG9mIGEgc2VydmljZSBtZXRob2Qgd2hpY2ggbWF5IG5vdCByZXR1cm4gYHJlc3BvbnNlID0gbnVsbGAuXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxuICogQHBhcmFtIHtUUmVzfSBbcmVzcG9uc2VdIFJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZTxUUmVzPj59IFByb21pc2UgaWYgYGNhbGxiYWNrYCBoYXMgYmVlbiBvbWl0dGVkLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgUlBDIHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXG4gKiBAZXhwb3J0cyBycGMuU2VydmljZVxuICogQGV4dGVuZHMgdXRpbC5FdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcblxuICAgIGlmICh0eXBlb2YgcnBjSW1wbCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcblxuICAgIHV0aWwuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBSUEMgaW1wbGVtZW50YXRpb24uIEJlY29tZXMgYG51bGxgIG9uY2UgdGhlIHNlcnZpY2UgaXMgZW5kZWQuXG4gICAgICogQHR5cGUge1JQQ0ltcGx8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3REZWxpbWl0ZWQgPSBCb29sZWFuKHJlcXVlc3REZWxpbWl0ZWQpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZURlbGltaXRlZCA9IEJvb2xlYW4ocmVzcG9uc2VEZWxpbWl0ZWQpO1xufVxuXG4vKipcbiAqIENhbGxzIGEgc2VydmljZSBtZXRob2QgdGhyb3VnaCB7QGxpbmsgcnBjLlNlcnZpY2UjcnBjSW1wbHxycGNJbXBsfS5cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVxPn0gcmVxdWVzdEN0b3IgUmVxdWVzdCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVzPn0gcmVzcG9uc2VDdG9yIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IGNhbGxiYWNrIFNlcnZpY2UgY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoIXJlcXVlc3QpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKHJwY0NhbGwsIHNlbGYsIG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCk7XG5cbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZCgvKiBlbmRlZEJ5UlBDICovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbZW5kZWRCeVJQQz1mYWxzZV0gV2hldGhlciB0aGUgc2VydmljZSBoYXMgYmVlbiBlbmRlZCBieSB0aGUgUlBDIGltcGxlbWVudGF0aW9uLlxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBgdGhpc2BcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGVuZGVkQnlSUEMpIHtcbiAgICBpZiAodGhpcy5ycGNJbXBsKSB7XG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXG4gICAgICAgICAgICB0aGlzLnJwY0ltcGwobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzLlxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxuICovXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcblxuICAgIC8vIG5vdGUgdGhhdCB0aGUgY2FzdHMgYmVsb3cgYXJlIHRoZW9yZXRpY2FsbHkgdW5uZWNlc3NhcnkgYXMgb2YgdG9kYXksIGJ1dCBvbGRlciBzdGF0aWNhbGx5XG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXG5cbiAgICAvKipcbiAgICAgKiBMb3cgYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBaZXJvIGJpdHMuXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XG4gKi9cbnZhciB6ZXJvID0gTG9uZ0JpdHMuemVybyA9IG5ldyBMb25nQml0cygwLCAwKTtcblxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbnplcm8uenpFbmNvZGUgPSB6ZXJvLnp6RGVjb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XG5cbi8qKlxuICogWmVybyBoYXNoLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMDtcbiAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgdmFyIGxvID0gdmFsdWUgPj4+IDAsXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcbiAgICBpZiAoc2lnbikge1xuICAgICAgICBoaSA9IH5oaSA+Pj4gMDtcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIGEgbnVtYmVyLCBsb25nIG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgcG9zc2libHkgdW5zYWZlIEphdmFTY3JpcHQgbnVtYmVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xuICAgICAgICB2YXIgbG8gPSB+dGhpcy5sbyArIDEgPj4+IDAsXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvICsgdGhpcy5oaSAqIDQyOTQ5NjcyOTY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd9IExvbmdcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xuICAgIHJldHVybiB1dGlsLkxvbmdcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG59O1xuXG52YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xuICovXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXG4gICAgLFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDYpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXG4gICAgICAgIHRoaXMuaGkgICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDI0XG4gICAgKTtcbn07XG5cbi8qKlxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcbiAgICB2YXIgbWFzayA9ICAgdGhpcy5oaSA+PiAzMTtcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgdGhpcy5sbyAgPSAoKHRoaXMubG8gPj4+IDEgfCB0aGlzLmhpIDw8IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgbG9uZ2JpdHMgd2hlbiBlbmNvZGVkIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcbiAgICAgICAgcGFydDIgPSAgdGhpcy5oaSA+Pj4gMjQ7XG4gICAgcmV0dXJuIHBhcnQyID09PSAwXG4gICAgICAgICA/IHBhcnQxID09PSAwXG4gICAgICAgICAgID8gcGFydDAgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcbiAgICAgICAgICAgOiBwYXJ0MSA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxuICAgICAgICAgOiBwYXJ0MiA8IDEyOCA/IDkgOiAxMDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gZXhwb3J0cztcblxuLy8gdXNlZCB0byByZXR1cm4gYSBQcm9taXNlIHdoZXJlIGNhbGxiYWNrIGlzIG9taXR0ZWRcbnV0aWwuYXNQcm9taXNlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2FzcHJvbWlzZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwuYmFzZTY0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Jhc2U2NFwiKTtcblxuLy8gYmFzZSBjbGFzcyBvZiBycGMuU2VydmljZVxudXRpbC5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyXCIpO1xuXG4vLyBmbG9hdCBoYW5kbGluZyBhY2Nyb3NzIGJyb3dzZXJzXG51dGlsLmZsb2F0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Zsb2F0XCIpO1xuXG4vLyByZXF1aXJlcyBtb2R1bGVzIG9wdGlvbmFsbHkgYW5kIGhpZGVzIHRoZSBjYWxsIGZyb20gYnVuZGxlcnNcbnV0aWwuaW5xdWlyZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9pbnF1aXJlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gdXRmOCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwudXRmOCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy91dGY4XCIpO1xuXG4vLyBwcm92aWRlcyBhIG5vZGUtbGlrZSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlclxudXRpbC5wb29sID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3Bvb2xcIik7XG5cbi8vIHV0aWxpdHkgdG8gd29yayB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZVxudXRpbC5Mb25nQml0cyA9IHJlcXVpcmUoXCIuL2xvbmdiaXRzXCIpO1xuXG4vKipcbiAqIFdoZXRoZXIgcnVubmluZyB3aXRoaW4gbm9kZSBvciBub3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNOb2RlID0gQm9vbGVhbih0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuXG4vKipcbiAqIEdsb2JhbCBvYmplY3QgcmVmZXJlbmNlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnV0aWwuZ2xvYmFsID0gdXRpbC5pc05vZGUgJiYgZ2xvYmFsXG4gICAgICAgICAgIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XG4gICAgICAgICAgIHx8IHR5cGVvZiBzZWxmICAgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZlxuICAgICAgICAgICB8fCB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWludmFsaWQtdGhpc1xuXG4vKipcbiAqIEFuIGltbXVhYmxlIGVtcHR5IGFycmF5LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtBcnJheS48Kj59XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW107IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBlbXB0eSBvYmplY3QuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIGludGVnZXJcbiAqL1xudXRpbC5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcbiAqL1xudXRpbC5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3RcbiAqL1xudXRpbC5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIHV0aWwuaXNTZXR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc3NldCA9XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzU2V0ID0gZnVuY3Rpb24gaXNTZXQob2JqLCBwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXEsIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpID4gMDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBCdWZmZXIgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IG5vZGUncyB0eXBpbmdzLlxuICogQGludGVyZmFjZSBCdWZmZXJcbiAqIEBleHRlbmRzIFVpbnQ4QXJyYXlcbiAqL1xuXG4vKipcbiAqIE5vZGUncyBCdWZmZXIgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPEJ1ZmZlcj59XG4gKi9cbnV0aWwuQnVmZmVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBCdWZmZXIgPSB1dGlsLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgICAgICAvLyByZWZ1c2UgdG8gdXNlIG5vbi1ub2RlIGJ1ZmZlcnMgaWYgbm90IGV4cGxpY2l0bHkgYXNzaWduZWQgKHBlcmYgcmVhc29ucyk6XG4gICAgICAgIHJldHVybiBCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA/IEJ1ZmZlciA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59KSgpO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZnVsbCBmb3IgQnVmZmVyLmZyb20uXG51dGlsLl9CdWZmZXJfZnJvbSA9IG51bGw7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmaWxsIGZvciBCdWZmZXIuYWxsb2NVbnNhZmUuXG51dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYnVmZmVyIG9mIHdoYXRldmVyIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbc2l6ZU9yQXJyYXk9MF0gQnVmZmVyIHNpemUgb3IgbnVtYmVyIGFycmF5XG4gKiBAcmV0dXJucyB7VWludDhBcnJheXxCdWZmZXJ9IEJ1ZmZlclxuICovXG51dGlsLm5ld0J1ZmZlciA9IGZ1bmN0aW9uIG5ld0J1ZmZlcihzaXplT3JBcnJheSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHR5cGVvZiBzaXplT3JBcnJheSA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogbmV3IHV0aWwuQXJyYXkoc2l6ZU9yQXJyYXkpXG4gICAgICAgIDogdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2Zyb20oc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgPyBzaXplT3JBcnJheVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoc2l6ZU9yQXJyYXkpO1xufTtcblxuLyoqXG4gKiBBcnJheSBpbXBsZW1lbnRhdGlvbiB1c2VkIGluIHRoZSBicm93c2VyLiBgVWludDhBcnJheWAgaWYgc3VwcG9ydGVkLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxVaW50OEFycmF5Pn1cbiAqL1xudXRpbC5BcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gVWludDhBcnJheSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA6IEFycmF5O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIExvbmcgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgTG9uZyBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbG9uZy5qcy5cbiAqIEBpbnRlcmZhY2UgTG9uZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvdyBMb3cgYml0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2ggSGlnaCBiaXRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBMb25nLmpzJ3MgTG9uZyBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8TG9uZz59XG4gKi9cbnV0aWwuTG9uZyA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8gJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTy5Mb25nXG4gICAgICAgICB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5Mb25nXG4gICAgICAgICB8fCB1dGlsLmlucXVpcmUoXCJsb25nXCIpO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAyIGJpdCAoYGJvb2xgKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkyUmUgPSAvXnRydWV8ZmFsc2V8MHwxJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDMyIGJpdCAoYGludDMyYCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkzMlJlID0gL14tPyg/OjB8WzEtOV1bMC05XSopJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDY0IGJpdCAoYGludDY0YCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXk2NFJlID0gL14oPzpbXFxcXHgwMC1cXFxceGZmXXs4fXwtPyg/OjB8WzEtOV1bMC05XSopKSQvO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9yIGxvbmcgdG8gYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbnV0aWwubG9uZ1RvSGFzaCA9IGZ1bmN0aW9uIGxvbmdUb0hhc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyB1dGlsLkxvbmdCaXRzLmZyb20odmFsdWUpLnRvSGFzaCgpXG4gICAgICAgIDogdXRpbC5Mb25nQml0cy56ZXJvSGFzaDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcgdG8gYSBsb25nIG9yIG51bWJlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd8bnVtYmVyfSBPcmlnaW5hbCB2YWx1ZVxuICovXG51dGlsLmxvbmdGcm9tSGFzaCA9IGZ1bmN0aW9uIGxvbmdGcm9tSGFzaChoYXNoLCB1bnNpZ25lZCkge1xuICAgIHZhciBiaXRzID0gdXRpbC5Mb25nQml0cy5mcm9tSGFzaChoYXNoKTtcbiAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICByZXR1cm4gdXRpbC5Mb25nLmZyb21CaXRzKGJpdHMubG8sIGJpdHMuaGksIHVuc2lnbmVkKTtcbiAgICByZXR1cm4gYml0cy50b051bWJlcihCb29sZWFuKHVuc2lnbmVkKSk7XG59O1xuXG4vKipcbiAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gc3JjIFNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0PWZhbHNlXSBNZXJnZXMgb25seSBpZiB0aGUga2V5IGlzIG5vdCBhbHJlYWR5IHNldFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoZHN0LCBzcmMsIGlmTm90U2V0KSB7IC8vIHVzZWQgYnkgY29udmVydGVyc1xuICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChkc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCB8fCAhaWZOb3RTZXQpXG4gICAgICAgICAgICBkc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgcmV0dXJuIGRzdDtcbn1cblxudXRpbC5tZXJnZSA9IG1lcmdlO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC5sY0ZpcnN0ID0gZnVuY3Rpb24gbGNGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGN1c3RvbSBlcnJvciBjb25zdHJ1Y3Rvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFcnJvciBuYW1lXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0b3I8RXJyb3I+fSBDdXN0b20gZXJyb3IgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gbmV3RXJyb3IobmFtZSkge1xuXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcykge1xuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21FcnJvcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIC8vIF4ganVzdCByZXR1cm5zIGEgbmV3IGVycm9yIGluc3RhbmNlIGJlY2F1c2UgdGhlIGN0b3IgY2FuIGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtZXNzYWdlOyB9IH0pO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgLy8gbm9kZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3VzdG9tRXJyb3IpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFja1wiLCB7IHZhbHVlOiBuZXcgRXJyb3IoKS5zdGFjayB8fCBcIlwiIH0pO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgbWVyZ2UodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgKEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBDdXN0b21FcnJvcjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21FcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBuYW1lOyB9IH0pO1xuXG4gICAgQ3VzdG9tRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gICAgfTtcblxuICAgIHJldHVybiBDdXN0b21FcnJvcjtcbn1cblxudXRpbC5uZXdFcnJvciA9IG5ld0Vycm9yO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcHJvdG9jb2wgZXJyb3IuXG4gKiBAY2xhc3NkZXNjIEVycm9yIHN1YmNsYXNzIGluZGljYXRpbmcgYSBwcm90b2NvbCBzcGVjaWZjIGVycm9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIEFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQGV4YW1wbGVcbiAqIHRyeSB7XG4gKiAgICAgTXlNZXNzYWdlLmRlY29kZShzb21lQnVmZmVyKTsgLy8gdGhyb3dzIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICogfSBjYXRjaCAoZSkge1xuICogICAgIGlmIChlIGluc3RhbmNlb2YgUHJvdG9jb2xFcnJvciAmJiBlLmluc3RhbmNlKVxuICogICAgICAgICBjb25zb2xlLmxvZyhcImRlY29kZWQgc28gZmFyOiBcIiArIEpTT04uc3RyaW5naWZ5KGUuaW5zdGFuY2UpKTtcbiAqIH1cbiAqL1xudXRpbC5Qcm90b2NvbEVycm9yID0gbmV3RXJyb3IoXCJQcm90b2NvbEVycm9yXCIpO1xuXG4vKipcbiAqIFNvIGZhciBkZWNvZGVkIG1lc3NhZ2UgaW5zdGFuY2UuXG4gKiBAbmFtZSB1dGlsLlByb3RvY29sRXJyb3IjaW5zdGFuY2VcbiAqIEB0eXBlIHtNZXNzYWdlPFQ+fVxuICovXG5cbi8qKlxuICogQSBPbmVPZiBnZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZHZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZHZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBnZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZHZXR0ZXJ9IFVuYm91bmQgZ2V0dGVyXG4gKi9cbnV0aWwub25lT2ZHZXR0ZXIgPSBmdW5jdGlvbiBnZXRPbmVPZihmaWVsZE5hbWVzKSB7XG4gICAgdmFyIGZpZWxkTWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICBmaWVsZE1hcFtmaWVsZE5hbWVzW2ldXSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLCBpID0ga2V5cy5sZW5ndGggLSAxOyBpID4gLTE7IC0taSlcbiAgICAgICAgICAgIGlmIChmaWVsZE1hcFtrZXlzW2ldXSA9PT0gMSAmJiB0aGlzW2tleXNbaV1dICE9PSB1bmRlZmluZWQgJiYgdGhpc1trZXlzW2ldXSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1tpXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBIE9uZU9mIHNldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZlNldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZlNldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB2YWx1ZSBGaWVsZCBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgc2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mU2V0dGVyfSBVbmJvdW5kIHNldHRlclxuICovXG51dGlsLm9uZU9mU2V0dGVyID0gZnVuY3Rpb24gc2V0T25lT2YoZmllbGROYW1lcykge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldICE9PSBuYW1lKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2ZpZWxkTmFtZXNbaV1dO1xuICAgIH07XG59O1xuXG4vKipcbiAqIERlZmF1bHQgY29udmVyc2lvbiBvcHRpb25zIHVzZWQgZm9yIHtAbGluayBNZXNzYWdlI3RvSlNPTn0gaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIFRoZXNlIG9wdGlvbnMgYXJlIGNsb3NlIHRvIHByb3RvMydzIEpTT04gbWFwcGluZyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpbnRlcm5hbCB0eXBlcyBsaWtlIEFueSBhcmUgaGFuZGxlZCBqdXN0IGxpa2UgbWVzc2FnZXMuIE1vcmUgcHJlY2lzZWx5OlxuICpcbiAqIC0gTG9uZ3MgYmVjb21lIHN0cmluZ3NcbiAqIC0gRW51bXMgYmVjb21lIHN0cmluZyBrZXlzXG4gKiAtIEJ5dGVzIGJlY29tZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKiAtIChTdWItKU1lc3NhZ2VzIGJlY29tZSBwbGFpbiBvYmplY3RzXG4gKiAtIE1hcHMgYmVjb21lIHBsYWluIG9iamVjdHMgd2l0aCBhbGwgc3RyaW5nIGtleXNcbiAqIC0gUmVwZWF0ZWQgZmllbGRzIGJlY29tZSBhcnJheXNcbiAqIC0gTmFOIGFuZCBJbmZpbml0eSBmb3IgZmxvYXQgYW5kIGRvdWJsZSBmaWVsZHMgYmVjb21lIHN0cmluZ3NcbiAqXG4gKiBAdHlwZSB7SUNvbnZlcnNpb25PcHRpb25zfVxuICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zP2hsPWVuI2pzb25cbiAqL1xudXRpbC50b0pTT05PcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGpzb246IHRydWVcbn07XG5cbi8vIFNldHMgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudCAoY2FsbGVkIGluIGluZGV4LW1pbmltYWwpXG51dGlsLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFCdWZmZXIpIHtcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGJlY2F1c2Ugbm9kZSA0LnggYnVmZmVycyBhcmUgaW5jb21wYXRpYmxlICYgaW1tdXRhYmxlXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9wcm90b2J1Zi5qcy9wdWxsLzY2NVxuICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSAmJiBCdWZmZXIuZnJvbSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfZnJvbSh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgICAgIH07XG4gICAgdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gQnVmZmVyLmFsbG9jVW5zYWZlIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyV3JpdGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgYmFzZTY0ICAgID0gdXRpbC5iYXNlNjQsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHdyaXRlciBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgVWludDhBcnJheSwgbnVtYmVyKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gT3AoZm4sIGxlbiwgdmFsKSB7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfVxuICAgICAqL1xuICAgIHRoaXMuZm4gPSBmbjtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGJ5dGUgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBsZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbCA9IHZhbDsgLy8gdHlwZSB2YXJpZXNcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgc3RhdGUgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIENvcGllZCB3cml0ZXIgc3RhdGUuXG4gKiBAbWVtYmVyb2YgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7V3JpdGVyfSB3cml0ZXIgV3JpdGVyIHRvIGNvcHkgc3RhdGUgZnJvbVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGVhZC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCB0YWlsLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IHN0YXRlLlxuICAgICAqIEB0eXBlIHtTdGF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXcml0ZXIoKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gMDtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgaGVhZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IG5ldyBPcChub29wLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgdGFpbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogTGlua2VkIGZvcmtlZCBzdGF0ZXMuXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbnVsbDtcblxuICAgIC8vIFdoZW4gYSB2YWx1ZSBpcyB3cml0dGVuLCB0aGUgd3JpdGVyIGNhbGN1bGF0ZXMgaXRzIGJ5dGUgbGVuZ3RoIGFuZCBwdXRzIGl0IGludG8gYSBsaW5rZWRcbiAgICAvLyBsaXN0IG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybSB3aGVuIGZpbmlzaCgpIGlzIGNhbGxlZC4gVGhpcyBib3RoIGFsbG93cyB1cyB0byBhbGxvY2F0ZVxuICAgIC8vIGJ1ZmZlcnMgb2YgdGhlIGV4YWN0IHJlcXVpcmVkIHNpemUgYW5kIHJlZHVjZXMgdGhlIGFtb3VudCBvZiB3b3JrIHdlIGhhdmUgdG8gZG8gY29tcGFyZWRcbiAgICAvLyB0byBmaXJzdCBjYWxjdWxhdGluZyBvdmVyIG9iamVjdHMgYW5kIHRoZW4gZW5jb2Rpbmcgb3ZlciBvYmplY3RzLiBJbiBvdXIgY2FzZSwgdGhlIGVuY29kaW5nXG4gICAgLy8gcGFydCBpcyBqdXN0IGEgbGlua2VkIGxpc3Qgd2FsayBjYWxsaW5nIG9wZXJhdGlvbnMgd2l0aCBhbHJlYWR5IHByZXBhcmVkIHZhbHVlcy5cbn1cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKCkge1xuICAgICAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVyKCk7XG4gICAgICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgd3JpdGVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyV3JpdGVyfFdyaXRlcn0gQSB7QGxpbmsgQnVmZmVyV3JpdGVyfSB3aGVuIEJ1ZmZlcnMgYXJlIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGEge0BsaW5rIFdyaXRlcn1cbiAqL1xuV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG4vKipcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxuICovXG5Xcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplKSB7XG4gICAgcmV0dXJuIG5ldyB1dGlsLkFycmF5KHNpemUpO1xufTtcblxuLy8gVXNlIFVpbnQ4QXJyYXkgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXIsIGp1c3QgbGlrZSBub2RlIGRvZXMgd2l0aCBidWZmZXJzXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxuICAgIFdyaXRlci5hbGxvYyA9IHV0aWwucG9vbChXcml0ZXIuYWxsb2MsIHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KTtcblxuLyoqXG4gKiBQdXNoZXMgYSBuZXcgb3BlcmF0aW9uIHRvIHRoZSBxdWV1ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAcHJpdmF0ZVxuICovXG5Xcml0ZXIucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gcHVzaChmbiwgbGVuLCB2YWwpIHtcbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBPcChmbiwgbGVuLCB2YWwpO1xuICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50MzIodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwgPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsID4+Pj0gNztcbiAgICB9XG4gICAgYnVmW3Bvc10gPSB2YWw7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHZhcmludCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGV4dGVuZHMgT3BcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xuICAgIHRoaXMubGVuID0gbGVuO1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbn1cblxuVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xuVmFyaW50T3AucHJvdG90eXBlLmZuID0gd3JpdGVWYXJpbnQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbiB3cml0ZV91aW50MzIodmFsdWUpIHtcbiAgICAvLyBoZXJlLCB0aGUgY2FsbCB0byB0aGlzLnB1c2ggaGFzIGJlZW4gaW5saW5lZCBhbmQgYSB2YXJpbnQgc3BlY2lmaWMgT3Agc3ViY2xhc3MgaXMgdXNlZC5cbiAgICAvLyB1aW50MzIgaXMgYnkgZmFyIHRoZSBtb3N0IGZyZXF1ZW50bHkgdXNlZCBvcGVyYXRpb24gYW5kIGJlbmVmaXRzIHNpZ25pZmljYW50bHkgZnJvbSB0aGlzLlxuICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBWYXJpbnRPcChcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApXG4gICAgICAgICAgICAgICAgPCAxMjggICAgICAgPyAxXG4gICAgICAgIDogdmFsdWUgPCAxNjM4NCAgICAgPyAyXG4gICAgICAgIDogdmFsdWUgPCAyMDk3MTUyICAgPyAzXG4gICAgICAgIDogdmFsdWUgPCAyNjg0MzU0NTYgPyA0XG4gICAgICAgIDogICAgICAgICAgICAgICAgICAgICA1LFxuICAgIHZhbHVlKSkubGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gd3JpdGVfaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwXG4gICAgICAgID8gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCAxMCwgTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSkpIC8vIDEwIGJ5dGVzIHBlciBzcGVjXG4gICAgICAgIDogdGhpcy51aW50MzIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50NjQodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwuaGkpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gKHZhbC5sbyA+Pj4gNyB8IHZhbC5oaSA8PCAyNSkgPj4+IDA7XG4gICAgICAgIHZhbC5oaSA+Pj49IDc7XG4gICAgfVxuICAgIHdoaWxlICh2YWwubG8gPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xuICAgIH1cbiAgICBidWZbcG9zKytdID0gdmFsLmxvO1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50NjQgPSBmdW5jdGlvbiB3cml0ZV91aW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQ2NCA9IFdyaXRlci5wcm90b3R5cGUudWludDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSkuenpFbmNvZGUoKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgYm9vbGlzaCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiB3cml0ZV9ib29sKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCB2YWx1ZSA/IDEgOiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICAmIDI1NTtcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5sbykuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmhpKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2NCA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBmbG9hdCAoMzIgYml0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHdyaXRlX2Zsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHdyaXRlX2RvdWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUpO1xufTtcblxudmFyIHdyaXRlQnl0ZXMgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zZXRcbiAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc19mb3IodmFsLCBidWYsIHBvcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHZhbFtpXTtcbiAgICB9O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gdmFsdWUgQnVmZmVyIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlcyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgaWYgKCFsZW4pXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhciBidWYgPSBXcml0ZXIuYWxsb2MobGVuID0gYmFzZTY0Lmxlbmd0aCh2YWx1ZSkpO1xuICAgICAgICBiYXNlNjQuZGVjb2RlKHZhbHVlLCBidWYsIDApO1xuICAgICAgICB2YWx1ZSA9IGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoKHZhbHVlKTtcbiAgICByZXR1cm4gbGVuXG4gICAgICAgID8gdGhpcy51aW50MzIobGVuKS5fcHVzaCh1dGY4LndyaXRlLCBsZW4sIHZhbHVlKVxuICAgICAgICA6IHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbn07XG5cbi8qKlxuICogRm9ya3MgdGhpcyB3cml0ZXIncyBzdGF0ZSBieSBwdXNoaW5nIGl0IHRvIGEgc3RhY2suXG4gKiBDYWxsaW5nIHtAbGluayBXcml0ZXIjcmVzZXR8cmVzZXR9IG9yIHtAbGluayBXcml0ZXIjbGRlbGltfGxkZWxpbX0gcmVzZXRzIHRoZSB3cml0ZXIgdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uIGZvcmsoKSB7XG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgIHRoaXMubGVuID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoaXMgaW5zdGFuY2UgdG8gdGhlIGxhc3Qgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlcykge1xuICAgICAgICB0aGlzLmhlYWQgICA9IHRoaXMuc3RhdGVzLmhlYWQ7XG4gICAgICAgIHRoaXMudGFpbCAgID0gdGhpcy5zdGF0ZXMudGFpbDtcbiAgICAgICAgdGhpcy5sZW4gICAgPSB0aGlzLnN0YXRlcy5sZW47XG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICAgIHRoaXMubGVuICA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdG8gdGhlIGxhc3Qgc3RhdGUgYW5kIGFwcGVuZHMgdGhlIGZvcmsgc3RhdGUncyBjdXJyZW50IHdyaXRlIGxlbmd0aCBhcyBhIHZhcmludCBmb2xsb3dlZCBieSBpdHMgb3BlcmF0aW9ucy5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmxkZWxpbSA9IGZ1bmN0aW9uIGxkZWxpbSgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZCxcbiAgICAgICAgdGFpbCA9IHRoaXMudGFpbCxcbiAgICAgICAgbGVuICA9IHRoaXMubGVuO1xuICAgIHRoaXMucmVzZXQoKS51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gaGVhZC5uZXh0OyAvLyBza2lwIG5vb3BcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgLy8gc2tpcCBub29wXG4gICAgICAgIGJ1ZiAgPSB0aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxcbiAgICAgICAgcG9zICA9IDA7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5mbihoZWFkLnZhbCwgYnVmLCBwb3MpO1xuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIC8vIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyV3JpdGVyXykge1xuICAgIEJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcl87XG4gICAgV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcblxuLy8gZXh0ZW5kcyBXcml0ZXJcbnZhciBXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG4oQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XG4gICAgV3JpdGVyLmNhbGwodGhpcyk7XG59XG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXJcbiAgICAgKi9cbiAgICBCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmU7XG5cbiAgICBCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciA9IHV0aWwuQnVmZmVyICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlLnNldC5uYW1lID09PSBcInNldFwiXG4gICAgICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBmYXN0ZXIgdGhhbiBjb3B5IChyZXF1aXJlcyBub2RlID49IDQgd2hlcmUgQnVmZmVycyBleHRlbmQgVWludDhBcnJheSBhbmQgc2V0IGlzIHByb3Blcmx5IGluaGVyaXRlZClcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb3B5KSAvLyBCdWZmZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgIGJ1Zltwb3MrK10gPSB2YWxbaSsrXTtcbiAgICAgICAgfTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB1dGlsLl9CdWZmZXJfZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVTdHJpbmdCdWZmZXIodmFsLCBidWYsIHBvcykge1xuICAgIGlmICh2YWwubGVuZ3RoIDwgNDApIC8vIHBsYWluIGpzIGlzIGZhc3RlciBmb3Igc2hvcnQgc3RyaW5ncyAocHJvYmFibHkgZHVlIHRvIHJlZHVuZGFudCBhc3NlcnRpb25zKVxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XG4gICAgZWxzZSBpZiAoYnVmLnV0ZjhXcml0ZSlcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XG4gICAgZWxzZVxuICAgICAgICBidWYud3JpdGUodmFsLCBwb3MpO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZ19idWZmZXIodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRpbC5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlU3RyaW5nQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZWFkYWJsZSA9PiB7XG4gIC8vIE5vZGUuanMgc3RyZWFtXG4gIGlmIChyZWFkYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHJldHVybiByZWFkYWJsZVxuXG4gIC8vIEJyb3dzZXIgUmVhZGFibGVTdHJlYW1cbiAgaWYgKHJlYWRhYmxlLmdldFJlYWRlcikge1xuICAgIHJldHVybiAoYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZS5nZXRSZWFkZXIoKVxuXG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICAgICAgeWllbGQgdmFsdWVcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKClcbiAgICAgIH1cbiAgICB9KSgpXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gc3RyZWFtJylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVhZFxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHJlcyAgICA9IDBcbiAgICAsIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gICAgLCBzaGlmdCAgPSAwXG4gICAgLCBjb3VudGVyID0gb2Zmc2V0XG4gICAgLCBiXG4gICAgLCBsID0gYnVmLmxlbmd0aFxuXG4gIGRvIHtcbiAgICBpZiAoY291bnRlciA+PSBsIHx8IHNoaWZ0ID4gNDkpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGRlY29kZSB2YXJpbnQnKVxuICAgIH1cbiAgICBiID0gYnVmW2NvdW50ZXIrK11cbiAgICByZXMgKz0gc2hpZnQgPCAyOFxuICAgICAgPyAoYiAmIFJFU1QpIDw8IHNoaWZ0XG4gICAgICA6IChiICYgUkVTVCkgKiBNYXRoLnBvdygyLCBzaGlmdClcbiAgICBzaGlmdCArPSA3XG4gIH0gd2hpbGUgKGIgPj0gTVNCKVxuXG4gIHJlYWQuYnl0ZXMgPSBjb3VudGVyIC0gb2Zmc2V0XG5cbiAgcmV0dXJuIHJlc1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuICAsIE1TQkFMTCA9IH5SRVNUXG4gICwgSU5UID0gTWF0aC5wb3coMiwgMzEpXG5cbmZ1bmN0aW9uIGVuY29kZShudW0sIG91dCwgb2Zmc2V0KSB7XG4gIGlmIChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiBudW0gPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgIGVuY29kZS5ieXRlcyA9IDBcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGVuY29kZSB2YXJpbnQnKVxuICB9XG4gIG91dCA9IG91dCB8fCBbXVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG5cbiAgd2hpbGUobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gLz0gMTI4XG4gIH1cbiAgd2hpbGUobnVtICYgTVNCQUxMKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSA+Pj49IDdcbiAgfVxuICBvdXRbb2Zmc2V0XSA9IG51bSB8IDBcbiAgXG4gIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldCArIDFcbiAgXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVuY29kZTogcmVxdWlyZSgnLi9lbmNvZGUuanMnKVxuICAsIGRlY29kZTogcmVxdWlyZSgnLi9kZWNvZGUuanMnKVxuICAsIGVuY29kaW5nTGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aC5qcycpXG59XG4iLCJcbnZhciBOMSA9IE1hdGgucG93KDIsICA3KVxudmFyIE4yID0gTWF0aC5wb3coMiwgMTQpXG52YXIgTjMgPSBNYXRoLnBvdygyLCAyMSlcbnZhciBONCA9IE1hdGgucG93KDIsIDI4KVxudmFyIE41ID0gTWF0aC5wb3coMiwgMzUpXG52YXIgTjYgPSBNYXRoLnBvdygyLCA0MilcbnZhciBONyA9IE1hdGgucG93KDIsIDQ5KVxudmFyIE44ID0gTWF0aC5wb3coMiwgNTYpXG52YXIgTjkgPSBNYXRoLnBvdygyLCA2MylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA8IE4xID8gMVxuICA6IHZhbHVlIDwgTjIgPyAyXG4gIDogdmFsdWUgPCBOMyA/IDNcbiAgOiB2YWx1ZSA8IE40ID8gNFxuICA6IHZhbHVlIDwgTjUgPyA1XG4gIDogdmFsdWUgPCBONiA/IDZcbiAgOiB2YWx1ZSA8IE43ID8gN1xuICA6IHZhbHVlIDwgTjggPyA4XG4gIDogdmFsdWUgPCBOOSA/IDlcbiAgOiAgICAgICAgICAgICAgMTBcbiAgKVxufVxuIiwiaW1wb3J0ICogYXMgY2JvcmcgZnJvbSAnY2JvcmcnO1xuaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5jb25zdCBDSURfQ0JPUl9UQUcgPSA0MjtcbmZ1bmN0aW9uIGNpZEVuY29kZXIob2JqKSB7XG4gIGlmIChvYmouYXNDSUQgIT09IG9iaikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNpZCA9IENJRC5hc0NJRChvYmopO1xuICBpZiAoIWNpZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY2lkLmJ5dGVzLmJ5dGVMZW5ndGggKyAxKTtcbiAgYnl0ZXMuc2V0KGNpZC5ieXRlcywgMSk7XG4gIHJldHVybiBbXG4gICAgbmV3IGNib3JnLlRva2VuKGNib3JnLlR5cGUudGFnLCBDSURfQ0JPUl9UQUcpLFxuICAgIG5ldyBjYm9yZy5Ub2tlbihjYm9yZy5UeXBlLmJ5dGVzLCBieXRlcylcbiAgXTtcbn1cbmZ1bmN0aW9uIHVuZGVmaW5lZEVuY29kZXIoKSB7XG4gIHRocm93IG5ldyBFcnJvcignYHVuZGVmaW5lZGAgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgSVBMRCBEYXRhIE1vZGVsIGFuZCBjYW5ub3QgYmUgZW5jb2RlZCcpO1xufVxuZnVuY3Rpb24gbnVtYmVyRW5jb2RlcihudW0pIHtcbiAgaWYgKE51bWJlci5pc05hTihudW0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgTmFOYCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBJUExEIERhdGEgTW9kZWwgYW5kIGNhbm5vdCBiZSBlbmNvZGVkJyk7XG4gIH1cbiAgaWYgKG51bSA9PT0gSW5maW5pdHkgfHwgbnVtID09PSAtSW5maW5pdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BJbmZpbml0eWAgYW5kIGAtSW5maW5pdHlgIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIElQTEQgRGF0YSBNb2RlbCBhbmQgY2Fubm90IGJlIGVuY29kZWQnKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IGVuY29kZU9wdGlvbnMgPSB7XG4gIGZsb2F0NjQ6IHRydWUsXG4gIHR5cGVFbmNvZGVyczoge1xuICAgIE9iamVjdDogY2lkRW5jb2RlcixcbiAgICB1bmRlZmluZWQ6IHVuZGVmaW5lZEVuY29kZXIsXG4gICAgbnVtYmVyOiBudW1iZXJFbmNvZGVyXG4gIH1cbn07XG5mdW5jdGlvbiBjaWREZWNvZGVyKGJ5dGVzKSB7XG4gIGlmIChieXRlc1swXSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDSUQgZm9yIENCT1IgdGFnIDQyOyBleHBlY3RlZCBsZWFkaW5nIDB4MDAnKTtcbiAgfVxuICByZXR1cm4gQ0lELmRlY29kZShieXRlcy5zdWJhcnJheSgxKSk7XG59XG5jb25zdCBkZWNvZGVPcHRpb25zID0ge1xuICBhbGxvd0luZGVmaW5pdGU6IGZhbHNlLFxuICBhbGxvd1VuZGVmaW5lZDogZmFsc2UsXG4gIGFsbG93TmFOOiBmYWxzZSxcbiAgYWxsb3dJbmZpbml0eTogZmFsc2UsXG4gIGFsbG93QmlnSW50OiB0cnVlLFxuICBzdHJpY3Q6IHRydWUsXG4gIHVzZU1hcHM6IGZhbHNlLFxuICB0YWdzOiBbXVxufTtcbmRlY29kZU9wdGlvbnMudGFnc1tDSURfQ0JPUl9UQUddID0gY2lkRGVjb2RlcjtcbmV4cG9ydCBjb25zdCBuYW1lID0gJ2RhZy1jYm9yJztcbmV4cG9ydCBjb25zdCBjb2RlID0gMTEzO1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IG5vZGUgPT4gY2JvcmcuZW5jb2RlKG5vZGUsIGVuY29kZU9wdGlvbnMpO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGRhdGEgPT4gY2JvcmcuZGVjb2RlKGRhdGEsIGRlY29kZU9wdGlvbnMpOyIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgZGVjb2RlTm9kZSB9IGZyb20gJy4vcGItZGVjb2RlLmpzJztcbmltcG9ydCB7IGVuY29kZU5vZGUgfSBmcm9tICcuL3BiLWVuY29kZS5qcyc7XG5pbXBvcnQge1xuICBwcmVwYXJlLFxuICB2YWxpZGF0ZSxcbiAgY3JlYXRlTm9kZSxcbiAgY3JlYXRlTGlua1xufSBmcm9tICcuL3V0aWwuanMnO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSAnZGFnLXBiJztcbmV4cG9ydCBjb25zdCBjb2RlID0gMTEyO1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShub2RlKSB7XG4gIHZhbGlkYXRlKG5vZGUpO1xuICBjb25zdCBwYm4gPSB7fTtcbiAgaWYgKG5vZGUuTGlua3MpIHtcbiAgICBwYm4uTGlua3MgPSBub2RlLkxpbmtzLm1hcChsID0+IHtcbiAgICAgIGNvbnN0IGxpbmsgPSB7fTtcbiAgICAgIGlmIChsLkhhc2gpIHtcbiAgICAgICAgbGluay5IYXNoID0gbC5IYXNoLmJ5dGVzO1xuICAgICAgfVxuICAgICAgaWYgKGwuTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbmsuTmFtZSA9IGwuTmFtZTtcbiAgICAgIH1cbiAgICAgIGlmIChsLlRzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGluay5Uc2l6ZSA9IGwuVHNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluaztcbiAgICB9KTtcbiAgfVxuICBpZiAobm9kZS5EYXRhKSB7XG4gICAgcGJuLkRhdGEgPSBub2RlLkRhdGE7XG4gIH1cbiAgcmV0dXJuIGVuY29kZU5vZGUocGJuKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoYnl0ZXMpIHtcbiAgY29uc3QgcGJuID0gZGVjb2RlTm9kZShieXRlcyk7XG4gIGNvbnN0IG5vZGUgPSB7fTtcbiAgaWYgKHBibi5EYXRhKSB7XG4gICAgbm9kZS5EYXRhID0gcGJuLkRhdGE7XG4gIH1cbiAgaWYgKHBibi5MaW5rcykge1xuICAgIG5vZGUuTGlua3MgPSBwYm4uTGlua3MubWFwKGwgPT4ge1xuICAgICAgY29uc3QgbGluayA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGluay5IYXNoID0gQ0lELmRlY29kZShsLkhhc2gpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgaWYgKCFsaW5rLkhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEhhc2ggZmllbGQgZm91bmQgaW4gbGluaywgZXhwZWN0ZWQgQ0lEJyk7XG4gICAgICB9XG4gICAgICBpZiAobC5OYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGluay5OYW1lID0gbC5OYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGwuVHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW5rLlRzaXplID0gbC5Uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5rO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZXhwb3J0IHtcbiAgcHJlcGFyZSxcbiAgdmFsaWRhdGUsXG4gIGNyZWF0ZU5vZGUsXG4gIGNyZWF0ZUxpbmtcbn07IiwiY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmZ1bmN0aW9uIGRlY29kZVZhcmludChieXRlcywgb2Zmc2V0KSB7XG4gIGxldCB2ID0gMDtcbiAgZm9yIChsZXQgc2hpZnQgPSAwOzsgc2hpZnQgKz0gNykge1xuICAgIGlmIChzaGlmdCA+PSA2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogdmFyaW50IG92ZXJmbG93Jyk7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3RvYnVmOiB1bmV4cGVjdGVkIGVuZCBvZiBkYXRhJyk7XG4gICAgfVxuICAgIGNvbnN0IGIgPSBieXRlc1tvZmZzZXQrK107XG4gICAgdiArPSBzaGlmdCA8IDI4ID8gKGIgJiAxMjcpIDw8IHNoaWZ0IDogKGIgJiAxMjcpICogMiAqKiBzaGlmdDtcbiAgICBpZiAoYiA8IDEyOCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBbXG4gICAgdixcbiAgICBvZmZzZXRcbiAgXTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJ5dGVzKGJ5dGVzLCBvZmZzZXQpIHtcbiAgbGV0IGJ5dGVMZW47XG4gIFtieXRlTGVuLCBvZmZzZXRdID0gZGVjb2RlVmFyaW50KGJ5dGVzLCBvZmZzZXQpO1xuICBjb25zdCBwb3N0T2Zmc2V0ID0gb2Zmc2V0ICsgYnl0ZUxlbjtcbiAgaWYgKGJ5dGVMZW4gPCAwIHx8IHBvc3RPZmZzZXQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogaW52YWxpZCBsZW5ndGgnKTtcbiAgfVxuICBpZiAocG9zdE9mZnNldCA+IGJ5dGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IHVuZXhwZWN0ZWQgZW5kIG9mIGRhdGEnKTtcbiAgfVxuICByZXR1cm4gW1xuICAgIGJ5dGVzLnN1YmFycmF5KG9mZnNldCwgcG9zdE9mZnNldCksXG4gICAgcG9zdE9mZnNldFxuICBdO1xufVxuZnVuY3Rpb24gZGVjb2RlS2V5KGJ5dGVzLCBpbmRleCkge1xuICBsZXQgd2lyZTtcbiAgW3dpcmUsIGluZGV4XSA9IGRlY29kZVZhcmludChieXRlcywgaW5kZXgpO1xuICByZXR1cm4gW1xuICAgIHdpcmUgJiA3LFxuICAgIHdpcmUgPj4gMyxcbiAgICBpbmRleFxuICBdO1xufVxuZnVuY3Rpb24gZGVjb2RlTGluayhieXRlcykge1xuICBjb25zdCBsaW5rID0ge307XG4gIGNvbnN0IGwgPSBieXRlcy5sZW5ndGg7XG4gIGxldCBpbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IGwpIHtcbiAgICBsZXQgd2lyZVR5cGUsIGZpZWxkTnVtO1xuICAgIFt3aXJlVHlwZSwgZmllbGROdW0sIGluZGV4XSA9IGRlY29kZUtleShieXRlcywgaW5kZXgpO1xuICAgIGlmIChmaWVsZE51bSA9PT0gMSkge1xuICAgICAgaWYgKGxpbmsuSGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3RvYnVmOiAoUEJMaW5rKSBkdXBsaWNhdGUgSGFzaCBzZWN0aW9uJyk7XG4gICAgICB9XG4gICAgICBpZiAod2lyZVR5cGUgIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcm90b2J1ZjogKFBCTGluaykgd3Jvbmcgd2lyZVR5cGUgKCR7IHdpcmVUeXBlIH0pIGZvciBIYXNoYCk7XG4gICAgICB9XG4gICAgICBpZiAobGluay5OYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTGluaykgaW52YWxpZCBvcmRlciwgZm91bmQgTmFtZSBiZWZvcmUgSGFzaCcpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmsuVHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3RvYnVmOiAoUEJMaW5rKSBpbnZhbGlkIG9yZGVyLCBmb3VuZCBUc2l6ZSBiZWZvcmUgSGFzaCcpO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgW2xpbmsuSGFzaCwgaW5kZXhdID0gZGVjb2RlQnl0ZXMoYnl0ZXMsIGluZGV4KTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkTnVtID09PSAyKSB7XG4gICAgICBpZiAobGluay5OYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTGluaykgZHVwbGljYXRlIE5hbWUgc2VjdGlvbicpO1xuICAgICAgfVxuICAgICAgaWYgKHdpcmVUeXBlICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJvdG9idWY6IChQQkxpbmspIHdyb25nIHdpcmVUeXBlICgkeyB3aXJlVHlwZSB9KSBmb3IgTmFtZWApO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmsuVHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3RvYnVmOiAoUEJMaW5rKSBpbnZhbGlkIG9yZGVyLCBmb3VuZCBUc2l6ZSBiZWZvcmUgTmFtZScpO1xuICAgICAgfVxuICAgICAgbGV0IGJ5dHM7XG4gICAgICBbYnl0cywgaW5kZXhdID0gZGVjb2RlQnl0ZXMoYnl0ZXMsIGluZGV4KTtcbiAgICAgIGxpbmsuTmFtZSA9IHRleHREZWNvZGVyLmRlY29kZShieXRzKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkTnVtID09PSAzKSB7XG4gICAgICBpZiAobGluay5Uc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IChQQkxpbmspIGR1cGxpY2F0ZSBUc2l6ZSBzZWN0aW9uJyk7XG4gICAgICB9XG4gICAgICBpZiAod2lyZVR5cGUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcm90b2J1ZjogKFBCTGluaykgd3Jvbmcgd2lyZVR5cGUgKCR7IHdpcmVUeXBlIH0pIGZvciBUc2l6ZWApO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgW2xpbmsuVHNpemUsIGluZGV4XSA9IGRlY29kZVZhcmludChieXRlcywgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHByb3RvYnVmOiAoUEJMaW5rKSBpbnZhbGlkIGZpZWxkTnVtYmVyLCBleHBlY3RlZCAxLCAyIG9yIDMsIGdvdCAkeyBmaWVsZE51bSB9YCk7XG4gICAgfVxuICB9XG4gIGlmIChpbmRleCA+IGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3RvYnVmOiAoUEJMaW5rKSB1bmV4cGVjdGVkIGVuZCBvZiBkYXRhJyk7XG4gIH1cbiAgcmV0dXJuIGxpbms7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTm9kZShieXRlcykge1xuICBjb25zdCBsID0gYnl0ZXMubGVuZ3RoO1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgbGlua3M7XG4gIGxldCBsaW5rc0JlZm9yZURhdGEgPSBmYWxzZTtcbiAgbGV0IGRhdGE7XG4gIHdoaWxlIChpbmRleCA8IGwpIHtcbiAgICBsZXQgd2lyZVR5cGUsIGZpZWxkTnVtO1xuICAgIFt3aXJlVHlwZSwgZmllbGROdW0sIGluZGV4XSA9IGRlY29kZUtleShieXRlcywgaW5kZXgpO1xuICAgIGlmICh3aXJlVHlwZSAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcm90b2J1ZjogKFBCTm9kZSkgaW52YWxpZCB3aXJlVHlwZSwgZXhwZWN0ZWQgMiwgZ290ICR7IHdpcmVUeXBlIH1gKTtcbiAgICB9XG4gICAgaWYgKGZpZWxkTnVtID09PSAxKSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3RvYnVmOiAoUEJOb2RlKSBkdXBsaWNhdGUgRGF0YSBzZWN0aW9uJyk7XG4gICAgICB9XG4gICAgICA7XG4gICAgICBbZGF0YSwgaW5kZXhdID0gZGVjb2RlQnl0ZXMoYnl0ZXMsIGluZGV4KTtcbiAgICAgIGlmIChsaW5rcykge1xuICAgICAgICBsaW5rc0JlZm9yZURhdGEgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmllbGROdW0gPT09IDIpIHtcbiAgICAgIGlmIChsaW5rc0JlZm9yZURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTm9kZSkgZHVwbGljYXRlIExpbmtzIHNlY3Rpb24nKTtcbiAgICAgIH0gZWxzZSBpZiAoIWxpbmtzKSB7XG4gICAgICAgIGxpbmtzID0gW107XG4gICAgICB9XG4gICAgICBsZXQgYnl0cztcbiAgICAgIFtieXRzLCBpbmRleF0gPSBkZWNvZGVCeXRlcyhieXRlcywgaW5kZXgpO1xuICAgICAgbGlua3MucHVzaChkZWNvZGVMaW5rKGJ5dHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcm90b2J1ZjogKFBCTm9kZSkgaW52YWxpZCBmaWVsZE51bWJlciwgZXhwZWN0ZWQgMSBvciAyLCBnb3QgJHsgZmllbGROdW0gfWApO1xuICAgIH1cbiAgfVxuICBpZiAoaW5kZXggPiBsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTm9kZSkgdW5leHBlY3RlZCBlbmQgb2YgZGF0YScpO1xuICB9XG4gIGNvbnN0IG5vZGUgPSB7fTtcbiAgaWYgKGRhdGEpIHtcbiAgICBub2RlLkRhdGEgPSBkYXRhO1xuICB9XG4gIG5vZGUuTGlua3MgPSBsaW5rcyB8fCBbXTtcbiAgcmV0dXJuIG5vZGU7XG59IiwiY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmNvbnN0IG1heEludDMyID0gMiAqKiAzMjtcbmNvbnN0IG1heFVJbnQzMiA9IDIgKiogMzE7XG5mdW5jdGlvbiBlbmNvZGVMaW5rKGxpbmssIGJ5dGVzKSB7XG4gIGxldCBpID0gYnl0ZXMubGVuZ3RoO1xuICBpZiAodHlwZW9mIGxpbmsuVHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKGxpbmsuVHNpemUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RzaXplIGNhbm5vdCBiZSBuZWdhdGl2ZScpO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGxpbmsuVHNpemUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RzaXplIHRvbyBsYXJnZSBmb3IgZW5jb2RpbmcnKTtcbiAgICB9XG4gICAgaSA9IGVuY29kZVZhcmludChieXRlcywgaSwgbGluay5Uc2l6ZSkgLSAxO1xuICAgIGJ5dGVzW2ldID0gMjQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBsaW5rLk5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbmFtZUJ5dGVzID0gdGV4dEVuY29kZXIuZW5jb2RlKGxpbmsuTmFtZSk7XG4gICAgaSAtPSBuYW1lQnl0ZXMubGVuZ3RoO1xuICAgIGJ5dGVzLnNldChuYW1lQnl0ZXMsIGkpO1xuICAgIGkgPSBlbmNvZGVWYXJpbnQoYnl0ZXMsIGksIG5hbWVCeXRlcy5sZW5ndGgpIC0gMTtcbiAgICBieXRlc1tpXSA9IDE4O1xuICB9XG4gIGlmIChsaW5rLkhhc2gpIHtcbiAgICBpIC09IGxpbmsuSGFzaC5sZW5ndGg7XG4gICAgYnl0ZXMuc2V0KGxpbmsuSGFzaCwgaSk7XG4gICAgaSA9IGVuY29kZVZhcmludChieXRlcywgaSwgbGluay5IYXNoLmxlbmd0aCkgLSAxO1xuICAgIGJ5dGVzW2ldID0gMTA7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIGk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlTm9kZShub2RlKSB7XG4gIGNvbnN0IHNpemUgPSBzaXplTm9kZShub2RlKTtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgbGV0IGkgPSBzaXplO1xuICBpZiAobm9kZS5EYXRhKSB7XG4gICAgaSAtPSBub2RlLkRhdGEubGVuZ3RoO1xuICAgIGJ5dGVzLnNldChub2RlLkRhdGEsIGkpO1xuICAgIGkgPSBlbmNvZGVWYXJpbnQoYnl0ZXMsIGksIG5vZGUuRGF0YS5sZW5ndGgpIC0gMTtcbiAgICBieXRlc1tpXSA9IDEwO1xuICB9XG4gIGlmIChub2RlLkxpbmtzKSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSBub2RlLkxpbmtzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgIGNvbnN0IHNpemUgPSBlbmNvZGVMaW5rKG5vZGUuTGlua3NbaW5kZXhdLCBieXRlcy5zdWJhcnJheSgwLCBpKSk7XG4gICAgICBpIC09IHNpemU7XG4gICAgICBpID0gZW5jb2RlVmFyaW50KGJ5dGVzLCBpLCBzaXplKSAtIDE7XG4gICAgICBieXRlc1tpXSA9IDE4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBzaXplTGluayhsaW5rKSB7XG4gIGxldCBuID0gMDtcbiAgaWYgKGxpbmsuSGFzaCkge1xuICAgIGNvbnN0IGwgPSBsaW5rLkhhc2gubGVuZ3RoO1xuICAgIG4gKz0gMSArIGwgKyBzb3YobCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBsaW5rLk5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbCA9IHRleHRFbmNvZGVyLmVuY29kZShsaW5rLk5hbWUpLmxlbmd0aDtcbiAgICBuICs9IDEgKyBsICsgc292KGwpO1xuICB9XG4gIGlmICh0eXBlb2YgbGluay5Uc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICBuICs9IDEgKyBzb3YobGluay5Uc2l6ZSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBzaXplTm9kZShub2RlKSB7XG4gIGxldCBuID0gMDtcbiAgaWYgKG5vZGUuRGF0YSkge1xuICAgIGNvbnN0IGwgPSBub2RlLkRhdGEubGVuZ3RoO1xuICAgIG4gKz0gMSArIGwgKyBzb3YobCk7XG4gIH1cbiAgaWYgKG5vZGUuTGlua3MpIHtcbiAgICBmb3IgKGNvbnN0IGxpbmsgb2Ygbm9kZS5MaW5rcykge1xuICAgICAgY29uc3QgbCA9IHNpemVMaW5rKGxpbmspO1xuICAgICAgbiArPSAxICsgbCArIHNvdihsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBlbmNvZGVWYXJpbnQoYnl0ZXMsIG9mZnNldCwgdikge1xuICBvZmZzZXQgLT0gc292KHYpO1xuICBjb25zdCBiYXNlID0gb2Zmc2V0O1xuICB3aGlsZSAodiA+PSBtYXhVSW50MzIpIHtcbiAgICBieXRlc1tvZmZzZXQrK10gPSB2ICYgMTI3IHwgMTI4O1xuICAgIHYgLz0gMTI4O1xuICB9XG4gIHdoaWxlICh2ID49IDEyOCkge1xuICAgIGJ5dGVzW29mZnNldCsrXSA9IHYgJiAxMjcgfCAxMjg7XG4gICAgdiA+Pj49IDc7XG4gIH1cbiAgYnl0ZXNbb2Zmc2V0XSA9IHY7XG4gIHJldHVybiBiYXNlO1xufVxuZnVuY3Rpb24gc292KHgpIHtcbiAgaWYgKHggJSAyID09PSAwKSB7XG4gICAgeCsrO1xuICB9XG4gIHJldHVybiBNYXRoLmZsb29yKChsZW42NCh4KSArIDYpIC8gNyk7XG59XG5mdW5jdGlvbiBsZW42NCh4KSB7XG4gIGxldCBuID0gMDtcbiAgaWYgKHggPj0gbWF4SW50MzIpIHtcbiAgICB4ID0gTWF0aC5mbG9vcih4IC8gbWF4SW50MzIpO1xuICAgIG4gPSAzMjtcbiAgfVxuICBpZiAoeCA+PSAxIDw8IDE2KSB7XG4gICAgeCA+Pj49IDE2O1xuICAgIG4gKz0gMTY7XG4gIH1cbiAgaWYgKHggPj0gMSA8PCA4KSB7XG4gICAgeCA+Pj49IDg7XG4gICAgbiArPSA4O1xuICB9XG4gIHJldHVybiBuICsgbGVuOHRhYlt4XTtcbn1cbmNvbnN0IGxlbjh0YWIgPSBbXG4gIDAsXG4gIDEsXG4gIDIsXG4gIDIsXG4gIDMsXG4gIDMsXG4gIDMsXG4gIDMsXG4gIDQsXG4gIDQsXG4gIDQsXG4gIDQsXG4gIDQsXG4gIDQsXG4gIDQsXG4gIDQsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDUsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDYsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDcsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDgsXG4gIDhcbl07IiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5jb25zdCBwYk5vZGVQcm9wZXJ0aWVzID0gW1xuICAnRGF0YScsXG4gICdMaW5rcydcbl07XG5jb25zdCBwYkxpbmtQcm9wZXJ0aWVzID0gW1xuICAnSGFzaCcsXG4gICdOYW1lJyxcbiAgJ1RzaXplJ1xuXTtcbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBsaW5rQ29tcGFyYXRvcihhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgYWJ1ZiA9IGEuTmFtZSA/IHRleHRFbmNvZGVyLmVuY29kZShhLk5hbWUpIDogW107XG4gIGNvbnN0IGJidWYgPSBiLk5hbWUgPyB0ZXh0RW5jb2Rlci5lbmNvZGUoYi5OYW1lKSA6IFtdO1xuICBsZXQgeCA9IGFidWYubGVuZ3RoO1xuICBsZXQgeSA9IGJidWYubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhYnVmW2ldICE9PSBiYnVmW2ldKSB7XG4gICAgICB4ID0gYWJ1ZltpXTtcbiAgICAgIHkgPSBiYnVmW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB4IDwgeSA/IC0xIDogeSA8IHggPyAxIDogMDtcbn1cbmZ1bmN0aW9uIGhhc09ubHlQcm9wZXJ0aWVzKG5vZGUsIHByb3BlcnRpZXMpIHtcbiAgcmV0dXJuICFPYmplY3Qua2V5cyhub2RlKS5zb21lKHAgPT4gIXByb3BlcnRpZXMuaW5jbHVkZXMocCkpO1xufVxuZnVuY3Rpb24gYXNMaW5rKGxpbmspIHtcbiAgaWYgKHR5cGVvZiBsaW5rLmFzQ0lEID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IEhhc2ggPSBDSUQuYXNDSUQobGluayk7XG4gICAgaWYgKCFIYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtJyk7XG4gICAgfVxuICAgIHJldHVybiB7IEhhc2ggfTtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkobGluaykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtJyk7XG4gIH1cbiAgY29uc3QgcGJsID0ge307XG4gIGlmIChsaW5rLkhhc2gpIHtcbiAgICBsZXQgY2lkID0gQ0lELmFzQ0lEKGxpbmsuSGFzaCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghY2lkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGluay5IYXNoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNpZCA9IENJRC5wYXJzZShsaW5rLkhhc2gpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmsuSGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICBjaWQgPSBDSUQuZGVjb2RlKGxpbmsuSGFzaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIERBRy1QQiBmb3JtOiAkeyBlLm1lc3NhZ2UgfWApO1xuICAgIH1cbiAgICBpZiAoY2lkKSB7XG4gICAgICBwYmwuSGFzaCA9IGNpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCFwYmwuSGFzaCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0nKTtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsuTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBwYmwuTmFtZSA9IGxpbmsuTmFtZTtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsuVHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgcGJsLlRzaXplID0gbGluay5Uc2l6ZTtcbiAgfVxuICByZXR1cm4gcGJsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmUobm9kZSkge1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgbm9kZSA9IHsgRGF0YTogbm9kZSB9O1xuICB9XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0nKTtcbiAgfVxuICBjb25zdCBwYm4gPSB7fTtcbiAgaWYgKG5vZGUuRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlLkRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYm4uRGF0YSA9IHRleHRFbmNvZGVyLmVuY29kZShub2RlLkRhdGEpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5EYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcGJuLkRhdGEgPSBub2RlLkRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0nKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUuTGlua3MgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUuTGlua3MpKSB7XG4gICAgICBwYm4uTGlua3MgPSBub2RlLkxpbmtzLm1hcChhc0xpbmspO1xuICAgICAgcGJuLkxpbmtzLnNvcnQobGlua0NvbXBhcmF0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBibi5MaW5rcyA9IFtdO1xuICB9XG4gIHJldHVybiBwYm47XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSkge1xuICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtJyk7XG4gIH1cbiAgaWYgKCFoYXNPbmx5UHJvcGVydGllcyhub2RlLCBwYk5vZGVQcm9wZXJ0aWVzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGV4dHJhbmVvdXMgcHJvcGVydGllcyknKTtcbiAgfVxuICBpZiAobm9kZS5EYXRhICE9PSB1bmRlZmluZWQgJiYgIShub2RlLkRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKERhdGEgbXVzdCBiZSBhIFVpbnQ4QXJyYXkpJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUuTGlua3MpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBEQUctUEIgZm9ybSAoTGlua3MgbXVzdCBiZSBhbiBhcnJheSknKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuTGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5rID0gbm9kZS5MaW5rc1tpXTtcbiAgICBpZiAoIWxpbmsgfHwgdHlwZW9mIGxpbmsgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkobGluaykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGJhZCBsaW5rIG9iamVjdCknKTtcbiAgICB9XG4gICAgaWYgKCFoYXNPbmx5UHJvcGVydGllcyhsaW5rLCBwYkxpbmtQcm9wZXJ0aWVzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBEQUctUEIgZm9ybSAoZXh0cmFuZW91cyBwcm9wZXJ0aWVzIG9uIGxpbmsgb2JqZWN0KScpO1xuICAgIH1cbiAgICBpZiAoIWxpbmsuSGFzaCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBEQUctUEIgZm9ybSAobGluayBtdXN0IGhhdmUgYSBIYXNoKScpO1xuICAgIH1cbiAgICBpZiAobGluay5IYXNoLmFzQ0lEICE9PSBsaW5rLkhhc2gpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGxpbmsgSGFzaCBtdXN0IGJlIGEgQ0lEKScpO1xuICAgIH1cbiAgICBpZiAobGluay5OYW1lICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGxpbmsuTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGxpbmsgTmFtZSBtdXN0IGJlIGEgc3RyaW5nKScpO1xuICAgIH1cbiAgICBpZiAobGluay5Uc2l6ZSAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2YgbGluay5Uc2l6ZSAhPT0gJ251bWJlcicgfHwgbGluay5Uc2l6ZSAlIDEgIT09IDApKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtIChsaW5rIFRzaXplIG11c3QgYmUgYW4gaW50ZWdlciknKTtcbiAgICB9XG4gICAgaWYgKGkgPiAwICYmIGxpbmtDb21wYXJhdG9yKGxpbmssIG5vZGUuTGlua3NbaSAtIDFdKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGxpbmtzIG11c3QgYmUgc29ydGVkIGJ5IE5hbWUgYnl0ZXMpJyk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm9kZShkYXRhLCBsaW5rcyA9IFtdKSB7XG4gIHJldHVybiBwcmVwYXJlKHtcbiAgICBEYXRhOiBkYXRhLFxuICAgIExpbmtzOiBsaW5rc1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaW5rKG5hbWUsIHNpemUsIGNpZCkge1xuICByZXR1cm4gYXNMaW5rKHtcbiAgICBIYXNoOiBjaWQsXG4gICAgTmFtZTogbmFtZSxcbiAgICBUc2l6ZTogc2l6ZVxuICB9KTtcbn0iLCJpbXBvcnQgeyBlbmNvZGUgfSBmcm9tICcuL2xpYi9lbmNvZGUuanMnO1xuaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSAnLi9saWIvZGVjb2RlLmpzJztcbmltcG9ydCB7XG4gIFRva2VuLFxuICBUeXBlXG59IGZyb20gJy4vbGliL3Rva2VuLmpzJztcbmV4cG9ydCB7XG4gIGRlY29kZSxcbiAgZW5jb2RlLFxuICBUb2tlbixcbiAgVHlwZVxufTsiLCJpbXBvcnQge1xuICBUb2tlbixcbiAgVHlwZVxufSBmcm9tICcuL3Rva2VuLmpzJztcbmltcG9ydCB7XG4gIGRlY29kZUVyclByZWZpeCxcbiAgYXNzZXJ0RW5vdWdoRGF0YVxufSBmcm9tICcuL2NvbW1vbi5qcyc7XG5leHBvcnQgY29uc3QgdWludEJvdW5kYXJpZXMgPSBbXG4gIDI0LFxuICAyNTYsXG4gIDY1NTM2LFxuICA0Mjk0OTY3Mjk2LFxuICBCaWdJbnQoJzE4NDQ2NzQ0MDczNzA5NTUxNjE2Jylcbl07XG5leHBvcnQgZnVuY3Rpb24gcmVhZFVpbnQ4KGRhdGEsIG9mZnNldCwgb3B0aW9ucykge1xuICBhc3NlcnRFbm91Z2hEYXRhKGRhdGEsIG9mZnNldCwgMSk7XG4gIGNvbnN0IHZhbHVlID0gZGF0YVtvZmZzZXRdO1xuICBpZiAob3B0aW9ucy5zdHJpY3QgPT09IHRydWUgJiYgdmFsdWUgPCB1aW50Qm91bmRhcmllc1swXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gaW50ZWdlciBlbmNvZGVkIGluIG1vcmUgYnl0ZXMgdGhhbiBuZWNlc3NhcnkgKHN0cmljdCBkZWNvZGUpYCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVaW50MTYoZGF0YSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gIGFzc2VydEVub3VnaERhdGEoZGF0YSwgb2Zmc2V0LCAyKTtcbiAgY29uc3QgdmFsdWUgPSBkYXRhW29mZnNldF0gPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMV07XG4gIGlmIChvcHRpb25zLnN0cmljdCA9PT0gdHJ1ZSAmJiB2YWx1ZSA8IHVpbnRCb3VuZGFyaWVzWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBpbnRlZ2VyIGVuY29kZWQgaW4gbW9yZSBieXRlcyB0aGFuIG5lY2Vzc2FyeSAoc3RyaWN0IGRlY29kZSlgKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQsIG9wdGlvbnMpIHtcbiAgYXNzZXJ0RW5vdWdoRGF0YShkYXRhLCBvZmZzZXQsIDQpO1xuICBjb25zdCB2YWx1ZSA9IGRhdGFbb2Zmc2V0XSAqIDE2Nzc3MjE2ICsgKGRhdGFbb2Zmc2V0ICsgMV0gPDwgMTYpICsgKGRhdGFbb2Zmc2V0ICsgMl0gPDwgOCkgKyBkYXRhW29mZnNldCArIDNdO1xuICBpZiAob3B0aW9ucy5zdHJpY3QgPT09IHRydWUgJiYgdmFsdWUgPCB1aW50Qm91bmRhcmllc1syXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gaW50ZWdlciBlbmNvZGVkIGluIG1vcmUgYnl0ZXMgdGhhbiBuZWNlc3NhcnkgKHN0cmljdCBkZWNvZGUpYCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVaW50NjQoZGF0YSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gIGFzc2VydEVub3VnaERhdGEoZGF0YSwgb2Zmc2V0LCA4KTtcbiAgY29uc3QgaGkgPSBkYXRhW29mZnNldF0gKiAxNjc3NzIxNiArIChkYXRhW29mZnNldCArIDFdIDw8IDE2KSArIChkYXRhW29mZnNldCArIDJdIDw8IDgpICsgZGF0YVtvZmZzZXQgKyAzXTtcbiAgY29uc3QgbG8gPSBkYXRhW29mZnNldCArIDRdICogMTY3NzcyMTYgKyAoZGF0YVtvZmZzZXQgKyA1XSA8PCAxNikgKyAoZGF0YVtvZmZzZXQgKyA2XSA8PCA4KSArIGRhdGFbb2Zmc2V0ICsgN107XG4gIGNvbnN0IHZhbHVlID0gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pO1xuICBpZiAob3B0aW9ucy5zdHJpY3QgPT09IHRydWUgJiYgdmFsdWUgPCB1aW50Qm91bmRhcmllc1szXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gaW50ZWdlciBlbmNvZGVkIGluIG1vcmUgYnl0ZXMgdGhhbiBuZWNlc3NhcnkgKHN0cmljdCBkZWNvZGUpYCk7XG4gIH1cbiAgaWYgKHZhbHVlIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWxsb3dCaWdJbnQgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBpbnRlZ2VycyBvdXRzaWRlIG9mIHRoZSBzYWZlIGludGVnZXIgcmFuZ2UgYXJlIG5vdCBzdXBwb3J0ZWRgKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVVaW50OChkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFRva2VuKFR5cGUudWludCwgcmVhZFVpbnQ4KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCAyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVVaW50MTYoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLnVpbnQsIHJlYWRVaW50MTYoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIDMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVVpbnQzMihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFRva2VuKFR5cGUudWludCwgcmVhZFVpbnQzMihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSwgNSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVWludDY0KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS51aW50LCByZWFkVWludDY0KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCA5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVVaW50KGJ1ZiwgdG9rZW4pIHtcbiAgcmV0dXJuIGVuY29kZVVpbnRWYWx1ZShidWYsIDAsIHRva2VuLnZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVVaW50VmFsdWUoYnVmLCBtYWpvciwgdWludCkge1xuICBpZiAodWludCA8IHVpbnRCb3VuZGFyaWVzWzBdKSB7XG4gICAgY29uc3QgbnVpbnQgPSBOdW1iZXIodWludCk7XG4gICAgYnVmLnB1c2goW21ham9yIHwgbnVpbnRdKTtcbiAgfSBlbHNlIGlmICh1aW50IDwgdWludEJvdW5kYXJpZXNbMV0pIHtcbiAgICBjb25zdCBudWludCA9IE51bWJlcih1aW50KTtcbiAgICBidWYucHVzaChbXG4gICAgICBtYWpvciB8IDI0LFxuICAgICAgbnVpbnRcbiAgICBdKTtcbiAgfSBlbHNlIGlmICh1aW50IDwgdWludEJvdW5kYXJpZXNbMl0pIHtcbiAgICBjb25zdCBudWludCA9IE51bWJlcih1aW50KTtcbiAgICBidWYucHVzaChbXG4gICAgICBtYWpvciB8IDI1LFxuICAgICAgbnVpbnQgPj4+IDgsXG4gICAgICBudWludCAmIDI1NVxuICAgIF0pO1xuICB9IGVsc2UgaWYgKHVpbnQgPCB1aW50Qm91bmRhcmllc1szXSkge1xuICAgIGNvbnN0IG51aW50ID0gTnVtYmVyKHVpbnQpO1xuICAgIGJ1Zi5wdXNoKFtcbiAgICAgIG1ham9yIHwgMjYsXG4gICAgICBudWludCA+Pj4gMjQgJiAyNTUsXG4gICAgICBudWludCA+Pj4gMTYgJiAyNTUsXG4gICAgICBudWludCA+Pj4gOCAmIDI1NSxcbiAgICAgIG51aW50ICYgMjU1XG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnVpbnQgPSBCaWdJbnQodWludCk7XG4gICAgaWYgKGJ1aW50IDwgdWludEJvdW5kYXJpZXNbNF0pIHtcbiAgICAgIGNvbnN0IHNldCA9IFtcbiAgICAgICAgbWFqb3IgfCAyNyxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXTtcbiAgICAgIGxldCBsbyA9IE51bWJlcihidWludCAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7XG4gICAgICBsZXQgaGkgPSBOdW1iZXIoYnVpbnQgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7XG4gICAgICBzZXRbOF0gPSBsbyAmIDI1NTtcbiAgICAgIGxvID0gbG8gPj4gODtcbiAgICAgIHNldFs3XSA9IGxvICYgMjU1O1xuICAgICAgbG8gPSBsbyA+PiA4O1xuICAgICAgc2V0WzZdID0gbG8gJiAyNTU7XG4gICAgICBsbyA9IGxvID4+IDg7XG4gICAgICBzZXRbNV0gPSBsbyAmIDI1NTtcbiAgICAgIHNldFs0XSA9IGhpICYgMjU1O1xuICAgICAgaGkgPSBoaSA+PiA4O1xuICAgICAgc2V0WzNdID0gaGkgJiAyNTU7XG4gICAgICBoaSA9IGhpID4+IDg7XG4gICAgICBzZXRbMl0gPSBoaSAmIDI1NTtcbiAgICAgIGhpID0gaGkgPj4gODtcbiAgICAgIHNldFsxXSA9IGhpICYgMjU1O1xuICAgICAgYnVmLnB1c2goc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBlbmNvdW50ZXJlZCBCaWdJbnQgbGFyZ2VyIHRoYW4gYWxsb3dhYmxlIHJhbmdlYCk7XG4gICAgfVxuICB9XG59XG5lbmNvZGVVaW50LmVuY29kZWRTaXplID0gZnVuY3Rpb24gZW5jb2RlZFNpemUodG9rZW4pIHtcbiAgcmV0dXJuIGVuY29kZVVpbnRWYWx1ZS5lbmNvZGVkU2l6ZSh0b2tlbi52YWx1ZSk7XG59O1xuZW5jb2RlVWludFZhbHVlLmVuY29kZWRTaXplID0gZnVuY3Rpb24gZW5jb2RlZFNpemUodWludCkge1xuICBpZiAodWludCA8IHVpbnRCb3VuZGFyaWVzWzBdKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKHVpbnQgPCB1aW50Qm91bmRhcmllc1sxXSkge1xuICAgIHJldHVybiAyO1xuICB9XG4gIGlmICh1aW50IDwgdWludEJvdW5kYXJpZXNbMl0pIHtcbiAgICByZXR1cm4gMztcbiAgfVxuICBpZiAodWludCA8IHVpbnRCb3VuZGFyaWVzWzNdKSB7XG4gICAgcmV0dXJuIDU7XG4gIH1cbiAgcmV0dXJuIDk7XG59O1xuZW5jb2RlVWludC5jb21wYXJlVG9rZW5zID0gZnVuY3Rpb24gY29tcGFyZVRva2Vucyh0b2sxLCB0b2syKSB7XG4gIHJldHVybiB0b2sxLnZhbHVlIDwgdG9rMi52YWx1ZSA/IC0xIDogdG9rMS52YWx1ZSA+IHRvazIudmFsdWUgPyAxIDogMDtcbn07IiwiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQgKiBhcyB1aW50IGZyb20gJy4vMHVpbnQuanMnO1xuaW1wb3J0IHsgZGVjb2RlRXJyUHJlZml4IH0gZnJvbSAnLi9jb21tb24uanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5lZ2ludDgoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLm5lZ2ludCwgLTEgLSB1aW50LnJlYWRVaW50OChkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSwgMik7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTmVnaW50MTYoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLm5lZ2ludCwgLTEgLSB1aW50LnJlYWRVaW50MTYoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIDMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5lZ2ludDMyKGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS5uZWdpbnQsIC0xIC0gdWludC5yZWFkVWludDMyKGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCA1KTtcbn1cbmNvbnN0IG5lZzFiID0gQmlnSW50KC0xKTtcbmNvbnN0IHBvczFiID0gQmlnSW50KDEpO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5lZ2ludDY0KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IGludCA9IHVpbnQucmVhZFVpbnQ2NChkYXRhLCBwb3MgKyAxLCBvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBpbnQgIT09ICdiaWdpbnQnKSB7XG4gICAgY29uc3QgdmFsdWUgPSAtMSAtIGludDtcbiAgICBpZiAodmFsdWUgPj0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS5uZWdpbnQsIHZhbHVlLCA5KTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWxsb3dCaWdJbnQgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGludGVnZXJzIG91dHNpZGUgb2YgdGhlIHNhZmUgaW50ZWdlciByYW5nZSBhcmUgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS5uZWdpbnQsIG5lZzFiIC0gQmlnSW50KGludCksIDkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZU5lZ2ludChidWYsIHRva2VuKSB7XG4gIGNvbnN0IG5lZ2ludCA9IHRva2VuLnZhbHVlO1xuICBjb25zdCB1bnNpZ25lZCA9IHR5cGVvZiBuZWdpbnQgPT09ICdiaWdpbnQnID8gbmVnaW50ICogbmVnMWIgLSBwb3MxYiA6IG5lZ2ludCAqIC0xIC0gMTtcbiAgdWludC5lbmNvZGVVaW50VmFsdWUoYnVmLCB0b2tlbi50eXBlLm1ham9yRW5jb2RlZCwgdW5zaWduZWQpO1xufVxuZW5jb2RlTmVnaW50LmVuY29kZWRTaXplID0gZnVuY3Rpb24gZW5jb2RlZFNpemUodG9rZW4pIHtcbiAgY29uc3QgbmVnaW50ID0gdG9rZW4udmFsdWU7XG4gIGNvbnN0IHVuc2lnbmVkID0gdHlwZW9mIG5lZ2ludCA9PT0gJ2JpZ2ludCcgPyBuZWdpbnQgKiBuZWcxYiAtIHBvczFiIDogbmVnaW50ICogLTEgLSAxO1xuICBpZiAodW5zaWduZWQgPCB1aW50LnVpbnRCb3VuZGFyaWVzWzBdKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKHVuc2lnbmVkIDwgdWludC51aW50Qm91bmRhcmllc1sxXSkge1xuICAgIHJldHVybiAyO1xuICB9XG4gIGlmICh1bnNpZ25lZCA8IHVpbnQudWludEJvdW5kYXJpZXNbMl0pIHtcbiAgICByZXR1cm4gMztcbiAgfVxuICBpZiAodW5zaWduZWQgPCB1aW50LnVpbnRCb3VuZGFyaWVzWzNdKSB7XG4gICAgcmV0dXJuIDU7XG4gIH1cbiAgcmV0dXJuIDk7XG59O1xuZW5jb2RlTmVnaW50LmNvbXBhcmVUb2tlbnMgPSBmdW5jdGlvbiBjb21wYXJlVG9rZW5zKHRvazEsIHRvazIpIHtcbiAgcmV0dXJuIHRvazEudmFsdWUgPCB0b2syLnZhbHVlID8gMSA6IHRvazEudmFsdWUgPiB0b2syLnZhbHVlID8gLTEgOiAwO1xufTsiLCJpbXBvcnQge1xuICBUb2tlbixcbiAgVHlwZVxufSBmcm9tICcuL3Rva2VuLmpzJztcbmltcG9ydCB7XG4gIGFzc2VydEVub3VnaERhdGEsXG4gIGRlY29kZUVyclByZWZpeFxufSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQgKiBhcyB1aW50IGZyb20gJy4vMHVpbnQuanMnO1xuaW1wb3J0IHtcbiAgY29tcGFyZSxcbiAgZnJvbVN0cmluZyxcbiAgc2xpY2Vcbn0gZnJvbSAnLi9ieXRlLXV0aWxzLmpzJztcbmZ1bmN0aW9uIHRvVG9rZW4oZGF0YSwgcG9zLCBwcmVmaXgsIGxlbmd0aCkge1xuICBhc3NlcnRFbm91Z2hEYXRhKGRhdGEsIHBvcywgcHJlZml4ICsgbGVuZ3RoKTtcbiAgY29uc3QgYnVmID0gc2xpY2UoZGF0YSwgcG9zICsgcHJlZml4LCBwb3MgKyBwcmVmaXggKyBsZW5ndGgpO1xuICByZXR1cm4gbmV3IFRva2VuKFR5cGUuYnl0ZXMsIGJ1ZiwgcHJlZml4ICsgbGVuZ3RoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCeXRlc0NvbXBhY3QoZGF0YSwgcG9zLCBtaW5vciwgX29wdGlvbnMpIHtcbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCAxLCBtaW5vcik7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQnl0ZXM4KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMiwgdWludC5yZWFkVWludDgoZGF0YSwgcG9zICsgMSwgb3B0aW9ucykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJ5dGVzMTYoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCAzLCB1aW50LnJlYWRVaW50MTYoZGF0YSwgcG9zICsgMSwgb3B0aW9ucykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJ5dGVzMzIoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCA1LCB1aW50LnJlYWRVaW50MzIoZGF0YSwgcG9zICsgMSwgb3B0aW9ucykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJ5dGVzNjQoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgbCA9IHVpbnQucmVhZFVpbnQ2NChkYXRhLCBwb3MgKyAxLCBvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBsID09PSAnYmlnaW50Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gNjQtYml0IGludGVnZXIgYnl0ZXMgbGVuZ3RocyBub3Qgc3VwcG9ydGVkYCk7XG4gIH1cbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCA5LCBsKTtcbn1cbmZ1bmN0aW9uIHRva2VuQnl0ZXModG9rZW4pIHtcbiAgaWYgKHRva2VuLmVuY29kZWRCeXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG9rZW4uZW5jb2RlZEJ5dGVzID0gdG9rZW4udHlwZSA9PT0gVHlwZS5zdHJpbmcgPyBmcm9tU3RyaW5nKHRva2VuLnZhbHVlKSA6IHRva2VuLnZhbHVlO1xuICB9XG4gIHJldHVybiB0b2tlbi5lbmNvZGVkQnl0ZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQnl0ZXMoYnVmLCB0b2tlbikge1xuICBjb25zdCBieXRlcyA9IHRva2VuQnl0ZXModG9rZW4pO1xuICB1aW50LmVuY29kZVVpbnRWYWx1ZShidWYsIHRva2VuLnR5cGUubWFqb3JFbmNvZGVkLCBieXRlcy5sZW5ndGgpO1xuICBidWYucHVzaChieXRlcyk7XG59XG5lbmNvZGVCeXRlcy5lbmNvZGVkU2l6ZSA9IGZ1bmN0aW9uIGVuY29kZWRTaXplKHRva2VuKSB7XG4gIGNvbnN0IGJ5dGVzID0gdG9rZW5CeXRlcyh0b2tlbik7XG4gIHJldHVybiB1aW50LmVuY29kZVVpbnRWYWx1ZS5lbmNvZGVkU2l6ZShieXRlcy5sZW5ndGgpICsgYnl0ZXMubGVuZ3RoO1xufTtcbmVuY29kZUJ5dGVzLmNvbXBhcmVUb2tlbnMgPSBmdW5jdGlvbiBjb21wYXJlVG9rZW5zKHRvazEsIHRvazIpIHtcbiAgcmV0dXJuIGNvbXBhcmVCeXRlcyh0b2tlbkJ5dGVzKHRvazEpLCB0b2tlbkJ5dGVzKHRvazIpKTtcbn07XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUJ5dGVzKGIxLCBiMikge1xuICByZXR1cm4gYjEubGVuZ3RoIDwgYjIubGVuZ3RoID8gLTEgOiBiMS5sZW5ndGggPiBiMi5sZW5ndGggPyAxIDogY29tcGFyZShiMSwgYjIpO1xufSIsImltcG9ydCB7XG4gIFRva2VuLFxuICBUeXBlXG59IGZyb20gJy4vdG9rZW4uanMnO1xuaW1wb3J0IHtcbiAgYXNzZXJ0RW5vdWdoRGF0YSxcbiAgZGVjb2RlRXJyUHJlZml4XG59IGZyb20gJy4vY29tbW9uLmpzJztcbmltcG9ydCAqIGFzIHVpbnQgZnJvbSAnLi8wdWludC5qcyc7XG5pbXBvcnQgeyBlbmNvZGVCeXRlcyB9IGZyb20gJy4vMmJ5dGVzLmpzJztcbmltcG9ydCB7IHRvU3RyaW5nIH0gZnJvbSAnLi9ieXRlLXV0aWxzLmpzJztcbmZ1bmN0aW9uIHRvVG9rZW4oZGF0YSwgcG9zLCBwcmVmaXgsIGxlbmd0aCkge1xuICBjb25zdCB0b3RMZW5ndGggPSBwcmVmaXggKyBsZW5ndGg7XG4gIGFzc2VydEVub3VnaERhdGEoZGF0YSwgcG9zLCB0b3RMZW5ndGgpO1xuICByZXR1cm4gbmV3IFRva2VuKFR5cGUuc3RyaW5nLCB0b1N0cmluZyhkYXRhLCBwb3MgKyBwcmVmaXgsIHBvcyArIHRvdExlbmd0aCksIHRvdExlbmd0aCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlU3RyaW5nQ29tcGFjdChkYXRhLCBwb3MsIG1pbm9yLCBfb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDEsIG1pbm9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmc4KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMiwgdWludC5yZWFkVWludDgoZGF0YSwgcG9zICsgMSwgb3B0aW9ucykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVN0cmluZzE2KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMywgdWludC5yZWFkVWludDE2KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmczMihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDUsIHVpbnQucmVhZFVpbnQzMihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlU3RyaW5nNjQoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgbCA9IHVpbnQucmVhZFVpbnQ2NChkYXRhLCBwb3MgKyAxLCBvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBsID09PSAnYmlnaW50Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gNjQtYml0IGludGVnZXIgc3RyaW5nIGxlbmd0aHMgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgOSwgbCk7XG59XG5leHBvcnQgY29uc3QgZW5jb2RlU3RyaW5nID0gZW5jb2RlQnl0ZXM7IiwiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQgKiBhcyB1aW50IGZyb20gJy4vMHVpbnQuanMnO1xuaW1wb3J0IHsgZGVjb2RlRXJyUHJlZml4IH0gZnJvbSAnLi9jb21tb24uanMnO1xuZnVuY3Rpb24gdG9Ub2tlbihfZGF0YSwgX3BvcywgcHJlZml4LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLmFycmF5LCBsZW5ndGgsIHByZWZpeCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQXJyYXlDb21wYWN0KGRhdGEsIHBvcywgbWlub3IsIF9vcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMSwgbWlub3IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUFycmF5OChkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDIsIHVpbnQucmVhZFVpbnQ4KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBcnJheTE2KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMywgdWludC5yZWFkVWludDE2KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBcnJheTMyKGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgNSwgdWludC5yZWFkVWludDMyKGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBcnJheTY0KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IGwgPSB1aW50LnJlYWRVaW50NjQoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyk7XG4gIGlmICh0eXBlb2YgbCA9PT0gJ2JpZ2ludCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IDY0LWJpdCBpbnRlZ2VyIGFycmF5IGxlbmd0aHMgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgOSwgbCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQXJyYXlJbmRlZmluaXRlKGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmFsbG93SW5kZWZpbml0ZSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGluZGVmaW5pdGUgbGVuZ3RoIGl0ZW1zIG5vdCBhbGxvd2VkYCk7XG4gIH1cbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCAxLCBJbmZpbml0eSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQXJyYXkoYnVmLCB0b2tlbikge1xuICB1aW50LmVuY29kZVVpbnRWYWx1ZShidWYsIFR5cGUuYXJyYXkubWFqb3JFbmNvZGVkLCB0b2tlbi52YWx1ZSk7XG59XG5lbmNvZGVBcnJheS5jb21wYXJlVG9rZW5zID0gdWludC5lbmNvZGVVaW50LmNvbXBhcmVUb2tlbnM7IiwiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQgKiBhcyB1aW50IGZyb20gJy4vMHVpbnQuanMnO1xuaW1wb3J0IHsgZGVjb2RlRXJyUHJlZml4IH0gZnJvbSAnLi9jb21tb24uanMnO1xuZnVuY3Rpb24gdG9Ub2tlbihfZGF0YSwgX3BvcywgcHJlZml4LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLm1hcCwgbGVuZ3RoLCBwcmVmaXgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1hcENvbXBhY3QoZGF0YSwgcG9zLCBtaW5vciwgX29wdGlvbnMpIHtcbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCAxLCBtaW5vcik7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTWFwOChkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDIsIHVpbnQucmVhZFVpbnQ4KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVNYXAxNihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDMsIHVpbnQucmVhZFVpbnQxNihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTWFwMzIoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCA1LCB1aW50LnJlYWRVaW50MzIoZGF0YSwgcG9zICsgMSwgb3B0aW9ucykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1hcDY0KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IGwgPSB1aW50LnJlYWRVaW50NjQoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyk7XG4gIGlmICh0eXBlb2YgbCA9PT0gJ2JpZ2ludCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IDY0LWJpdCBpbnRlZ2VyIG1hcCBsZW5ndGhzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDksIGwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1hcEluZGVmaW5pdGUoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuYWxsb3dJbmRlZmluaXRlID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gaW5kZWZpbml0ZSBsZW5ndGggaXRlbXMgbm90IGFsbG93ZWRgKTtcbiAgfVxuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDEsIEluZmluaXR5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVNYXAoYnVmLCB0b2tlbikge1xuICB1aW50LmVuY29kZVVpbnRWYWx1ZShidWYsIFR5cGUubWFwLm1ham9yRW5jb2RlZCwgdG9rZW4udmFsdWUpO1xufVxuZW5jb2RlTWFwLmNvbXBhcmVUb2tlbnMgPSB1aW50LmVuY29kZVVpbnQuY29tcGFyZVRva2VuczsiLCJpbXBvcnQge1xuICBUb2tlbixcbiAgVHlwZVxufSBmcm9tICcuL3Rva2VuLmpzJztcbmltcG9ydCAqIGFzIHVpbnQgZnJvbSAnLi8wdWludC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVGFnQ29tcGFjdChfZGF0YSwgX3BvcywgbWlub3IsIF9vcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS50YWcsIG1pbm9yLCAxKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUYWc4KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS50YWcsIHVpbnQucmVhZFVpbnQ4KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCAyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUYWcxNihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFRva2VuKFR5cGUudGFnLCB1aW50LnJlYWRVaW50MTYoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIDMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRhZzMyKGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS50YWcsIHVpbnQucmVhZFVpbnQzMihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSwgNSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVGFnNjQoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLnRhZywgdWludC5yZWFkVWludDY0KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCA5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVUYWcoYnVmLCB0b2tlbikge1xuICB1aW50LmVuY29kZVVpbnRWYWx1ZShidWYsIFR5cGUudGFnLm1ham9yRW5jb2RlZCwgdG9rZW4udmFsdWUpO1xufVxuZW5jb2RlVGFnLmNvbXBhcmVUb2tlbnMgPSB1aW50LmVuY29kZVVpbnQuY29tcGFyZVRva2VuczsiLCJpbXBvcnQge1xuICBUb2tlbixcbiAgVHlwZVxufSBmcm9tICcuL3Rva2VuLmpzJztcbmltcG9ydCB7IGRlY29kZUVyclByZWZpeCB9IGZyb20gJy4vY29tbW9uLmpzJztcbmltcG9ydCB7IGVuY29kZVVpbnQgfSBmcm9tICcuLzB1aW50LmpzJztcbmNvbnN0IE1JTk9SX0ZBTFNFID0gMjA7XG5jb25zdCBNSU5PUl9UUlVFID0gMjE7XG5jb25zdCBNSU5PUl9OVUxMID0gMjI7XG5jb25zdCBNSU5PUl9VTkRFRklORUQgPSAyMztcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVVbmRlZmluZWQoX2RhdGEsIF9wb3MsIF9taW5vciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5hbGxvd1VuZGVmaW5lZCA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IHVuZGVmaW5lZCB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxuICByZXR1cm4gbmV3IFRva2VuKFR5cGUudW5kZWZpbmVkLCB1bmRlZmluZWQsIDEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJyZWFrKF9kYXRhLCBfcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuYWxsb3dJbmRlZmluaXRlID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gaW5kZWZpbml0ZSBsZW5ndGggaXRlbXMgbm90IGFsbG93ZWRgKTtcbiAgfVxuICByZXR1cm4gbmV3IFRva2VuKFR5cGUuYnJlYWssIHVuZGVmaW5lZCwgMSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbih2YWx1ZSwgYnl0ZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hbGxvd05hTiA9PT0gZmFsc2UgJiYgTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBOYU4gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93SW5maW5pdHkgPT09IGZhbHNlICYmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHwgdmFsdWUgPT09IC1JbmZpbml0eSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gSW5maW5pdHkgdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS5mbG9hdCwgdmFsdWUsIGJ5dGVzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVGbG9hdDE2KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVUb2tlbihyZWFkRmxvYXQxNihkYXRhLCBwb3MgKyAxKSwgMywgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRmxvYXQzMihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gY3JlYXRlVG9rZW4ocmVhZEZsb2F0MzIoZGF0YSwgcG9zICsgMSksIDUsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUZsb2F0NjQoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyZWF0ZVRva2VuKHJlYWRGbG9hdDY0KGRhdGEsIHBvcyArIDEpLCA5LCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVGbG9hdChidWYsIHRva2VuLCBvcHRpb25zKSB7XG4gIGNvbnN0IGZsb2F0ID0gdG9rZW4udmFsdWU7XG4gIGlmIChmbG9hdCA9PT0gZmFsc2UpIHtcbiAgICBidWYucHVzaChbVHlwZS5mbG9hdC5tYWpvckVuY29kZWQgfCBNSU5PUl9GQUxTRV0pO1xuICB9IGVsc2UgaWYgKGZsb2F0ID09PSB0cnVlKSB7XG4gICAgYnVmLnB1c2goW1R5cGUuZmxvYXQubWFqb3JFbmNvZGVkIHwgTUlOT1JfVFJVRV0pO1xuICB9IGVsc2UgaWYgKGZsb2F0ID09PSBudWxsKSB7XG4gICAgYnVmLnB1c2goW1R5cGUuZmxvYXQubWFqb3JFbmNvZGVkIHwgTUlOT1JfTlVMTF0pO1xuICB9IGVsc2UgaWYgKGZsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYucHVzaChbVHlwZS5mbG9hdC5tYWpvckVuY29kZWQgfCBNSU5PUl9VTkRFRklORURdKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZGVjb2RlZDtcbiAgICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLmZsb2F0NjQgIT09IHRydWUpIHtcbiAgICAgIGVuY29kZUZsb2F0MTYoZmxvYXQpO1xuICAgICAgZGVjb2RlZCA9IHJlYWRGbG9hdDE2KHVpOGEsIDEpO1xuICAgICAgaWYgKGZsb2F0ID09PSBkZWNvZGVkIHx8IE51bWJlci5pc05hTihmbG9hdCkpIHtcbiAgICAgICAgdWk4YVswXSA9IDI0OTtcbiAgICAgICAgYnVmLnB1c2godWk4YS5zbGljZSgwLCAzKSk7XG4gICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jb2RlRmxvYXQzMihmbG9hdCk7XG4gICAgICAgIGRlY29kZWQgPSByZWFkRmxvYXQzMih1aThhLCAxKTtcbiAgICAgICAgaWYgKGZsb2F0ID09PSBkZWNvZGVkKSB7XG4gICAgICAgICAgdWk4YVswXSA9IDI1MDtcbiAgICAgICAgICBidWYucHVzaCh1aThhLnNsaWNlKDAsIDUpKTtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgIGVuY29kZUZsb2F0NjQoZmxvYXQpO1xuICAgICAgZGVjb2RlZCA9IHJlYWRGbG9hdDY0KHVpOGEsIDEpO1xuICAgICAgdWk4YVswXSA9IDI1MTtcbiAgICAgIGJ1Zi5wdXNoKHVpOGEuc2xpY2UoMCwgOSkpO1xuICAgIH1cbiAgfVxufVxuZW5jb2RlRmxvYXQuZW5jb2RlZFNpemUgPSBmdW5jdGlvbiBlbmNvZGVkU2l6ZSh0b2tlbiwgb3B0aW9ucykge1xuICBjb25zdCBmbG9hdCA9IHRva2VuLnZhbHVlO1xuICBpZiAoZmxvYXQgPT09IGZhbHNlIHx8IGZsb2F0ID09PSB0cnVlIHx8IGZsb2F0ID09PSBudWxsIHx8IGZsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgZGVjb2RlZDtcbiAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZmxvYXQ2NCAhPT0gdHJ1ZSkge1xuICAgIGVuY29kZUZsb2F0MTYoZmxvYXQpO1xuICAgIGRlY29kZWQgPSByZWFkRmxvYXQxNih1aThhLCAxKTtcbiAgICBpZiAoZmxvYXQgPT09IGRlY29kZWQgfHwgTnVtYmVyLmlzTmFOKGZsb2F0KSkge1xuICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICAgIGVuY29kZUZsb2F0MzIoZmxvYXQpO1xuICAgIGRlY29kZWQgPSByZWFkRmxvYXQzMih1aThhLCAxKTtcbiAgICBpZiAoZmxvYXQgPT09IGRlY29kZWQpIHtcbiAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgfVxuICByZXR1cm4gOTtcbn07XG5jb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoOSk7XG5jb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIsIDEpO1xuY29uc3QgdWk4YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgMCk7XG5mdW5jdGlvbiBlbmNvZGVGbG9hdDE2KGlucCkge1xuICBpZiAoaW5wID09PSBJbmZpbml0eSkge1xuICAgIGRhdGFWaWV3LnNldFVpbnQxNigwLCAzMTc0NCwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKGlucCA9PT0gLUluZmluaXR5KSB7XG4gICAgZGF0YVZpZXcuc2V0VWludDE2KDAsIDY0NTEyLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoTnVtYmVyLmlzTmFOKGlucCkpIHtcbiAgICBkYXRhVmlldy5zZXRVaW50MTYoMCwgMzIyNTYsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhVmlldy5zZXRGbG9hdDMyKDAsIGlucCk7XG4gICAgY29uc3QgdmFsdTMyID0gZGF0YVZpZXcuZ2V0VWludDMyKDApO1xuICAgIGNvbnN0IGV4cG9uZW50ID0gKHZhbHUzMiAmIDIxMzkwOTUwNDApID4+IDIzO1xuICAgIGNvbnN0IG1hbnRpc3NhID0gdmFsdTMyICYgODM4ODYwNztcbiAgICBpZiAoZXhwb25lbnQgPT09IDI1NSkge1xuICAgICAgZGF0YVZpZXcuc2V0VWludDE2KDAsIDMxNzQ0LCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChleHBvbmVudCA9PT0gMCkge1xuICAgICAgZGF0YVZpZXcuc2V0VWludDE2KDAsIChpbnAgJiAyMTQ3NDgzNjQ4KSA+PiAxNiB8IG1hbnRpc3NhID4+IDEzLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxvZ2ljYWxFeHBvbmVudCA9IGV4cG9uZW50IC0gMTI3O1xuICAgICAgaWYgKGxvZ2ljYWxFeHBvbmVudCA8IC0yNCkge1xuICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYoMCwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGxvZ2ljYWxFeHBvbmVudCA8IC0xNCkge1xuICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYoMCwgKHZhbHUzMiAmIDIxNDc0ODM2NDgpID4+IDE2IHwgMSA8PCAyNCArIGxvZ2ljYWxFeHBvbmVudCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KDAsICh2YWx1MzIgJiAyMTQ3NDgzNjQ4KSA+PiAxNiB8IGxvZ2ljYWxFeHBvbmVudCArIDE1IDw8IDEwIHwgbWFudGlzc2EgPj4gMTMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlYWRGbG9hdDE2KHVpOGEsIHBvcykge1xuICBpZiAodWk4YS5sZW5ndGggLSBwb3MgPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBub3QgZW5vdWdoIGRhdGEgZm9yIGZsb2F0MTZgKTtcbiAgfVxuICBjb25zdCBoYWxmID0gKHVpOGFbcG9zXSA8PCA4KSArIHVpOGFbcG9zICsgMV07XG4gIGlmIChoYWxmID09PSAzMTc0NCkge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuICBpZiAoaGFsZiA9PT0gNjQ1MTIpIHtcbiAgICByZXR1cm4gLUluZmluaXR5O1xuICB9XG4gIGlmIChoYWxmID09PSAzMjI1Nikge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgY29uc3QgZXhwID0gaGFsZiA+PiAxMCAmIDMxO1xuICBjb25zdCBtYW50ID0gaGFsZiAmIDEwMjM7XG4gIGxldCB2YWw7XG4gIGlmIChleHAgPT09IDApIHtcbiAgICB2YWwgPSBtYW50ICogMiAqKiAtMjQ7XG4gIH0gZWxzZSBpZiAoZXhwICE9PSAzMSkge1xuICAgIHZhbCA9IChtYW50ICsgMTAyNCkgKiAyICoqIChleHAgLSAyNSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gbWFudCA9PT0gMCA/IEluZmluaXR5IDogTmFOO1xuICB9XG4gIHJldHVybiBoYWxmICYgMzI3NjggPyAtdmFsIDogdmFsO1xufVxuZnVuY3Rpb24gZW5jb2RlRmxvYXQzMihpbnApIHtcbiAgZGF0YVZpZXcuc2V0RmxvYXQzMigwLCBpbnAsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHJlYWRGbG9hdDMyKHVpOGEsIHBvcykge1xuICBpZiAodWk4YS5sZW5ndGggLSBwb3MgPCA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBub3QgZW5vdWdoIGRhdGEgZm9yIGZsb2F0MzJgKTtcbiAgfVxuICBjb25zdCBvZmZzZXQgPSAodWk4YS5ieXRlT2Zmc2V0IHx8IDApICsgcG9zO1xuICByZXR1cm4gbmV3IERhdGFWaWV3KHVpOGEuYnVmZmVyLCBvZmZzZXQsIDQpLmdldEZsb2F0MzIoMCwgZmFsc2UpO1xufVxuZnVuY3Rpb24gZW5jb2RlRmxvYXQ2NChpbnApIHtcbiAgZGF0YVZpZXcuc2V0RmxvYXQ2NCgwLCBpbnAsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHJlYWRGbG9hdDY0KHVpOGEsIHBvcykge1xuICBpZiAodWk4YS5sZW5ndGggLSBwb3MgPCA4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBub3QgZW5vdWdoIGRhdGEgZm9yIGZsb2F0NjRgKTtcbiAgfVxuICBjb25zdCBvZmZzZXQgPSAodWk4YS5ieXRlT2Zmc2V0IHx8IDApICsgcG9zO1xuICByZXR1cm4gbmV3IERhdGFWaWV3KHVpOGEuYnVmZmVyLCBvZmZzZXQsIDgpLmdldEZsb2F0NjQoMCwgZmFsc2UpO1xufVxuZW5jb2RlRmxvYXQuY29tcGFyZVRva2VucyA9IGVuY29kZVVpbnQuY29tcGFyZVRva2VuczsiLCJpbXBvcnQge1xuICBhbGxvYyxcbiAgY29uY2F0LFxuICBzbGljZVxufSBmcm9tICcuL2J5dGUtdXRpbHMuanMnO1xuY29uc3QgZGVmYXVsdENodW5rU2l6ZSA9IDI1NjtcbmV4cG9ydCBjbGFzcyBCbCB7XG4gIGNvbnN0cnVjdG9yKGNodW5rU2l6ZSA9IGRlZmF1bHRDaHVua1NpemUpIHtcbiAgICB0aGlzLmNodW5rU2l6ZSA9IGNodW5rU2l6ZTtcbiAgICB0aGlzLmN1cnNvciA9IDA7XG4gICAgdGhpcy5tYXhDdXJzb3IgPSAtMTtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHRoaXMuX2luaXRSZXVzZUNodW5rID0gbnVsbDtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHRoaXMuY3Vyc29yID0gMDtcbiAgICB0aGlzLm1heEN1cnNvciA9IC0xO1xuICAgIGlmICh0aGlzLl9pbml0UmV1c2VDaHVuayAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5jaHVua3MucHVzaCh0aGlzLl9pbml0UmV1c2VDaHVuayk7XG4gICAgICB0aGlzLm1heEN1cnNvciA9IHRoaXMuX2luaXRSZXVzZUNodW5rLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9XG4gIHB1c2goYnl0ZXMpIHtcbiAgICBsZXQgdG9wQ2h1bmsgPSB0aGlzLmNodW5rc1t0aGlzLmNodW5rcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBuZXdNYXggPSB0aGlzLmN1cnNvciArIGJ5dGVzLmxlbmd0aDtcbiAgICBpZiAobmV3TWF4IDw9IHRoaXMubWF4Q3Vyc29yICsgMSkge1xuICAgICAgY29uc3QgY2h1bmtQb3MgPSB0b3BDaHVuay5sZW5ndGggLSAodGhpcy5tYXhDdXJzb3IgLSB0aGlzLmN1cnNvcikgLSAxO1xuICAgICAgdG9wQ2h1bmsuc2V0KGJ5dGVzLCBjaHVua1Bvcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0b3BDaHVuaykge1xuICAgICAgICBjb25zdCBjaHVua1BvcyA9IHRvcENodW5rLmxlbmd0aCAtICh0aGlzLm1heEN1cnNvciAtIHRoaXMuY3Vyc29yKSAtIDE7XG4gICAgICAgIGlmIChjaHVua1BvcyA8IHRvcENodW5rLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuY2h1bmtzW3RoaXMuY2h1bmtzLmxlbmd0aCAtIDFdID0gdG9wQ2h1bmsuc3ViYXJyYXkoMCwgY2h1bmtQb3MpO1xuICAgICAgICAgIHRoaXMubWF4Q3Vyc29yID0gdGhpcy5jdXJzb3IgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoIDwgNjQgJiYgYnl0ZXMubGVuZ3RoIDwgdGhpcy5jaHVua1NpemUpIHtcbiAgICAgICAgdG9wQ2h1bmsgPSBhbGxvYyh0aGlzLmNodW5rU2l6ZSk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2godG9wQ2h1bmspO1xuICAgICAgICB0aGlzLm1heEN1cnNvciArPSB0b3BDaHVuay5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9pbml0UmV1c2VDaHVuayA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX2luaXRSZXVzZUNodW5rID0gdG9wQ2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgdG9wQ2h1bmsuc2V0KGJ5dGVzLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goYnl0ZXMpO1xuICAgICAgICB0aGlzLm1heEN1cnNvciArPSBieXRlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3Vyc29yICs9IGJ5dGVzLmxlbmd0aDtcbiAgfVxuICB0b0J5dGVzKHJlc2V0ID0gZmFsc2UpIHtcbiAgICBsZXQgYnl0cztcbiAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuY2h1bmtzWzBdO1xuICAgICAgaWYgKHJlc2V0ICYmIHRoaXMuY3Vyc29yID4gY2h1bmsubGVuZ3RoIC8gMikge1xuICAgICAgICBieXRzID0gdGhpcy5jdXJzb3IgPT09IGNodW5rLmxlbmd0aCA/IGNodW5rIDogY2h1bmsuc3ViYXJyYXkoMCwgdGhpcy5jdXJzb3IpO1xuICAgICAgICB0aGlzLl9pbml0UmV1c2VDaHVuayA9IG51bGw7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBieXRzID0gc2xpY2UoY2h1bmssIDAsIHRoaXMuY3Vyc29yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnl0cyA9IGNvbmNhdCh0aGlzLmNodW5rcywgdGhpcy5jdXJzb3IpO1xuICAgIH1cbiAgICBpZiAocmVzZXQpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dHM7XG4gIH1cbn0iLCJleHBvcnQgY29uc3QgdXNlQnVmZmVyID0gZ2xvYmFsVGhpcy5wcm9jZXNzICYmICFnbG9iYWxUaGlzLnByb2Nlc3MuYnJvd3NlciAmJiBnbG9iYWxUaGlzLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5CdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbic7XG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGlzQnVmZmVyKGJ1Zikge1xuICByZXR1cm4gdXNlQnVmZmVyICYmIGdsb2JhbFRoaXMuQnVmZmVyLmlzQnVmZmVyKGJ1Zik7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNVOEEoYnVmKSB7XG4gIGlmICghKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShidWYpO1xuICB9XG4gIHJldHVybiBpc0J1ZmZlcihidWYpID8gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKSA6IGJ1Zjtcbn1cbmV4cG9ydCBjb25zdCB0b1N0cmluZyA9IHVzZUJ1ZmZlciA/IChieXRlcywgc3RhcnQsIGVuZCkgPT4ge1xuICByZXR1cm4gZW5kIC0gc3RhcnQgPiA2NCA/IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYnl0ZXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpLnRvU3RyaW5nKCd1dGY4JykgOiB1dGY4U2xpY2UoYnl0ZXMsIHN0YXJ0LCBlbmQpO1xufSA6IChieXRlcywgc3RhcnQsIGVuZCkgPT4ge1xuICByZXR1cm4gZW5kIC0gc3RhcnQgPiA2NCA/IHRleHREZWNvZGVyLmRlY29kZShieXRlcy5zdWJhcnJheShzdGFydCwgZW5kKSkgOiB1dGY4U2xpY2UoYnl0ZXMsIHN0YXJ0LCBlbmQpO1xufTtcbmV4cG9ydCBjb25zdCBmcm9tU3RyaW5nID0gdXNlQnVmZmVyID8gc3RyaW5nID0+IHtcbiAgcmV0dXJuIHN0cmluZy5sZW5ndGggPiA2NCA/IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oc3RyaW5nKSA6IHV0ZjhUb0J5dGVzKHN0cmluZyk7XG59IDogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHN0cmluZy5sZW5ndGggPiA2NCA/IHRleHRFbmNvZGVyLmVuY29kZShzdHJpbmcpIDogdXRmOFRvQnl0ZXMoc3RyaW5nKTtcbn07XG5leHBvcnQgY29uc3QgZnJvbUFycmF5ID0gYXJyID0+IHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhcnIpO1xufTtcbmV4cG9ydCBjb25zdCBzbGljZSA9IHVzZUJ1ZmZlciA/IChieXRlcywgc3RhcnQsIGVuZCkgPT4ge1xuICBpZiAoaXNCdWZmZXIoYnl0ZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXMuc2xpY2Uoc3RhcnQsIGVuZCk7XG59IDogKGJ5dGVzLCBzdGFydCwgZW5kKSA9PiB7XG4gIHJldHVybiBieXRlcy5zbGljZShzdGFydCwgZW5kKTtcbn07XG5leHBvcnQgY29uc3QgY29uY2F0ID0gdXNlQnVmZmVyID8gKGNodW5rcywgbGVuZ3RoKSA9PiB7XG4gIGNodW5rcyA9IGNodW5rcy5tYXAoYyA9PiBjIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGMgOiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGMpKTtcbiAgcmV0dXJuIGFzVThBKGdsb2JhbFRoaXMuQnVmZmVyLmNvbmNhdChjaHVua3MsIGxlbmd0aCkpO1xufSA6IChjaHVua3MsIGxlbmd0aCkgPT4ge1xuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICBsZXQgb2ZmID0gMDtcbiAgZm9yIChsZXQgYiBvZiBjaHVua3MpIHtcbiAgICBpZiAob2ZmICsgYi5sZW5ndGggPiBvdXQubGVuZ3RoKSB7XG4gICAgICBiID0gYi5zdWJhcnJheSgwLCBvdXQubGVuZ3RoIC0gb2ZmKTtcbiAgICB9XG4gICAgb3V0LnNldChiLCBvZmYpO1xuICAgIG9mZiArPSBiLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbmV4cG9ydCBjb25zdCBhbGxvYyA9IHVzZUJ1ZmZlciA/IHNpemUgPT4ge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG59IDogc2l6ZSA9PiB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbn07XG5leHBvcnQgY29uc3QgdG9IZXggPSB1c2VCdWZmZXIgPyBkID0+IHtcbiAgaWYgKHR5cGVvZiBkID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkO1xuICB9XG4gIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKHRvQnl0ZXMoZCkpLnRvU3RyaW5nKCdoZXgnKTtcbn0gOiBkID0+IHtcbiAgaWYgKHR5cGVvZiBkID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkO1xuICB9XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwodG9CeXRlcyhkKSwgKHAsIGMpID0+IGAkeyBwIH0keyBjLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpIH1gLCAnJyk7XG59O1xuZXhwb3J0IGNvbnN0IGZyb21IZXggPSB1c2VCdWZmZXIgPyBoZXggPT4ge1xuICBpZiAoaGV4IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBoZXg7XG4gIH1cbiAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oaGV4LCAnaGV4Jyk7XG59IDogaGV4ID0+IHtcbiAgaWYgKGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gaGV4O1xuICB9XG4gIGlmICghaGV4Lmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGV4LnNwbGl0KCcnKS5tYXAoKGMsIGksIGQpID0+IGkgJSAyID09PSAwID8gYDB4JHsgYyB9JHsgZFtpICsgMV0gfWAgOiAnJykuZmlsdGVyKEJvb2xlYW4pLm1hcChlID0+IHBhcnNlSW50KGUsIDE2KSkpO1xufTtcbmZ1bmN0aW9uIHRvQnl0ZXMob2JqKSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvYmopO1xuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvYmouYnVmZmVyLCBvYmouYnl0ZU9mZnNldCwgb2JqLmJ5dGVMZW5ndGgpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShiMSwgYjIpIHtcbiAgaWYgKGlzQnVmZmVyKGIxKSAmJiBpc0J1ZmZlcihiMikpIHtcbiAgICByZXR1cm4gYjEuY29tcGFyZShiMik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChiMVtpXSA9PT0gYjJbaV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gYjFbaV0gPCBiMltpXSA/IC0xIDogMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cmluZywgdW5pdHMgPSBJbmZpbml0eSkge1xuICBsZXQgY29kZVBvaW50O1xuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gIGNvbnN0IGJ5dGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZVBvaW50ID4gNTUyOTUgJiYgY29kZVBvaW50IDwgNTczNDQpIHtcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICBpZiAoY29kZVBvaW50ID4gNTYzMTkpIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpXG4gICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpXG4gICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVQb2ludCA8IDU2MzIwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSlcbiAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gNTUyOTYgPDwgMTAgfCBjb2RlUG9pbnQgLSA1NjMyMCkgKyA2NTUzNjtcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSlcbiAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICB9XG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gICAgaWYgKGNvZGVQb2ludCA8IDEyOCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApXG4gICAgICAgIGJyZWFrO1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMjA0OCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApXG4gICAgICAgIGJyZWFrO1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gNiB8IDE5MiwgY29kZVBvaW50ICYgNjMgfCAxMjgpO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgNjU1MzYpIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKVxuICAgICAgICBicmVhaztcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDEyIHwgMjI0LCBjb2RlUG9pbnQgPj4gNiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAxMTE0MTEyKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMClcbiAgICAgICAgYnJlYWs7XG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiAxOCB8IDI0MCwgY29kZVBvaW50ID4+IDEyICYgNjMgfCAxMjgsIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gdXRmOFNsaWNlKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIHdoaWxlIChvZmZzZXQgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbb2Zmc2V0XTtcbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbDtcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IGZpcnN0Qnl0ZSA+IDIzOSA/IDQgOiBmaXJzdEJ5dGUgPiAyMjMgPyAzIDogZmlyc3RCeXRlID4gMTkxID8gMiA6IDE7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50O1xuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChmaXJzdEJ5dGUgPCAxMjgpIHtcbiAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHNlY29uZEJ5dGUgPSBidWZbb2Zmc2V0ICsgMV07XG4gICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCkge1xuICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMzEpIDw8IDYgfCBzZWNvbmRCeXRlICYgNjM7XG4gICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAxMjcpIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBzZWNvbmRCeXRlID0gYnVmW29mZnNldCArIDFdO1xuICAgICAgICB0aGlyZEJ5dGUgPSBidWZbb2Zmc2V0ICsgMl07XG4gICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAodGhpcmRCeXRlICYgMTkyKSA9PT0gMTI4KSB7XG4gICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAxNSkgPDwgMTIgfCAoc2Vjb25kQnl0ZSAmIDYzKSA8PCA2IHwgdGhpcmRCeXRlICYgNjM7XG4gICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAyMDQ3ICYmICh0ZW1wQ29kZVBvaW50IDwgNTUyOTYgfHwgdGVtcENvZGVQb2ludCA+IDU3MzQzKSkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHNlY29uZEJ5dGUgPSBidWZbb2Zmc2V0ICsgMV07XG4gICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltvZmZzZXQgKyAyXTtcbiAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltvZmZzZXQgKyAzXTtcbiAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmICh0aGlyZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKGZvdXJ0aEJ5dGUgJiAxOTIpID09PSAxMjgpIHtcbiAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDE1KSA8PCAxOCB8IChzZWNvbmRCeXRlICYgNjMpIDw8IDEyIHwgKHRoaXJkQnl0ZSAmIDYzKSA8PCA2IHwgZm91cnRoQnl0ZSAmIDYzO1xuICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gNjU1MzUgJiYgdGVtcENvZGVQb2ludCA8IDExMTQxMTIpIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIGNvZGVQb2ludCA9IDY1NTMzO1xuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiA2NTUzNSkge1xuICAgICAgY29kZVBvaW50IC09IDY1NTM2O1xuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDEwMjMgfCA1NTI5Nik7XG4gICAgICBjb2RlUG9pbnQgPSA1NjMyMCB8IGNvZGVQb2ludCAmIDEwMjM7XG4gICAgfVxuICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgb2Zmc2V0ICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG4gIH1cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpO1xufVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSA0MDk2O1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKTtcbiAgfVxuICBsZXQgcmVzID0gJyc7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkpO1xuICB9XG4gIHJldHVybiByZXM7XG59IiwiY29uc3QgZGVjb2RlRXJyUHJlZml4ID0gJ0NCT1IgZGVjb2RlIGVycm9yOic7XG5jb25zdCBlbmNvZGVFcnJQcmVmaXggPSAnQ0JPUiBlbmNvZGUgZXJyb3I6JztcbmNvbnN0IHVpbnRNaW5vclByZWZpeEJ5dGVzID0gW107XG51aW50TWlub3JQcmVmaXhCeXRlc1syM10gPSAxO1xudWludE1pbm9yUHJlZml4Qnl0ZXNbMjRdID0gMjtcbnVpbnRNaW5vclByZWZpeEJ5dGVzWzI1XSA9IDM7XG51aW50TWlub3JQcmVmaXhCeXRlc1syNl0gPSA1O1xudWludE1pbm9yUHJlZml4Qnl0ZXNbMjddID0gOTtcbmZ1bmN0aW9uIGFzc2VydEVub3VnaERhdGEoZGF0YSwgcG9zLCBuZWVkKSB7XG4gIGlmIChkYXRhLmxlbmd0aCAtIHBvcyA8IG5lZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IG5vdCBlbm91Z2ggZGF0YSBmb3IgdHlwZWApO1xuICB9XG59XG5leHBvcnQge1xuICBkZWNvZGVFcnJQcmVmaXgsXG4gIGVuY29kZUVyclByZWZpeCxcbiAgdWludE1pbm9yUHJlZml4Qnl0ZXMsXG4gIGFzc2VydEVub3VnaERhdGFcbn07IiwiaW1wb3J0IHsgZGVjb2RlRXJyUHJlZml4IH0gZnJvbSAnLi9jb21tb24uanMnO1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJy4vdG9rZW4uanMnO1xuaW1wb3J0IHtcbiAganVtcCxcbiAgcXVpY2tcbn0gZnJvbSAnLi9qdW1wLmpzJztcbmNvbnN0IGRlZmF1bHREZWNvZGVPcHRpb25zID0ge1xuICBzdHJpY3Q6IGZhbHNlLFxuICBhbGxvd0luZGVmaW5pdGU6IHRydWUsXG4gIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICBhbGxvd0JpZ0ludDogdHJ1ZVxufTtcbmNsYXNzIFRva2VuaXNlciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgZG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgfVxuICBuZXh0KCkge1xuICAgIGNvbnN0IGJ5dCA9IHRoaXMuZGF0YVt0aGlzLnBvc107XG4gICAgbGV0IHRva2VuID0gcXVpY2tbYnl0XTtcbiAgICBpZiAodG9rZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGp1bXBbYnl0XTtcbiAgICAgIGlmICghZGVjb2Rlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IG5vIGRlY29kZXIgZm9yIG1ham9yIHR5cGUgJHsgYnl0ID4+PiA1IH0gKGJ5dGUgMHgkeyBieXQudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykgfSlgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pbm9yID0gYnl0ICYgMzE7XG4gICAgICB0b2tlbiA9IGRlY29kZXIodGhpcy5kYXRhLCB0aGlzLnBvcywgbWlub3IsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMucG9zICs9IHRva2VuLmVuY29kZWRMZW5ndGg7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG59XG5jb25zdCBET05FID0gU3ltYm9sLmZvcignRE9ORScpO1xuY29uc3QgQlJFQUsgPSBTeW1ib2wuZm9yKCdCUkVBSycpO1xuZnVuY3Rpb24gdG9rZW5Ub0FycmF5KHRva2VuLCB0b2tlbmlzZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgYXJyID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW4udmFsdWU7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gdG9rZW5zVG9PYmplY3QodG9rZW5pc2VyLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWUgPT09IEJSRUFLKSB7XG4gICAgICBpZiAodG9rZW4udmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBnb3QgdW5leHBlY3RlZCBicmVhayB0byBsZW5ndGhlZCBhcnJheWApO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IERPTkUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gZm91bmQgYXJyYXkgYnV0IG5vdCBlbm91Z2ggZW50cmllcyAoZ290ICR7IGkgfSwgZXhwZWN0ZWQgJHsgdG9rZW4udmFsdWUgfSlgKTtcbiAgICB9XG4gICAgYXJyW2ldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIHRva2VuVG9NYXAodG9rZW4sIHRva2VuaXNlciwgb3B0aW9ucykge1xuICBjb25zdCB1c2VNYXBzID0gb3B0aW9ucy51c2VNYXBzID09PSB0cnVlO1xuICBjb25zdCBvYmogPSB1c2VNYXBzID8gdW5kZWZpbmVkIDoge307XG4gIGNvbnN0IG0gPSB1c2VNYXBzID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuLnZhbHVlOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSB0b2tlbnNUb09iamVjdCh0b2tlbmlzZXIsIG9wdGlvbnMpO1xuICAgIGlmIChrZXkgPT09IEJSRUFLKSB7XG4gICAgICBpZiAodG9rZW4udmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBnb3QgdW5leHBlY3RlZCBicmVhayB0byBsZW5ndGhlZCBtYXBgKTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gRE9ORSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBmb3VuZCBtYXAgYnV0IG5vdCBlbm91Z2ggZW50cmllcyAoZ290ICR7IGkgfSBbbm8ga2V5XSwgZXhwZWN0ZWQgJHsgdG9rZW4udmFsdWUgfSlgKTtcbiAgICB9XG4gICAgaWYgKHVzZU1hcHMgIT09IHRydWUgJiYgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gbm9uLXN0cmluZyBrZXlzIG5vdCBzdXBwb3J0ZWQgKGdvdCAkeyB0eXBlb2Yga2V5IH0pYCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdG9rZW5zVG9PYmplY3QodG9rZW5pc2VyLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWUgPT09IERPTkUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gZm91bmQgbWFwIGJ1dCBub3QgZW5vdWdoIGVudHJpZXMgKGdvdCAkeyBpIH0gW25vIHZhbHVlXSwgZXhwZWN0ZWQgJHsgdG9rZW4udmFsdWUgfSlgKTtcbiAgICB9XG4gICAgaWYgKHVzZU1hcHMpIHtcbiAgICAgIG0uc2V0KGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdXNlTWFwcyA/IG0gOiBvYmo7XG59XG5mdW5jdGlvbiB0b2tlbnNUb09iamVjdCh0b2tlbmlzZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHRva2VuaXNlci5kb25lKCkpIHtcbiAgICByZXR1cm4gRE9ORTtcbiAgfVxuICBjb25zdCB0b2tlbiA9IHRva2VuaXNlci5uZXh0KCk7XG4gIGlmICh0b2tlbi50eXBlID09PSBUeXBlLmJyZWFrKSB7XG4gICAgcmV0dXJuIEJSRUFLO1xuICB9XG4gIGlmICh0b2tlbi50eXBlLnRlcm1pbmFsKSB7XG4gICAgcmV0dXJuIHRva2VuLnZhbHVlO1xuICB9XG4gIGlmICh0b2tlbi50eXBlID09PSBUeXBlLmFycmF5KSB7XG4gICAgcmV0dXJuIHRva2VuVG9BcnJheSh0b2tlbiwgdG9rZW5pc2VyLCBvcHRpb25zKTtcbiAgfVxuICBpZiAodG9rZW4udHlwZSA9PT0gVHlwZS5tYXApIHtcbiAgICByZXR1cm4gdG9rZW5Ub01hcCh0b2tlbiwgdG9rZW5pc2VyLCBvcHRpb25zKTtcbiAgfVxuICBpZiAodG9rZW4udHlwZSA9PT0gVHlwZS50YWcpIHtcbiAgICBpZiAob3B0aW9ucy50YWdzICYmIHR5cGVvZiBvcHRpb25zLnRhZ3NbdG9rZW4udmFsdWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCB0YWdnZWQgPSB0b2tlbnNUb09iamVjdCh0b2tlbmlzZXIsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG9wdGlvbnMudGFnc1t0b2tlbi52YWx1ZV0odGFnZ2VkKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSB0YWcgbm90IHN1cHBvcnRlZCAoJHsgdG9rZW4udmFsdWUgfSlgKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkJyk7XG59XG5mdW5jdGlvbiBkZWNvZGUoZGF0YSwgb3B0aW9ucykge1xuICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGRhdGEgdG8gZGVjb2RlIG11c3QgYmUgYSBVaW50OEFycmF5YCk7XG4gIH1cbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHREZWNvZGVPcHRpb25zLCBvcHRpb25zKTtcbiAgY29uc3QgdG9rZW5pc2VyID0gb3B0aW9ucy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXNlcihkYXRhLCBvcHRpb25zKTtcbiAgY29uc3QgZGVjb2RlZCA9IHRva2Vuc1RvT2JqZWN0KHRva2VuaXNlciwgb3B0aW9ucyk7XG4gIGlmIChkZWNvZGVkID09PSBET05FKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBkaWQgbm90IGZpbmQgYW55IGNvbnRlbnQgdG8gZGVjb2RlYCk7XG4gIH1cbiAgaWYgKGRlY29kZWQgPT09IEJSRUFLKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBnb3QgdW5leHBlY3RlZCBicmVha2ApO1xuICB9XG4gIGlmICghdG9rZW5pc2VyLmRvbmUoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gdG9vIG1hbnkgdGVybWluYWxzLCBkYXRhIG1ha2VzIG5vIHNlbnNlYCk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5leHBvcnQge1xuICBUb2tlbmlzZXIsXG4gIHRva2Vuc1RvT2JqZWN0LFxuICBkZWNvZGVcbn07IiwiaW1wb3J0IHsgaXMgfSBmcm9tICcuL2lzLmpzJztcbmltcG9ydCB7XG4gIFRva2VuLFxuICBUeXBlXG59IGZyb20gJy4vdG9rZW4uanMnO1xuaW1wb3J0IHsgQmwgfSBmcm9tICcuL2JsLmpzJztcbmltcG9ydCB7IGVuY29kZUVyclByZWZpeCB9IGZyb20gJy4vY29tbW9uLmpzJztcbmltcG9ydCB7IHF1aWNrRW5jb2RlVG9rZW4gfSBmcm9tICcuL2p1bXAuanMnO1xuaW1wb3J0IHsgYXNVOEEgfSBmcm9tICcuL2J5dGUtdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5jb2RlVWludCB9IGZyb20gJy4vMHVpbnQuanMnO1xuaW1wb3J0IHsgZW5jb2RlTmVnaW50IH0gZnJvbSAnLi8xbmVnaW50LmpzJztcbmltcG9ydCB7IGVuY29kZUJ5dGVzIH0gZnJvbSAnLi8yYnl0ZXMuanMnO1xuaW1wb3J0IHsgZW5jb2RlU3RyaW5nIH0gZnJvbSAnLi8zc3RyaW5nLmpzJztcbmltcG9ydCB7IGVuY29kZUFycmF5IH0gZnJvbSAnLi80YXJyYXkuanMnO1xuaW1wb3J0IHsgZW5jb2RlTWFwIH0gZnJvbSAnLi81bWFwLmpzJztcbmltcG9ydCB7IGVuY29kZVRhZyB9IGZyb20gJy4vNnRhZy5qcyc7XG5pbXBvcnQgeyBlbmNvZGVGbG9hdCB9IGZyb20gJy4vN2Zsb2F0LmpzJztcbmNvbnN0IGRlZmF1bHRFbmNvZGVPcHRpb25zID0ge1xuICBmbG9hdDY0OiBmYWxzZSxcbiAgbWFwU29ydGVyLFxuICBxdWlja0VuY29kZVRva2VuXG59O1xuY29uc3QgY2JvckVuY29kZXJzID0gW107XG5jYm9yRW5jb2RlcnNbVHlwZS51aW50Lm1ham9yXSA9IGVuY29kZVVpbnQ7XG5jYm9yRW5jb2RlcnNbVHlwZS5uZWdpbnQubWFqb3JdID0gZW5jb2RlTmVnaW50O1xuY2JvckVuY29kZXJzW1R5cGUuYnl0ZXMubWFqb3JdID0gZW5jb2RlQnl0ZXM7XG5jYm9yRW5jb2RlcnNbVHlwZS5zdHJpbmcubWFqb3JdID0gZW5jb2RlU3RyaW5nO1xuY2JvckVuY29kZXJzW1R5cGUuYXJyYXkubWFqb3JdID0gZW5jb2RlQXJyYXk7XG5jYm9yRW5jb2RlcnNbVHlwZS5tYXAubWFqb3JdID0gZW5jb2RlTWFwO1xuY2JvckVuY29kZXJzW1R5cGUudGFnLm1ham9yXSA9IGVuY29kZVRhZztcbmNib3JFbmNvZGVyc1tUeXBlLmZsb2F0Lm1ham9yXSA9IGVuY29kZUZsb2F0O1xuY29uc3QgYnVmID0gbmV3IEJsKCk7XG5jbGFzcyBSZWYge1xuICBjb25zdHJ1Y3RvcihvYmosIHBhcmVudCkge1xuICAgIHRoaXMub2JqID0gb2JqO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGluY2x1ZGVzKG9iaikge1xuICAgIGxldCBwID0gdGhpcztcbiAgICBkbyB7XG4gICAgICBpZiAocC5vYmogPT09IG9iaikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChwID0gcC5wYXJlbnQpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlQ2hlY2soc3RhY2ssIG9iaikge1xuICAgIGlmIChzdGFjayAmJiBzdGFjay5pbmNsdWRlcyhvYmopKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGVuY29kZUVyclByZWZpeCB9IG9iamVjdCBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzYCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVmKG9iaiwgc3RhY2spO1xuICB9XG59XG5jb25zdCBzaW1wbGVUb2tlbnMgPSB7XG4gIG51bGw6IG5ldyBUb2tlbihUeXBlLm51bGwsIG51bGwpLFxuICB1bmRlZmluZWQ6IG5ldyBUb2tlbihUeXBlLnVuZGVmaW5lZCwgdW5kZWZpbmVkKSxcbiAgdHJ1ZTogbmV3IFRva2VuKFR5cGUudHJ1ZSwgdHJ1ZSksXG4gIGZhbHNlOiBuZXcgVG9rZW4oVHlwZS5mYWxzZSwgZmFsc2UpLFxuICBlbXB0eUFycmF5OiBuZXcgVG9rZW4oVHlwZS5hcnJheSwgMCksXG4gIGVtcHR5TWFwOiBuZXcgVG9rZW4oVHlwZS5tYXAsIDApXG59O1xuY29uc3QgdHlwZUVuY29kZXJzID0ge1xuICBudW1iZXIob2JqLCBfdHlwLCBfb3B0aW9ucywgX3JlZlN0YWNrKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG9iaikgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKG9iaikpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS5mbG9hdCwgb2JqKTtcbiAgICB9IGVsc2UgaWYgKG9iaiA+PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKFR5cGUudWludCwgb2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLm5lZ2ludCwgb2JqKTtcbiAgICB9XG4gIH0sXG4gIGJpZ2ludChvYmosIF90eXAsIF9vcHRpb25zLCBfcmVmU3RhY2spIHtcbiAgICBpZiAob2JqID49IEJpZ0ludCgwKSkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLnVpbnQsIG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS5uZWdpbnQsIG9iaik7XG4gICAgfVxuICB9LFxuICBVaW50OEFycmF5KG9iaiwgX3R5cCwgX29wdGlvbnMsIF9yZWZTdGFjaykge1xuICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS5ieXRlcywgb2JqKTtcbiAgfSxcbiAgc3RyaW5nKG9iaiwgX3R5cCwgX29wdGlvbnMsIF9yZWZTdGFjaykge1xuICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS5zdHJpbmcsIG9iaik7XG4gIH0sXG4gIGJvb2xlYW4ob2JqLCBfdHlwLCBfb3B0aW9ucywgX3JlZlN0YWNrKSB7XG4gICAgcmV0dXJuIG9iaiA/IHNpbXBsZVRva2Vucy50cnVlIDogc2ltcGxlVG9rZW5zLmZhbHNlO1xuICB9LFxuICBudWxsKF9vYmosIF90eXAsIF9vcHRpb25zLCBfcmVmU3RhY2spIHtcbiAgICByZXR1cm4gc2ltcGxlVG9rZW5zLm51bGw7XG4gIH0sXG4gIHVuZGVmaW5lZChfb2JqLCBfdHlwLCBfb3B0aW9ucywgX3JlZlN0YWNrKSB7XG4gICAgcmV0dXJuIHNpbXBsZVRva2Vucy51bmRlZmluZWQ7XG4gIH0sXG4gIEFycmF5QnVmZmVyKG9iaiwgX3R5cCwgX29wdGlvbnMsIF9yZWZTdGFjaykge1xuICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS5ieXRlcywgbmV3IFVpbnQ4QXJyYXkob2JqKSk7XG4gIH0sXG4gIERhdGFWaWV3KG9iaiwgX3R5cCwgX29wdGlvbnMsIF9yZWZTdGFjaykge1xuICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS5ieXRlcywgbmV3IFVpbnQ4QXJyYXkob2JqLmJ1ZmZlciwgb2JqLmJ5dGVPZmZzZXQsIG9iai5ieXRlTGVuZ3RoKSk7XG4gIH0sXG4gIEFycmF5KG9iaiwgX3R5cCwgb3B0aW9ucywgcmVmU3RhY2spIHtcbiAgICBpZiAoIW9iai5sZW5ndGgpIHtcbiAgICAgIGlmIChvcHRpb25zLmFkZEJyZWFrVG9rZW5zID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgc2ltcGxlVG9rZW5zLmVtcHR5QXJyYXksXG4gICAgICAgICAgbmV3IFRva2VuKFR5cGUuYnJlYWspXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2ltcGxlVG9rZW5zLmVtcHR5QXJyYXk7XG4gICAgfVxuICAgIHJlZlN0YWNrID0gUmVmLmNyZWF0ZUNoZWNrKHJlZlN0YWNrLCBvYmopO1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBlIG9mIG9iaikge1xuICAgICAgZW50cmllc1tpKytdID0gb2JqZWN0VG9Ub2tlbnMoZSwgb3B0aW9ucywgcmVmU3RhY2spO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hZGRCcmVha1Rva2Vucykge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFRva2VuKFR5cGUuYXJyYXksIG9iai5sZW5ndGgpLFxuICAgICAgICBlbnRyaWVzLFxuICAgICAgICBuZXcgVG9rZW4oVHlwZS5icmVhaylcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBuZXcgVG9rZW4oVHlwZS5hcnJheSwgb2JqLmxlbmd0aCksXG4gICAgICBlbnRyaWVzXG4gICAgXTtcbiAgfSxcbiAgT2JqZWN0KG9iaiwgdHlwLCBvcHRpb25zLCByZWZTdGFjaykge1xuICAgIGNvbnN0IGlzTWFwID0gdHlwICE9PSAnT2JqZWN0JztcbiAgICBjb25zdCBrZXlzID0gaXNNYXAgPyBvYmoua2V5cygpIDogT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBsZW5ndGggPSBpc01hcCA/IG9iai5zaXplIDoga2V5cy5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIGlmIChvcHRpb25zLmFkZEJyZWFrVG9rZW5zID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgc2ltcGxlVG9rZW5zLmVtcHR5TWFwLFxuICAgICAgICAgIG5ldyBUb2tlbihUeXBlLmJyZWFrKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpbXBsZVRva2Vucy5lbXB0eU1hcDtcbiAgICB9XG4gICAgcmVmU3RhY2sgPSBSZWYuY3JlYXRlQ2hlY2socmVmU3RhY2ssIG9iaik7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBlbnRyaWVzW2krK10gPSBbXG4gICAgICAgIG9iamVjdFRvVG9rZW5zKGtleSwgb3B0aW9ucywgcmVmU3RhY2spLFxuICAgICAgICBvYmplY3RUb1Rva2Vucyhpc01hcCA/IG9iai5nZXQoa2V5KSA6IG9ialtrZXldLCBvcHRpb25zLCByZWZTdGFjaylcbiAgICAgIF07XG4gICAgfVxuICAgIHNvcnRNYXBFbnRyaWVzKGVudHJpZXMsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmFkZEJyZWFrVG9rZW5zKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBuZXcgVG9rZW4oVHlwZS5tYXAsIGxlbmd0aCksXG4gICAgICAgIGVudHJpZXMsXG4gICAgICAgIG5ldyBUb2tlbihUeXBlLmJyZWFrKVxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBUb2tlbihUeXBlLm1hcCwgbGVuZ3RoKSxcbiAgICAgIGVudHJpZXNcbiAgICBdO1xuICB9XG59O1xudHlwZUVuY29kZXJzLk1hcCA9IHR5cGVFbmNvZGVycy5PYmplY3Q7XG50eXBlRW5jb2RlcnMuQnVmZmVyID0gdHlwZUVuY29kZXJzLlVpbnQ4QXJyYXk7XG5mb3IgKGNvbnN0IHR5cCBvZiAnVWludDhDbGFtcGVkIFVpbnQxNiBVaW50MzIgSW50OCBJbnQxNiBJbnQzMiBCaWdVaW50NjQgQmlnSW50NjQgRmxvYXQzMiBGbG9hdDY0Jy5zcGxpdCgnICcpKSB7XG4gIHR5cGVFbmNvZGVyc1tgJHsgdHlwIH1BcnJheWBdID0gdHlwZUVuY29kZXJzLkRhdGFWaWV3O1xufVxuZnVuY3Rpb24gb2JqZWN0VG9Ub2tlbnMob2JqLCBvcHRpb25zID0ge30sIHJlZlN0YWNrKSB7XG4gIGNvbnN0IHR5cCA9IGlzKG9iaik7XG4gIGNvbnN0IGN1c3RvbVR5cGVFbmNvZGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGVFbmNvZGVycyAmJiBvcHRpb25zLnR5cGVFbmNvZGVyc1t0eXBdIHx8IHR5cGVFbmNvZGVyc1t0eXBdO1xuICBpZiAodHlwZW9mIGN1c3RvbVR5cGVFbmNvZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgdG9rZW5zID0gY3VzdG9tVHlwZUVuY29kZXIob2JqLCB0eXAsIG9wdGlvbnMsIHJlZlN0YWNrKTtcbiAgICBpZiAodG9rZW5zICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICB9XG4gIGNvbnN0IHR5cGVFbmNvZGVyID0gdHlwZUVuY29kZXJzW3R5cF07XG4gIGlmICghdHlwZUVuY29kZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGVuY29kZUVyclByZWZpeCB9IHVuc3VwcG9ydGVkIHR5cGU6ICR7IHR5cCB9YCk7XG4gIH1cbiAgcmV0dXJuIHR5cGVFbmNvZGVyKG9iaiwgdHlwLCBvcHRpb25zLCByZWZTdGFjayk7XG59XG5mdW5jdGlvbiBzb3J0TWFwRW50cmllcyhlbnRyaWVzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLm1hcFNvcnRlcikge1xuICAgIGVudHJpZXMuc29ydChvcHRpb25zLm1hcFNvcnRlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcFNvcnRlcihlMSwgZTIpIHtcbiAgY29uc3Qga2V5VG9rZW4xID0gQXJyYXkuaXNBcnJheShlMVswXSkgPyBlMVswXVswXSA6IGUxWzBdO1xuICBjb25zdCBrZXlUb2tlbjIgPSBBcnJheS5pc0FycmF5KGUyWzBdKSA/IGUyWzBdWzBdIDogZTJbMF07XG4gIGlmIChrZXlUb2tlbjEudHlwZSAhPT0ga2V5VG9rZW4yLnR5cGUpIHtcbiAgICByZXR1cm4ga2V5VG9rZW4xLnR5cGUuY29tcGFyZShrZXlUb2tlbjIudHlwZSk7XG4gIH1cbiAgY29uc3QgbWFqb3IgPSBrZXlUb2tlbjEudHlwZS5tYWpvcjtcbiAgY29uc3QgdGNtcCA9IGNib3JFbmNvZGVyc1ttYWpvcl0uY29tcGFyZVRva2VucyhrZXlUb2tlbjEsIGtleVRva2VuMik7XG4gIGlmICh0Y21wID09PSAwKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBjb21wbGV4IGtleSB0eXBlcyB1c2VkLCBDQk9SIGtleSBzb3J0aW5nIGd1YXJhbnRlZXMgYXJlIGdvbmUnKTtcbiAgfVxuICByZXR1cm4gdGNtcDtcbn1cbmZ1bmN0aW9uIHRva2Vuc1RvRW5jb2RlZChidWYsIHRva2VucywgZW5jb2RlcnMsIG9wdGlvbnMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW5zKSkge1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICB0b2tlbnNUb0VuY29kZWQoYnVmLCB0b2tlbiwgZW5jb2RlcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlbmNvZGVyc1t0b2tlbnMudHlwZS5tYWpvcl0oYnVmLCB0b2tlbnMsIG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBlbmNvZGVDdXN0b20oZGF0YSwgZW5jb2RlcnMsIG9wdGlvbnMpIHtcbiAgY29uc3QgdG9rZW5zID0gb2JqZWN0VG9Ub2tlbnMoZGF0YSwgb3B0aW9ucyk7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0b2tlbnMpICYmIG9wdGlvbnMucXVpY2tFbmNvZGVUb2tlbikge1xuICAgIGNvbnN0IHF1aWNrQnl0ZXMgPSBvcHRpb25zLnF1aWNrRW5jb2RlVG9rZW4odG9rZW5zKTtcbiAgICBpZiAocXVpY2tCeXRlcykge1xuICAgICAgcmV0dXJuIHF1aWNrQnl0ZXM7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGVyc1t0b2tlbnMudHlwZS5tYWpvcl07XG4gICAgaWYgKGVuY29kZXIuZW5jb2RlZFNpemUpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBlbmNvZGVyLmVuY29kZWRTaXplKHRva2Vucywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBidWYgPSBuZXcgQmwoc2l6ZSk7XG4gICAgICBlbmNvZGVyKGJ1ZiwgdG9rZW5zLCBvcHRpb25zKTtcbiAgICAgIGlmIChidWYuY2h1bmtzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZXJyb3I6IHByZS1jYWxjdWxhdGVkIGxlbmd0aCBmb3IgJHsgdG9rZW5zIH0gd2FzIHdyb25nYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXNVOEEoYnVmLmNodW5rc1swXSk7XG4gICAgfVxuICB9XG4gIHRva2Vuc1RvRW5jb2RlZChidWYsIHRva2VucywgZW5jb2RlcnMsIG9wdGlvbnMpO1xuICByZXR1cm4gYnVmLnRvQnl0ZXModHJ1ZSk7XG59XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEVuY29kZU9wdGlvbnMsIG9wdGlvbnMpO1xuICByZXR1cm4gZW5jb2RlQ3VzdG9tKGRhdGEsIGNib3JFbmNvZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQge1xuICBvYmplY3RUb1Rva2VucyxcbiAgZW5jb2RlLFxuICBlbmNvZGVDdXN0b20sXG4gIFJlZlxufTsiLCJjb25zdCB0eXBlb2ZzID0gW1xuICAnc3RyaW5nJyxcbiAgJ251bWJlcicsXG4gICdiaWdpbnQnLFxuICAnc3ltYm9sJ1xuXTtcbmNvbnN0IG9iamVjdFR5cGVOYW1lcyA9IFtcbiAgJ0Z1bmN0aW9uJyxcbiAgJ0dlbmVyYXRvcicsXG4gICdBc3luY0dlbmVyYXRvcicsXG4gICdHZW5lcmF0b3JGdW5jdGlvbicsXG4gICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJyxcbiAgJ0FzeW5jRnVuY3Rpb24nLFxuICAnT2JzZXJ2YWJsZScsXG4gICdBcnJheScsXG4gICdCdWZmZXInLFxuICAnT2JqZWN0JyxcbiAgJ1JlZ0V4cCcsXG4gICdEYXRlJyxcbiAgJ0Vycm9yJyxcbiAgJ01hcCcsXG4gICdTZXQnLFxuICAnV2Vha01hcCcsXG4gICdXZWFrU2V0JyxcbiAgJ0FycmF5QnVmZmVyJyxcbiAgJ1NoYXJlZEFycmF5QnVmZmVyJyxcbiAgJ0RhdGFWaWV3JyxcbiAgJ1Byb21pc2UnLFxuICAnVVJMJyxcbiAgJ0hUTUxFbGVtZW50JyxcbiAgJ0ludDhBcnJheScsXG4gICdVaW50OEFycmF5JyxcbiAgJ1VpbnQ4Q2xhbXBlZEFycmF5JyxcbiAgJ0ludDE2QXJyYXknLFxuICAnVWludDE2QXJyYXknLFxuICAnSW50MzJBcnJheScsXG4gICdVaW50MzJBcnJheScsXG4gICdGbG9hdDMyQXJyYXknLFxuICAnRmxvYXQ2NEFycmF5JyxcbiAgJ0JpZ0ludDY0QXJyYXknLFxuICAnQmlnVWludDY0QXJyYXknXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH1cbiAgaWYgKHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgIHJldHVybiAnYm9vbGVhbic7XG4gIH1cbiAgY29uc3QgdHlwZU9mID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZW9mcy5pbmNsdWRlcyh0eXBlT2YpKSB7XG4gICAgcmV0dXJuIHR5cGVPZjtcbiAgfVxuICBpZiAodHlwZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuICdGdW5jdGlvbic7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuICdBcnJheSc7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiAnQnVmZmVyJztcbiAgfVxuICBjb25zdCBvYmplY3RUeXBlID0gZ2V0T2JqZWN0VHlwZSh2YWx1ZSk7XG4gIGlmIChvYmplY3RUeXBlKSB7XG4gICAgcmV0dXJuIG9iamVjdFR5cGU7XG4gIH1cbiAgcmV0dXJuICdPYmplY3QnO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIHZhbHVlLmNvbnN0cnVjdG9yLmlzQnVmZmVyLmNhbGwobnVsbCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0T2JqZWN0VHlwZSh2YWx1ZSkge1xuICBjb25zdCBvYmplY3RUeXBlTmFtZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xuICBpZiAob2JqZWN0VHlwZU5hbWVzLmluY2x1ZGVzKG9iamVjdFR5cGVOYW1lKSkge1xuICAgIHJldHVybiBvYmplY3RUeXBlTmFtZTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufSIsImltcG9ydCB7XG4gIFRva2VuLFxuICBUeXBlXG59IGZyb20gJy4vdG9rZW4uanMnO1xuaW1wb3J0ICogYXMgdWludCBmcm9tICcuLzB1aW50LmpzJztcbmltcG9ydCAqIGFzIG5lZ2ludCBmcm9tICcuLzFuZWdpbnQuanMnO1xuaW1wb3J0ICogYXMgYnl0ZXMgZnJvbSAnLi8yYnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgc3RyaW5nIGZyb20gJy4vM3N0cmluZy5qcyc7XG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICcuLzRhcnJheS5qcyc7XG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnLi81bWFwLmpzJztcbmltcG9ydCAqIGFzIHRhZyBmcm9tICcuLzZ0YWcuanMnO1xuaW1wb3J0ICogYXMgZmxvYXQgZnJvbSAnLi83ZmxvYXQuanMnO1xuaW1wb3J0IHsgZGVjb2RlRXJyUHJlZml4IH0gZnJvbSAnLi9jb21tb24uanMnO1xuaW1wb3J0IHsgZnJvbUFycmF5IH0gZnJvbSAnLi9ieXRlLXV0aWxzLmpzJztcbmZ1bmN0aW9uIGludmFsaWRNaW5vcihkYXRhLCBwb3MsIG1pbm9yKSB7XG4gIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gZW5jb3VudGVyZWQgaW52YWxpZCBtaW5vciAoJHsgbWlub3IgfSkgZm9yIG1ham9yICR7IGRhdGFbcG9zXSA+Pj4gNSB9YCk7XG59XG5mdW5jdGlvbiBlcnJvcmVyKG1zZykge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gJHsgbXNnIH1gKTtcbiAgfTtcbn1cbmV4cG9ydCBjb25zdCBqdW1wID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8PSAyMzsgaSsrKSB7XG4gIGp1bXBbaV0gPSBpbnZhbGlkTWlub3I7XG59XG5qdW1wWzI0XSA9IHVpbnQuZGVjb2RlVWludDg7XG5qdW1wWzI1XSA9IHVpbnQuZGVjb2RlVWludDE2O1xuanVtcFsyNl0gPSB1aW50LmRlY29kZVVpbnQzMjtcbmp1bXBbMjddID0gdWludC5kZWNvZGVVaW50NjQ7XG5qdW1wWzI4XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjldID0gaW52YWxpZE1pbm9yO1xuanVtcFszMF0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzMxXSA9IGludmFsaWRNaW5vcjtcbmZvciAobGV0IGkgPSAzMjsgaSA8PSA1NTsgaSsrKSB7XG4gIGp1bXBbaV0gPSBpbnZhbGlkTWlub3I7XG59XG5qdW1wWzU2XSA9IG5lZ2ludC5kZWNvZGVOZWdpbnQ4O1xuanVtcFs1N10gPSBuZWdpbnQuZGVjb2RlTmVnaW50MTY7XG5qdW1wWzU4XSA9IG5lZ2ludC5kZWNvZGVOZWdpbnQzMjtcbmp1bXBbNTldID0gbmVnaW50LmRlY29kZU5lZ2ludDY0O1xuanVtcFs2MF0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzYxXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbNjJdID0gaW52YWxpZE1pbm9yO1xuanVtcFs2M10gPSBpbnZhbGlkTWlub3I7XG5mb3IgKGxldCBpID0gNjQ7IGkgPD0gODc7IGkrKykge1xuICBqdW1wW2ldID0gYnl0ZXMuZGVjb2RlQnl0ZXNDb21wYWN0O1xufVxuanVtcFs4OF0gPSBieXRlcy5kZWNvZGVCeXRlczg7XG5qdW1wWzg5XSA9IGJ5dGVzLmRlY29kZUJ5dGVzMTY7XG5qdW1wWzkwXSA9IGJ5dGVzLmRlY29kZUJ5dGVzMzI7XG5qdW1wWzkxXSA9IGJ5dGVzLmRlY29kZUJ5dGVzNjQ7XG5qdW1wWzkyXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbOTNdID0gaW52YWxpZE1pbm9yO1xuanVtcFs5NF0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzk1XSA9IGVycm9yZXIoJ2luZGVmaW5pdGUgbGVuZ3RoIGJ5dGVzL3N0cmluZ3MgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbmZvciAobGV0IGkgPSA5NjsgaSA8PSAxMTk7IGkrKykge1xuICBqdW1wW2ldID0gc3RyaW5nLmRlY29kZVN0cmluZ0NvbXBhY3Q7XG59XG5qdW1wWzEyMF0gPSBzdHJpbmcuZGVjb2RlU3RyaW5nODtcbmp1bXBbMTIxXSA9IHN0cmluZy5kZWNvZGVTdHJpbmcxNjtcbmp1bXBbMTIyXSA9IHN0cmluZy5kZWNvZGVTdHJpbmczMjtcbmp1bXBbMTIzXSA9IHN0cmluZy5kZWNvZGVTdHJpbmc2NDtcbmp1bXBbMTI0XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMTI1XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMTI2XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMTI3XSA9IGVycm9yZXIoJ2luZGVmaW5pdGUgbGVuZ3RoIGJ5dGVzL3N0cmluZ3MgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbmZvciAobGV0IGkgPSAxMjg7IGkgPD0gMTUxOyBpKyspIHtcbiAganVtcFtpXSA9IGFycmF5LmRlY29kZUFycmF5Q29tcGFjdDtcbn1cbmp1bXBbMTUyXSA9IGFycmF5LmRlY29kZUFycmF5ODtcbmp1bXBbMTUzXSA9IGFycmF5LmRlY29kZUFycmF5MTY7XG5qdW1wWzE1NF0gPSBhcnJheS5kZWNvZGVBcnJheTMyO1xuanVtcFsxNTVdID0gYXJyYXkuZGVjb2RlQXJyYXk2NDtcbmp1bXBbMTU2XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMTU3XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMTU4XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMTU5XSA9IGFycmF5LmRlY29kZUFycmF5SW5kZWZpbml0ZTtcbmZvciAobGV0IGkgPSAxNjA7IGkgPD0gMTgzOyBpKyspIHtcbiAganVtcFtpXSA9IG1hcC5kZWNvZGVNYXBDb21wYWN0O1xufVxuanVtcFsxODRdID0gbWFwLmRlY29kZU1hcDg7XG5qdW1wWzE4NV0gPSBtYXAuZGVjb2RlTWFwMTY7XG5qdW1wWzE4Nl0gPSBtYXAuZGVjb2RlTWFwMzI7XG5qdW1wWzE4N10gPSBtYXAuZGVjb2RlTWFwNjQ7XG5qdW1wWzE4OF0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzE4OV0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzE5MF0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzE5MV0gPSBtYXAuZGVjb2RlTWFwSW5kZWZpbml0ZTtcbmZvciAobGV0IGkgPSAxOTI7IGkgPD0gMjE1OyBpKyspIHtcbiAganVtcFtpXSA9IHRhZy5kZWNvZGVUYWdDb21wYWN0O1xufVxuanVtcFsyMTZdID0gdGFnLmRlY29kZVRhZzg7XG5qdW1wWzIxN10gPSB0YWcuZGVjb2RlVGFnMTY7XG5qdW1wWzIxOF0gPSB0YWcuZGVjb2RlVGFnMzI7XG5qdW1wWzIxOV0gPSB0YWcuZGVjb2RlVGFnNjQ7XG5qdW1wWzIyMF0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzIyMV0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzIyMl0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzIyM10gPSBpbnZhbGlkTWlub3I7XG5mb3IgKGxldCBpID0gMjI0OyBpIDw9IDI0MzsgaSsrKSB7XG4gIGp1bXBbaV0gPSBlcnJvcmVyKCdzaW1wbGUgdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG59XG5qdW1wWzI0NF0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzI0NV0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzI0Nl0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzI0N10gPSBmbG9hdC5kZWNvZGVVbmRlZmluZWQ7XG5qdW1wWzI0OF0gPSBlcnJvcmVyKCdzaW1wbGUgdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG5qdW1wWzI0OV0gPSBmbG9hdC5kZWNvZGVGbG9hdDE2O1xuanVtcFsyNTBdID0gZmxvYXQuZGVjb2RlRmxvYXQzMjtcbmp1bXBbMjUxXSA9IGZsb2F0LmRlY29kZUZsb2F0NjQ7XG5qdW1wWzI1Ml0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzI1M10gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzI1NF0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzI1NV0gPSBmbG9hdC5kZWNvZGVCcmVhaztcbmV4cG9ydCBjb25zdCBxdWljayA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gIHF1aWNrW2ldID0gbmV3IFRva2VuKFR5cGUudWludCwgaSwgMSk7XG59XG5mb3IgKGxldCBpID0gLTE7IGkgPj0gLTI0OyBpLS0pIHtcbiAgcXVpY2tbMzEgLSBpXSA9IG5ldyBUb2tlbihUeXBlLm5lZ2ludCwgaSwgMSk7XG59XG5xdWlja1s2NF0gPSBuZXcgVG9rZW4oVHlwZS5ieXRlcywgbmV3IFVpbnQ4QXJyYXkoMCksIDEpO1xucXVpY2tbOTZdID0gbmV3IFRva2VuKFR5cGUuc3RyaW5nLCAnJywgMSk7XG5xdWlja1sxMjhdID0gbmV3IFRva2VuKFR5cGUuYXJyYXksIDAsIDEpO1xucXVpY2tbMTYwXSA9IG5ldyBUb2tlbihUeXBlLm1hcCwgMCwgMSk7XG5xdWlja1syNDRdID0gbmV3IFRva2VuKFR5cGUuZmFsc2UsIGZhbHNlLCAxKTtcbnF1aWNrWzI0NV0gPSBuZXcgVG9rZW4oVHlwZS50cnVlLCB0cnVlLCAxKTtcbnF1aWNrWzI0Nl0gPSBuZXcgVG9rZW4oVHlwZS5udWxsLCBudWxsLCAxKTtcbmV4cG9ydCBmdW5jdGlvbiBxdWlja0VuY29kZVRva2VuKHRva2VuKSB7XG4gIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICBjYXNlIFR5cGUuZmFsc2U6XG4gICAgcmV0dXJuIGZyb21BcnJheShbMjQ0XSk7XG4gIGNhc2UgVHlwZS50cnVlOlxuICAgIHJldHVybiBmcm9tQXJyYXkoWzI0NV0pO1xuICBjYXNlIFR5cGUubnVsbDpcbiAgICByZXR1cm4gZnJvbUFycmF5KFsyNDZdKTtcbiAgY2FzZSBUeXBlLmJ5dGVzOlxuICAgIGlmICghdG9rZW4udmFsdWUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5KFs2NF0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIGNhc2UgVHlwZS5zdHJpbmc6XG4gICAgaWYgKHRva2VuLnZhbHVlID09PSAnJykge1xuICAgICAgcmV0dXJuIGZyb21BcnJheShbOTZdKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICBjYXNlIFR5cGUuYXJyYXk6XG4gICAgaWYgKHRva2VuLnZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5KFsxMjhdKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICBjYXNlIFR5cGUubWFwOlxuICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheShbMTYwXSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgY2FzZSBUeXBlLnVpbnQ6XG4gICAgaWYgKHRva2VuLnZhbHVlIDwgMjQpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXkoW051bWJlcih0b2tlbi52YWx1ZSldKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICBjYXNlIFR5cGUubmVnaW50OlxuICAgIGlmICh0b2tlbi52YWx1ZSA+PSAtMjQpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXkoWzMxIC0gTnVtYmVyKHRva2VuLnZhbHVlKV0pO1xuICAgIH1cbiAgfVxufSIsImNsYXNzIFR5cGUge1xuICBjb25zdHJ1Y3RvcihtYWpvciwgbmFtZSwgdGVybWluYWwpIHtcbiAgICB0aGlzLm1ham9yID0gbWFqb3I7XG4gICAgdGhpcy5tYWpvckVuY29kZWQgPSBtYWpvciA8PCA1O1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50ZXJtaW5hbCA9IHRlcm1pbmFsO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgVHlwZVskeyB0aGlzLm1ham9yIH1dLiR7IHRoaXMubmFtZSB9YDtcbiAgfVxuICBjb21wYXJlKHR5cCkge1xuICAgIHJldHVybiB0aGlzLm1ham9yIDwgdHlwLm1ham9yID8gLTEgOiB0aGlzLm1ham9yID4gdHlwLm1ham9yID8gMSA6IDA7XG4gIH1cbn1cblR5cGUudWludCA9IG5ldyBUeXBlKDAsICd1aW50JywgdHJ1ZSk7XG5UeXBlLm5lZ2ludCA9IG5ldyBUeXBlKDEsICduZWdpbnQnLCB0cnVlKTtcblR5cGUuYnl0ZXMgPSBuZXcgVHlwZSgyLCAnYnl0ZXMnLCB0cnVlKTtcblR5cGUuc3RyaW5nID0gbmV3IFR5cGUoMywgJ3N0cmluZycsIHRydWUpO1xuVHlwZS5hcnJheSA9IG5ldyBUeXBlKDQsICdhcnJheScsIGZhbHNlKTtcblR5cGUubWFwID0gbmV3IFR5cGUoNSwgJ21hcCcsIGZhbHNlKTtcblR5cGUudGFnID0gbmV3IFR5cGUoNiwgJ3RhZycsIGZhbHNlKTtcblR5cGUuZmxvYXQgPSBuZXcgVHlwZSg3LCAnZmxvYXQnLCB0cnVlKTtcblR5cGUuZmFsc2UgPSBuZXcgVHlwZSg3LCAnZmFsc2UnLCB0cnVlKTtcblR5cGUudHJ1ZSA9IG5ldyBUeXBlKDcsICd0cnVlJywgdHJ1ZSk7XG5UeXBlLm51bGwgPSBuZXcgVHlwZSg3LCAnbnVsbCcsIHRydWUpO1xuVHlwZS51bmRlZmluZWQgPSBuZXcgVHlwZSg3LCAndW5kZWZpbmVkJywgdHJ1ZSk7XG5UeXBlLmJyZWFrID0gbmV3IFR5cGUoNywgJ2JyZWFrJywgdHJ1ZSk7XG5jbGFzcyBUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHZhbHVlLCBlbmNvZGVkTGVuZ3RoKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5lbmNvZGVkTGVuZ3RoID0gZW5jb2RlZExlbmd0aDtcbiAgICB0aGlzLmVuY29kZWRCeXRlcyA9IHVuZGVmaW5lZDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFRva2VuWyR7IHRoaXMudHlwZSB9XS4keyB0aGlzLnZhbHVlIH1gO1xuICB9XG59XG5leHBvcnQge1xuICBUeXBlLFxuICBUb2tlblxufTsiLCJleHBvcnQgZGVmYXVsdCAoKSA9PiB7XG59OyIsImltcG9ydCBlcnJDb2RlIGZyb20gJ2Vyci1jb2RlJztcbmltcG9ydCBpdFBlZWthYmxlIGZyb20gJ2l0LXBlZWthYmxlJztcbmltcG9ydCBicm93c2VyU3RyZWFtVG9JdCBmcm9tICdicm93c2VyLXJlYWRhYmxlc3RyZWFtLXRvLWl0JztcbmltcG9ydCBhbGwgZnJvbSAnaXQtYWxsJztcbmltcG9ydCB7XG4gIGlzQnl0ZXMsXG4gIGlzQmxvYixcbiAgaXNSZWFkYWJsZVN0cmVhbVxufSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBub3JtYWxpc2VDb250ZW50KGlucHV0KSB7XG4gIGlmIChpc0J5dGVzKGlucHV0KSkge1xuICAgIHJldHVybiBuZXcgQmxvYihbaW5wdXRdKTtcbiAgfVxuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIHJldHVybiBuZXcgQmxvYihbaW5wdXQudG9TdHJpbmcoKV0pO1xuICB9XG4gIGlmIChpc0Jsb2IoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGlucHV0KSkge1xuICAgIGlucHV0ID0gYnJvd3NlclN0cmVhbVRvSXQoaW5wdXQpO1xuICB9XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQgfHwgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICBjb25zdCBwZWVrYWJsZSA9IGl0UGVla2FibGUoaW5wdXQpO1xuICAgIGNvbnN0IHt2YWx1ZSwgZG9uZX0gPSBhd2FpdCBwZWVrYWJsZS5wZWVrKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiBpdFRvQmxvYihwZWVrYWJsZSk7XG4gICAgfVxuICAgIHBlZWthYmxlLnB1c2godmFsdWUpO1xuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIG5ldyBCbG9iKFtVaW50OEFycmF5LmZyb20oYXdhaXQgYWxsKHBlZWthYmxlKSldKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHJldHVybiBpdFRvQmxvYihwZWVrYWJsZSk7XG4gICAgfVxuICB9XG4gIHRocm93IGVyckNvZGUobmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0OiAkeyBpbnB1dCB9YCksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xufVxuYXN5bmMgZnVuY3Rpb24gaXRUb0Jsb2Ioc3RyZWFtKSB7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgcGFydHMucHVzaChjaHVuayk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9iKHBhcnRzKTtcbn0iLCJpbXBvcnQgeyBub3JtYWxpc2VDb250ZW50IH0gZnJvbSAnLi9ub3JtYWxpc2UtY29udGVudC5icm93c2VyLmpzJztcbmltcG9ydCB7IG5vcm1hbGlzZSB9IGZyb20gJy4vbm9ybWFsaXNlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpc2VJbnB1dChpbnB1dCkge1xuICByZXR1cm4gbm9ybWFsaXNlKGlucHV0LCBub3JtYWxpc2VDb250ZW50KTtcbn0iLCJpbXBvcnQgZXJyQ29kZSBmcm9tICdlcnItY29kZSc7XG5pbXBvcnQgYnJvd3NlclN0cmVhbVRvSXQgZnJvbSAnYnJvd3Nlci1yZWFkYWJsZXN0cmVhbS10by1pdCc7XG5pbXBvcnQgaXRQZWVrYWJsZSBmcm9tICdpdC1wZWVrYWJsZSc7XG5pbXBvcnQgbWFwIGZyb20gJ2l0LW1hcCc7XG5pbXBvcnQge1xuICBpc0J5dGVzLFxuICBpc0Jsb2IsXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzRmlsZU9iamVjdFxufSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7XG4gIHBhcnNlTXRpbWUsXG4gIHBhcnNlTW9kZVxufSBmcm9tICdpcGZzLXVuaXhmcyc7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIG5vcm1hbGlzZShpbnB1dCwgbm9ybWFsaXNlQ29udGVudCkge1xuICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0OiAkeyBpbnB1dCB9YCksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgeWllbGQgdG9GaWxlT2JqZWN0KGlucHV0LnRvU3RyaW5nKCksIG5vcm1hbGlzZUNvbnRlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNCeXRlcyhpbnB1dCkgfHwgaXNCbG9iKGlucHV0KSkge1xuICAgIHlpZWxkIHRvRmlsZU9iamVjdChpbnB1dCwgbm9ybWFsaXNlQ29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGlucHV0KSkge1xuICAgIGlucHV0ID0gYnJvd3NlclN0cmVhbVRvSXQoaW5wdXQpO1xuICB9XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQgfHwgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICBjb25zdCBwZWVrYWJsZSA9IGl0UGVla2FibGUoaW5wdXQpO1xuICAgIGNvbnN0IHt2YWx1ZSwgZG9uZX0gPSBhd2FpdCBwZWVrYWJsZS5wZWVrKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHlpZWxkKiBbXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVla2FibGUucHVzaCh2YWx1ZSk7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICB5aWVsZCB0b0ZpbGVPYmplY3QocGVla2FibGUsIG5vcm1hbGlzZUNvbnRlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHlpZWxkKiBtYXAocGVla2FibGUsIHZhbHVlID0+IHRvRmlsZU9iamVjdCh7IGNvbnRlbnQ6IHZhbHVlIH0sIG5vcm1hbGlzZUNvbnRlbnQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRmlsZU9iamVjdCh2YWx1ZSkgfHwgaXNCbG9iKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICB5aWVsZCogbWFwKHBlZWthYmxlLCB2YWx1ZSA9PiB0b0ZpbGVPYmplY3QodmFsdWUsIG5vcm1hbGlzZUNvbnRlbnQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0gfHwgdmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdIHx8IGlzUmVhZGFibGVTdHJlYW0odmFsdWUpKSB7XG4gICAgICB5aWVsZCogbWFwKHBlZWthYmxlLCB2YWx1ZSA9PiB0b0ZpbGVPYmplY3QodmFsdWUsIG5vcm1hbGlzZUNvbnRlbnQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRmlsZU9iamVjdChpbnB1dCkpIHtcbiAgICB5aWVsZCB0b0ZpbGVPYmplY3QoaW5wdXQsIG5vcm1hbGlzZUNvbnRlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogJyArIHR5cGVvZiBpbnB1dCksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xufVxuYXN5bmMgZnVuY3Rpb24gdG9GaWxlT2JqZWN0KGlucHV0LCBub3JtYWxpc2VDb250ZW50KSB7XG4gIGNvbnN0IHtwYXRoLCBtb2RlLCBtdGltZSwgY29udGVudH0gPSBpbnB1dDtcbiAgY29uc3QgZmlsZSA9IHtcbiAgICBwYXRoOiBwYXRoIHx8ICcnLFxuICAgIG1vZGU6IHBhcnNlTW9kZShtb2RlKSxcbiAgICBtdGltZTogcGFyc2VNdGltZShtdGltZSlcbiAgfTtcbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBmaWxlLmNvbnRlbnQgPSBhd2FpdCBub3JtYWxpc2VDb250ZW50KGNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgZmlsZS5jb250ZW50ID0gYXdhaXQgbm9ybWFsaXNlQ29udGVudChpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIGZpbGU7XG59IiwiZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMob2JqKSB7XG4gIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Jsb2Iob2JqKSB7XG4gIHJldHVybiBvYmouY29uc3RydWN0b3IgJiYgKG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQmxvYicgfHwgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdGaWxlJykgJiYgdHlwZW9mIG9iai5zdHJlYW0gPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlT2JqZWN0KG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKG9iai5wYXRoIHx8IG9iai5jb250ZW50KTtcbn1cbmV4cG9ydCBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID0gdmFsdWUgPT4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmdldFJlYWRlciA9PT0gJ2Z1bmN0aW9uJzsiLCJleHBvcnQgZnVuY3Rpb24gbW9kZVRvU3RyaW5nKG1vZGUpIHtcbiAgaWYgKG1vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2RlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtb2RlO1xuICB9XG4gIHJldHVybiBtb2RlLnRvU3RyaW5nKDgpLnBhZFN0YXJ0KDQsICcwJyk7XG59IiwiY29uc3QgTE9BRF9CQVNFID0gbmFtZSA9PiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYE5vIGJhc2UgZm91bmQgZm9yIFwiJHsgbmFtZSB9XCJgKSk7XG5leHBvcnQgY2xhc3MgTXVsdGliYXNlcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9iYXNlc0J5TmFtZSA9IHt9O1xuICAgIHRoaXMuX2Jhc2VzQnlQcmVmaXggPSB7fTtcbiAgICB0aGlzLl9sb2FkQmFzZSA9IG9wdGlvbnMubG9hZEJhc2UgfHwgTE9BRF9CQVNFO1xuICAgIGZvciAoY29uc3QgYmFzZSBvZiBvcHRpb25zLmJhc2VzKSB7XG4gICAgICB0aGlzLmFkZEJhc2UoYmFzZSk7XG4gICAgfVxuICB9XG4gIGFkZEJhc2UoYmFzZSkge1xuICAgIGlmICh0aGlzLl9iYXNlc0J5TmFtZVtiYXNlLm5hbWVdIHx8IHRoaXMuX2Jhc2VzQnlQcmVmaXhbYmFzZS5wcmVmaXhdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVjIGFscmVhZHkgZXhpc3RzIGZvciBjb2RlYyBcIiR7IGJhc2UubmFtZSB9XCJgKTtcbiAgICB9XG4gICAgdGhpcy5fYmFzZXNCeU5hbWVbYmFzZS5uYW1lXSA9IGJhc2U7XG4gICAgdGhpcy5fYmFzZXNCeVByZWZpeFtiYXNlLnByZWZpeF0gPSBiYXNlO1xuICB9XG4gIHJlbW92ZUJhc2UoYmFzZSkge1xuICAgIGRlbGV0ZSB0aGlzLl9iYXNlc0J5TmFtZVtiYXNlLm5hbWVdO1xuICAgIGRlbGV0ZSB0aGlzLl9iYXNlc0J5UHJlZml4W2Jhc2UucHJlZml4XTtcbiAgfVxuICBhc3luYyBnZXRCYXNlKG5hbWVPclByZWZpeCkge1xuICAgIGlmICh0aGlzLl9iYXNlc0J5TmFtZVtuYW1lT3JQcmVmaXhdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmFzZXNCeU5hbWVbbmFtZU9yUHJlZml4XTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Jhc2VzQnlQcmVmaXhbbmFtZU9yUHJlZml4XSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VzQnlQcmVmaXhbbmFtZU9yUHJlZml4XTtcbiAgICB9XG4gICAgY29uc3QgYmFzZSA9IGF3YWl0IHRoaXMuX2xvYWRCYXNlKG5hbWVPclByZWZpeCk7XG4gICAgaWYgKHRoaXMuX2Jhc2VzQnlOYW1lW2Jhc2UubmFtZV0gPT0gbnVsbCAmJiB0aGlzLl9iYXNlc0J5UHJlZml4W2Jhc2UucHJlZml4XSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmFkZEJhc2UoYmFzZSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGxpc3RCYXNlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9iYXNlc0J5TmFtZSk7XG4gIH1cbn0iLCJjb25zdCBMT0FEX0NPREVDID0gY29kZU9yTmFtZSA9PiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYE5vIGNvZGVjIGZvdW5kIGZvciBcIiR7IGNvZGVPck5hbWUgfVwiYCkpO1xuZXhwb3J0IGNsYXNzIE11bHRpY29kZWNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuX2NvZGVjc0J5TmFtZSA9IHt9O1xuICAgIHRoaXMuX2NvZGVjc0J5Q29kZSA9IHt9O1xuICAgIHRoaXMuX2xvYWRDb2RlYyA9IG9wdGlvbnMubG9hZENvZGVjIHx8IExPQURfQ09ERUM7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBvcHRpb25zLmNvZGVjcykge1xuICAgICAgdGhpcy5hZGRDb2RlYyhjb2RlYyk7XG4gICAgfVxuICB9XG4gIGFkZENvZGVjKGNvZGVjKSB7XG4gICAgaWYgKHRoaXMuX2NvZGVjc0J5TmFtZVtjb2RlYy5uYW1lXSB8fCB0aGlzLl9jb2RlY3NCeUNvZGVbY29kZWMuY29kZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb2x2ZXIgYWxyZWFkeSBleGlzdHMgZm9yIGNvZGVjIFwiJHsgY29kZWMubmFtZSB9XCJgKTtcbiAgICB9XG4gICAgdGhpcy5fY29kZWNzQnlOYW1lW2NvZGVjLm5hbWVdID0gY29kZWM7XG4gICAgdGhpcy5fY29kZWNzQnlDb2RlW2NvZGVjLmNvZGVdID0gY29kZWM7XG4gIH1cbiAgcmVtb3ZlQ29kZWMoY29kZWMpIHtcbiAgICBkZWxldGUgdGhpcy5fY29kZWNzQnlOYW1lW2NvZGVjLm5hbWVdO1xuICAgIGRlbGV0ZSB0aGlzLl9jb2RlY3NCeUNvZGVbY29kZWMuY29kZV07XG4gIH1cbiAgYXN5bmMgZ2V0Q29kZWMoY29kZSkge1xuICAgIGNvbnN0IHRhYmxlID0gdHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnID8gdGhpcy5fY29kZWNzQnlOYW1lIDogdGhpcy5fY29kZWNzQnlDb2RlO1xuICAgIGlmICh0YWJsZVtjb2RlXSkge1xuICAgICAgcmV0dXJuIHRhYmxlW2NvZGVdO1xuICAgIH1cbiAgICBjb25zdCBjb2RlYyA9IGF3YWl0IHRoaXMuX2xvYWRDb2RlYyhjb2RlKTtcbiAgICBpZiAodGFibGVbY29kZV0gPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRDb2RlYyhjb2RlYyk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlYztcbiAgfVxuICBsaXN0Q29kZWNzKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2NvZGVjc0J5TmFtZSk7XG4gIH1cbn0iLCJjb25zdCBMT0FEX0hBU0hFUiA9IGNvZGVPck5hbWUgPT4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBObyBoYXNoZXIgZm91bmQgZm9yIFwiJHsgY29kZU9yTmFtZSB9XCJgKSk7XG5leHBvcnQgY2xhc3MgTXVsdGloYXNoZXMge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5faGFzaGVyc0J5TmFtZSA9IHt9O1xuICAgIHRoaXMuX2hhc2hlcnNCeUNvZGUgPSB7fTtcbiAgICB0aGlzLl9sb2FkSGFzaGVyID0gb3B0aW9ucy5sb2FkSGFzaGVyIHx8IExPQURfSEFTSEVSO1xuICAgIGZvciAoY29uc3QgaGFzaGVyIG9mIG9wdGlvbnMuaGFzaGVycykge1xuICAgICAgdGhpcy5hZGRIYXNoZXIoaGFzaGVyKTtcbiAgICB9XG4gIH1cbiAgYWRkSGFzaGVyKGhhc2hlcikge1xuICAgIGlmICh0aGlzLl9oYXNoZXJzQnlOYW1lW2hhc2hlci5uYW1lXSB8fCB0aGlzLl9oYXNoZXJzQnlDb2RlW2hhc2hlci5jb2RlXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNvbHZlciBhbHJlYWR5IGV4aXN0cyBmb3IgY29kZWMgXCIkeyBoYXNoZXIubmFtZSB9XCJgKTtcbiAgICB9XG4gICAgdGhpcy5faGFzaGVyc0J5TmFtZVtoYXNoZXIubmFtZV0gPSBoYXNoZXI7XG4gICAgdGhpcy5faGFzaGVyc0J5Q29kZVtoYXNoZXIuY29kZV0gPSBoYXNoZXI7XG4gIH1cbiAgcmVtb3ZlSGFzaGVyKGhhc2hlcikge1xuICAgIGRlbGV0ZSB0aGlzLl9oYXNoZXJzQnlOYW1lW2hhc2hlci5uYW1lXTtcbiAgICBkZWxldGUgdGhpcy5faGFzaGVyc0J5Q29kZVtoYXNoZXIuY29kZV07XG4gIH1cbiAgYXN5bmMgZ2V0SGFzaGVyKGNvZGUpIHtcbiAgICBjb25zdCB0YWJsZSA9IHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJyA/IHRoaXMuX2hhc2hlcnNCeU5hbWUgOiB0aGlzLl9oYXNoZXJzQnlDb2RlO1xuICAgIGlmICh0YWJsZVtjb2RlXSkge1xuICAgICAgcmV0dXJuIHRhYmxlW2NvZGVdO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZXIgPSBhd2FpdCB0aGlzLl9sb2FkSGFzaGVyKGNvZGUpO1xuICAgIGlmICh0YWJsZVtjb2RlXSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmFkZEhhc2hlcihoYXNoZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaGVyO1xuICB9XG4gIGxpc3RIYXNoZXJzKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2hhc2hlcnNCeU5hbWUpO1xuICB9XG59IiwiaW1wb3J0IHsgbm9ybWFsaXNlSW5wdXQgfSBmcm9tICcuL2ZpbGVzL25vcm1hbGlzZS1pbnB1dC5icm93c2VyLmpzJztcbmltcG9ydCB7IG1vZGVUb1N0cmluZyB9IGZyb20gJy4vbW9kZS10by1zdHJpbmcuanMnO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG11bHRpcGFydFJlcXVlc3Qoc291cmNlLCBhYm9ydENvbnRyb2xsZXIsIGhlYWRlcnMgPSB7fSkge1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgdG90YWwgPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IHtjb250ZW50LCBwYXRoLCBtb2RlLCBtdGltZX0gb2Ygbm9ybWFsaXNlSW5wdXQoc291cmNlKSkge1xuICAgIGxldCBmaWxlU3VmZml4ID0gJyc7XG4gICAgY29uc3QgdHlwZSA9IGNvbnRlbnQgPyAnZmlsZScgOiAnZGlyJztcbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICBmaWxlU3VmZml4ID0gYC0keyBpbmRleCB9YDtcbiAgICB9XG4gICAgbGV0IGZpZWxkTmFtZSA9IHR5cGUgKyBmaWxlU3VmZml4O1xuICAgIGNvbnN0IHFzID0gW107XG4gICAgaWYgKG1vZGUgIT09IG51bGwgJiYgbW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBxcy5wdXNoKGBtb2RlPSR7IG1vZGVUb1N0cmluZyhtb2RlKSB9YCk7XG4gICAgfVxuICAgIGlmIChtdGltZSAhPSBudWxsKSB7XG4gICAgICBjb25zdCB7c2VjcywgbnNlY3N9ID0gbXRpbWU7XG4gICAgICBxcy5wdXNoKGBtdGltZT0keyBzZWNzIH1gKTtcbiAgICAgIGlmIChuc2VjcyAhPSBudWxsKSB7XG4gICAgICAgIHFzLnB1c2goYG10aW1lLW5zZWNzPSR7IG5zZWNzIH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHFzLmxlbmd0aCkge1xuICAgICAgZmllbGROYW1lID0gYCR7IGZpZWxkTmFtZSB9PyR7IHFzLmpvaW4oJyYnKSB9YDtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIGZvcm1EYXRhLnNldChmaWVsZE5hbWUsIGNvbnRlbnQsIHBhdGggIT0gbnVsbCA/IGVuY29kZVVSSUNvbXBvbmVudChwYXRoKSA6IHVuZGVmaW5lZCk7XG4gICAgICBjb25zdCBlbmQgPSB0b3RhbCArIGNvbnRlbnQuc2l6ZTtcbiAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICBuYW1lOiBwYXRoLFxuICAgICAgICBzdGFydDogdG90YWwsXG4gICAgICAgIGVuZFxuICAgICAgfSk7XG4gICAgICB0b3RhbCA9IGVuZDtcbiAgICB9IGVsc2UgaWYgKHBhdGggIT0gbnVsbCkge1xuICAgICAgZm9ybURhdGEuc2V0KGZpZWxkTmFtZSwgbmV3IEZpbGUoWycnXSwgZW5jb2RlVVJJQ29tcG9uZW50KHBhdGgpLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi94LWRpcmVjdG9yeScgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhdGggb3IgY29udGVudCBvciBib3RoIG11c3QgYmUgc2V0Jyk7XG4gICAgfVxuICAgIGluZGV4Kys7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3RhbCxcbiAgICBwYXJ0cyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHk6IGZvcm1EYXRhXG4gIH07XG59IiwiaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnO1xuaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIG5vcm1hbGlzZUlucHV0KGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQ6ICR7IGlucHV0IH1gKSwgJ0VSUl9VTkVYUEVDVEVEX0lOUFVUJyk7XG4gIH1cbiAgY29uc3QgY2lkID0gQ0lELmFzQ0lEKGlucHV0KTtcbiAgaWYgKGNpZCkge1xuICAgIHlpZWxkIHRvUGluKHsgY2lkIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIHlpZWxkIHRvUGluKHsgcGF0aDogaW5wdXQgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbnB1dC5jaWQgIT0gbnVsbCB8fCBpbnB1dC5wYXRoICE9IG51bGwpIHtcbiAgICByZXR1cm4geWllbGQgdG9QaW4oaW5wdXQpO1xuICB9XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBmaXJzdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAoZmlyc3QuZG9uZSlcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICBpZiAoQ0lELmFzQ0lEKGZpcnN0LnZhbHVlKSB8fCBmaXJzdC52YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2YgZmlyc3QudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB5aWVsZCB0b1Bpbih7IGNpZDogZmlyc3QudmFsdWUgfSk7XG4gICAgICBmb3IgKGNvbnN0IGNpZCBvZiBpdGVyYXRvcikge1xuICAgICAgICB5aWVsZCB0b1Bpbih7IGNpZCB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZpcnN0LnZhbHVlLmNpZCAhPSBudWxsIHx8IGZpcnN0LnZhbHVlLnBhdGggIT0gbnVsbCkge1xuICAgICAgeWllbGQgdG9QaW4oZmlyc3QudmFsdWUpO1xuICAgICAgZm9yIChjb25zdCBvYmogb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgeWllbGQgdG9QaW4ob2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgaW5wdXQ6ICcgKyB0eXBlb2YgaW5wdXQpLCAnRVJSX1VORVhQRUNURURfSU5QVVQnKTtcbiAgfVxuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IGlucHV0W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGZpcnN0ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgIGlmIChmaXJzdC5kb25lKVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIGlmIChDSUQuYXNDSUQoZmlyc3QudmFsdWUpIHx8IGZpcnN0LnZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiBmaXJzdC52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHlpZWxkIHRvUGluKHsgY2lkOiBmaXJzdC52YWx1ZSB9KTtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2lkIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgIHlpZWxkIHRvUGluKHsgY2lkIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmlyc3QudmFsdWUuY2lkICE9IG51bGwgfHwgZmlyc3QudmFsdWUucGF0aCAhPSBudWxsKSB7XG4gICAgICB5aWVsZCB0b1BpbihmaXJzdC52YWx1ZSk7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IG9iaiBvZiBpdGVyYXRvcikge1xuICAgICAgICB5aWVsZCB0b1BpbihvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogJyArIHR5cGVvZiBpbnB1dCksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xuICB9XG4gIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdVbmV4cGVjdGVkIGlucHV0OiAnICsgdHlwZW9mIGlucHV0KSwgJ0VSUl9VTkVYUEVDVEVEX0lOUFVUJyk7XG59XG5mdW5jdGlvbiB0b1BpbihpbnB1dCkge1xuICBjb25zdCBwYXRoID0gaW5wdXQuY2lkIHx8IGAkeyBpbnB1dC5wYXRoIH1gO1xuICBpZiAoIXBhdGgpIHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogUGxlYXNlIHBhdGggZWl0aGVyIGEgQ0lEIG9yIGFuIElQRlMgcGF0aCcpLCAnRVJSX1VORVhQRUNURURfSU5QVVQnKTtcbiAgfVxuICBjb25zdCBwaW4gPSB7XG4gICAgcGF0aCxcbiAgICByZWN1cnNpdmU6IGlucHV0LnJlY3Vyc2l2ZSAhPT0gZmFsc2VcbiAgfTtcbiAgaWYgKGlucHV0Lm1ldGFkYXRhICE9IG51bGwpIHtcbiAgICBwaW4ubWV0YWRhdGEgPSBpbnB1dC5tZXRhZGF0YTtcbiAgfVxuICByZXR1cm4gcGluO1xufSIsImltcG9ydCB7IE11bHRpYWRkciB9IGZyb20gJ211bHRpYWRkcic7XG5pbXBvcnQgbXVsdGlBZGRyVG9VcmkgZnJvbSAnbXVsdGlhZGRyLXRvLXVyaSc7XG5leHBvcnQgZnVuY3Rpb24gdG9VcmxTdHJpbmcodXJsKSB7XG4gIHRyeSB7XG4gICAgdXJsID0gbXVsdGlBZGRyVG9VcmkobmV3IE11bHRpYWRkcih1cmwpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgdXJsID0gdXJsLnRvU3RyaW5nKCk7XG4gIHJldHVybiB1cmw7XG59IiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5pbXBvcnQgeyBvYmplY3RUb0NhbWVsIH0gZnJvbSAnLi9saWIvb2JqZWN0LXRvLWNhbWVsLmpzJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyBtdWx0aXBhcnRSZXF1ZXN0IH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL211bHRpcGFydC1yZXF1ZXN0JztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuaW1wb3J0IHsgYWJvcnRTaWduYWwgfSBmcm9tICcuL2xpYi9hYm9ydC1zaWduYWwuanMnO1xuaW1wb3J0IHsgQWJvcnRDb250cm9sbGVyIH0gZnJvbSAnbmF0aXZlLWFib3J0LWNvbnRyb2xsZXInO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUFkZEFsbCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiogYWRkQWxsKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSBhYm9ydFNpZ25hbChjb250cm9sbGVyLnNpZ25hbCwgb3B0aW9ucy5zaWduYWwpO1xuICAgIGNvbnN0IHtoZWFkZXJzLCBib2R5LCB0b3RhbCwgcGFydHN9ID0gYXdhaXQgbXVsdGlwYXJ0UmVxdWVzdChzb3VyY2UsIGNvbnRyb2xsZXIsIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgW3Byb2dyZXNzRm4sIG9uVXBsb2FkUHJvZ3Jlc3NdID0gdHlwZW9mIG9wdGlvbnMucHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgPyBjcmVhdGVQcm9ncmVzc0hhbmRsZXIodG90YWwsIHBhcnRzLCBvcHRpb25zLnByb2dyZXNzKSA6IFtcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZFxuICAgIF07XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2FkZCcsIHtcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAnc3RyZWFtLWNoYW5uZWxzJzogdHJ1ZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgcHJvZ3Jlc3M6IEJvb2xlYW4ocHJvZ3Jlc3NGbilcbiAgICAgIH0pLFxuICAgICAgb25VcGxvYWRQcm9ncmVzcyxcbiAgICAgIHNpZ25hbCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5XG4gICAgfSk7XG4gICAgZm9yIGF3YWl0IChsZXQgZmlsZSBvZiByZXMubmRqc29uKCkpIHtcbiAgICAgIGZpbGUgPSBvYmplY3RUb0NhbWVsKGZpbGUpO1xuICAgICAgaWYgKGZpbGUuaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHlpZWxkIHRvQ29yZUludGVyZmFjZShmaWxlKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvZ3Jlc3NGbikge1xuICAgICAgICBwcm9ncmVzc0ZuKGZpbGUuYnl0ZXMgfHwgMCwgZmlsZS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkZEFsbDtcbn0pO1xuY29uc3QgY3JlYXRlUHJvZ3Jlc3NIYW5kbGVyID0gKHRvdGFsLCBwYXJ0cywgcHJvZ3Jlc3MpID0+IHBhcnRzID8gW1xuICB1bmRlZmluZWQsXG4gIGNyZWF0ZU9uVXBsb2FkUHJvZ3Jlc3ModG90YWwsIHBhcnRzLCBwcm9ncmVzcylcbl0gOiBbXG4gIHByb2dyZXNzLFxuICB1bmRlZmluZWRcbl07XG5jb25zdCBjcmVhdGVPblVwbG9hZFByb2dyZXNzID0gKHNpemUsIHBhcnRzLCBwcm9ncmVzcykgPT4ge1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBjb3VudCA9IHBhcnRzLmxlbmd0aDtcbiAgcmV0dXJuICh7bG9hZGVkLCB0b3RhbH0pID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IE1hdGguZmxvb3IobG9hZGVkIC8gdG90YWwgKiBzaXplKTtcbiAgICB3aGlsZSAoaW5kZXggPCBjb3VudCkge1xuICAgICAgY29uc3Qge3N0YXJ0LCBlbmQsIG5hbWV9ID0gcGFydHNbaW5kZXhdO1xuICAgICAgaWYgKHBvc2l0aW9uIDwgZW5kKSB7XG4gICAgICAgIHByb2dyZXNzKHBvc2l0aW9uIC0gc3RhcnQsIG5hbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyZXNzKGVuZCAtIHN0YXJ0LCBuYW1lKTtcbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gdG9Db3JlSW50ZXJmYWNlKHtuYW1lLCBoYXNoLCBzaXplLCBtb2RlLCBtdGltZSwgbXRpbWVOc2Vjc30pIHtcbiAgY29uc3Qgb3V0cHV0ID0ge1xuICAgIHBhdGg6IG5hbWUsXG4gICAgY2lkOiBDSUQucGFyc2UoaGFzaCksXG4gICAgc2l6ZTogcGFyc2VJbnQoc2l6ZSlcbiAgfTtcbiAgaWYgKG1vZGUgIT0gbnVsbCkge1xuICAgIG91dHB1dC5tb2RlID0gcGFyc2VJbnQobW9kZSwgOCk7XG4gIH1cbiAgaWYgKG10aW1lICE9IG51bGwpIHtcbiAgICBvdXRwdXQubXRpbWUgPSB7XG4gICAgICBzZWNzOiBtdGltZSxcbiAgICAgIG5zZWNzOiBtdGltZU5zZWNzIHx8IDBcbiAgICB9O1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59IiwiaW1wb3J0IHsgY3JlYXRlQWRkQWxsIH0gZnJvbSAnLi9hZGQtYWxsLmpzJztcbmltcG9ydCBsYXN0IGZyb20gJ2l0LWxhc3QnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi9saWIvY29uZmlndXJlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBZGQob3B0aW9ucykge1xuICBjb25zdCBhbGwgPSBjcmVhdGVBZGRBbGwob3B0aW9ucyk7XG4gIHJldHVybiBjb25maWd1cmUoKCkgPT4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIGFkZChpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICByZXR1cm4gYXdhaXQgbGFzdChhbGwoaW5wdXQsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZDtcbiAgfSkob3B0aW9ucyk7XG59IiwiaW1wb3J0IHsgY3JlYXRlV2FudGxpc3QgfSBmcm9tICcuL3dhbnRsaXN0LmpzJztcbmltcG9ydCB7IGNyZWF0ZVdhbnRsaXN0Rm9yUGVlciB9IGZyb20gJy4vd2FudGxpc3QtZm9yLXBlZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RhdCB9IGZyb20gJy4vc3RhdC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVVbndhbnQgfSBmcm9tICcuL3Vud2FudC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQml0c3dhcChjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICB3YW50bGlzdDogY3JlYXRlV2FudGxpc3QoY29uZmlnKSxcbiAgICB3YW50bGlzdEZvclBlZXI6IGNyZWF0ZVdhbnRsaXN0Rm9yUGVlcihjb25maWcpLFxuICAgIHVud2FudDogY3JlYXRlVW53YW50KGNvbmZpZyksXG4gICAgc3RhdDogY3JlYXRlU3RhdChjb25maWcpXG4gIH07XG59IiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVTdGF0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXQob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2JpdHN3YXAvc3RhdCcsIHtcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIHRvQ29yZUludGVyZmFjZShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICByZXR1cm4gc3RhdDtcbn0pO1xuZnVuY3Rpb24gdG9Db3JlSW50ZXJmYWNlKHJlcykge1xuICByZXR1cm4ge1xuICAgIHByb3ZpZGVCdWZMZW46IHJlcy5Qcm92aWRlQnVmTGVuLFxuICAgIHdhbnRsaXN0OiAocmVzLldhbnRsaXN0IHx8IFtdKS5tYXAoayA9PiBDSUQucGFyc2Uoa1snLyddKSksXG4gICAgcGVlcnM6IHJlcy5QZWVycyB8fCBbXSxcbiAgICBibG9ja3NSZWNlaXZlZDogQmlnSW50KHJlcy5CbG9ja3NSZWNlaXZlZCksXG4gICAgZGF0YVJlY2VpdmVkOiBCaWdJbnQocmVzLkRhdGFSZWNlaXZlZCksXG4gICAgYmxvY2tzU2VudDogQmlnSW50KHJlcy5CbG9ja3NTZW50KSxcbiAgICBkYXRhU2VudDogQmlnSW50KHJlcy5EYXRhU2VudCksXG4gICAgZHVwQmxrc1JlY2VpdmVkOiBCaWdJbnQocmVzLkR1cEJsa3NSZWNlaXZlZCksXG4gICAgZHVwRGF0YVJlY2VpdmVkOiBCaWdJbnQocmVzLkR1cERhdGFSZWNlaXZlZClcbiAgfTtcbn0iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVVbndhbnQgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gdW53YW50KGNpZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2JpdHN3YXAvdW53YW50Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGNpZC50b1N0cmluZygpLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiByZXMuanNvbigpO1xuICB9XG4gIHJldHVybiB1bndhbnQ7XG59KTsiLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVdhbnRsaXN0Rm9yUGVlciA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiB3YW50bGlzdEZvclBlZXIocGVlcklkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCAoYXdhaXQgYXBpLnBvc3QoJ2JpdHN3YXAvd2FudGxpc3QnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHBlZXI6IHBlZXJJZC50b1N0cmluZygpXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pKS5qc29uKCk7XG4gICAgcmV0dXJuIChyZXMuS2V5cyB8fCBbXSkubWFwKGsgPT4gQ0lELnBhcnNlKGtbJy8nXSkpO1xuICB9XG4gIHJldHVybiB3YW50bGlzdEZvclBlZXI7XG59KTsiLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVdhbnRsaXN0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIHdhbnRsaXN0KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IChhd2FpdCBhcGkucG9zdCgnYml0c3dhcC93YW50bGlzdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSkpLmpzb24oKTtcbiAgICByZXR1cm4gKHJlcy5LZXlzIHx8IFtdKS5tYXAoayA9PiBDSUQucGFyc2Uoa1snLyddKSk7XG4gIH1cbiAgcmV0dXJuIHdhbnRsaXN0O1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlR2V0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGdldChjaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdibG9jay9nZXQnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogY2lkLnRvU3RyaW5nKCksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpKTtcbiAgfVxuICByZXR1cm4gZ2V0O1xufSk7IiwiaW1wb3J0IHsgY3JlYXRlR2V0IH0gZnJvbSAnLi9nZXQuanMnO1xuaW1wb3J0IHsgY3JlYXRlUHV0IH0gZnJvbSAnLi9wdXQuanMnO1xuaW1wb3J0IHsgY3JlYXRlUm0gfSBmcm9tICcuL3JtLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN0YXQgfSBmcm9tICcuL3N0YXQuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJsb2NrKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGdldDogY3JlYXRlR2V0KGNvbmZpZyksXG4gICAgcHV0OiBjcmVhdGVQdXQoY29uZmlnKSxcbiAgICBybTogY3JlYXRlUm0oY29uZmlnKSxcbiAgICBzdGF0OiBjcmVhdGVTdGF0KGNvbmZpZylcbiAgfTtcbn0iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IG11bHRpcGFydFJlcXVlc3QgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvbXVsdGlwYXJ0LXJlcXVlc3QnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5pbXBvcnQgeyBhYm9ydFNpZ25hbCB9IGZyb20gJy4uL2xpYi9hYm9ydC1zaWduYWwuanMnO1xuaW1wb3J0IHsgQWJvcnRDb250cm9sbGVyIH0gZnJvbSAnbmF0aXZlLWFib3J0LWNvbnRyb2xsZXInO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVB1dCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBwdXQoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSBhYm9ydFNpZ25hbChjb250cm9sbGVyLnNpZ25hbCwgb3B0aW9ucy5zaWduYWwpO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJ2Jsb2NrL3B1dCcsIHtcbiAgICAgICAgc2lnbmFsOiBzaWduYWwsXG4gICAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICAgIC4uLmF3YWl0IG11bHRpcGFydFJlcXVlc3QoZGF0YSwgY29udHJvbGxlciwgb3B0aW9ucy5oZWFkZXJzKVxuICAgICAgfSk7XG4gICAgICByZXMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdkYWctcGInKSB7XG4gICAgICAgIHJldHVybiBwdXQoZGF0YSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgZm9ybWF0OiAncHJvdG9idWYnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gJ2RhZy1jYm9yJykge1xuICAgICAgICByZXR1cm4gcHV0KGRhdGEsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIGZvcm1hdDogJ2Nib3InXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gQ0lELnBhcnNlKHJlcy5LZXkpO1xuICB9XG4gIHJldHVybiBwdXQ7XG59KTsiLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJtID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uKiBybShjaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjaWQpKSB7XG4gICAgICBjaWQgPSBbY2lkXTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2Jsb2NrL3JtJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGNpZC5tYXAoY2lkID0+IGNpZC50b1N0cmluZygpKSxcbiAgICAgICAgJ3N0cmVhbS1jaGFubmVscyc6IHRydWUsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgZm9yIGF3YWl0IChjb25zdCByZW1vdmVkIG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgeWllbGQgdG9Db3JlSW50ZXJmYWNlKHJlbW92ZWQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcm07XG59KTtcbmZ1bmN0aW9uIHRvQ29yZUludGVyZmFjZShyZW1vdmVkKSB7XG4gIGNvbnN0IG91dCA9IHsgY2lkOiBDSUQucGFyc2UocmVtb3ZlZC5IYXNoKSB9O1xuICBpZiAocmVtb3ZlZC5FcnJvcikge1xuICAgIG91dC5lcnJvciA9IG5ldyBFcnJvcihyZW1vdmVkLkVycm9yKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufSIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlU3RhdCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBzdGF0KGNpZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2Jsb2NrL3N0YXQnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogY2lkLnRvU3RyaW5nKCksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNpZDogQ0lELnBhcnNlKGRhdGEuS2V5KSxcbiAgICAgIHNpemU6IGRhdGEuU2l6ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXQ7XG59KTsiLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmltcG9ydCB7IE11bHRpYWRkciB9IGZyb20gJ211bHRpYWRkcic7XG5leHBvcnQgY29uc3QgY3JlYXRlQWRkID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZChhZGRyLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnYm9vdHN0cmFwL2FkZCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBhZGRyLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHtQZWVyc30gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiB7IFBlZXJzOiBQZWVycy5tYXAobWEgPT4gbmV3IE11bHRpYWRkcihtYSkpIH07XG4gIH1cbiAgcmV0dXJuIGFkZDtcbn0pOyIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuaW1wb3J0IHsgTXVsdGlhZGRyIH0gZnJvbSAnbXVsdGlhZGRyJztcbmV4cG9ydCBjb25zdCBjcmVhdGVDbGVhciA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBjbGVhcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnYm9vdHN0cmFwL3JtJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBhbGw6IHRydWVcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3Qge1BlZXJzfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIHsgUGVlcnM6IFBlZXJzLm1hcChtYSA9PiBuZXcgTXVsdGlhZGRyKG1hKSkgfTtcbiAgfVxuICByZXR1cm4gY2xlYXI7XG59KTsiLCJpbXBvcnQgeyBjcmVhdGVBZGQgfSBmcm9tICcuL2FkZC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDbGVhciB9IGZyb20gJy4vY2xlYXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlTGlzdCB9IGZyb20gJy4vbGlzdC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVSZXNldCB9IGZyb20gJy4vcmVzZXQuanMnO1xuaW1wb3J0IHsgY3JlYXRlUm0gfSBmcm9tICcuL3JtLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCb290c3RyYXAoY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgYWRkOiBjcmVhdGVBZGQoY29uZmlnKSxcbiAgICBjbGVhcjogY3JlYXRlQ2xlYXIoY29uZmlnKSxcbiAgICBsaXN0OiBjcmVhdGVMaXN0KGNvbmZpZyksXG4gICAgcmVzZXQ6IGNyZWF0ZVJlc2V0KGNvbmZpZyksXG4gICAgcm06IGNyZWF0ZVJtKGNvbmZpZylcbiAgfTtcbn0iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmltcG9ydCB7IE11bHRpYWRkciB9IGZyb20gJ211bHRpYWRkcic7XG5leHBvcnQgY29uc3QgY3JlYXRlTGlzdCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBsaXN0KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdib290c3RyYXAvbGlzdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3Qge1BlZXJzfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIHsgUGVlcnM6IFBlZXJzLm1hcChtYSA9PiBuZXcgTXVsdGlhZGRyKG1hKSkgfTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn0pOyIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuaW1wb3J0IHsgTXVsdGlhZGRyIH0gZnJvbSAnbXVsdGlhZGRyJztcbmV4cG9ydCBjb25zdCBjcmVhdGVSZXNldCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiByZXNldChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnYm9vdHN0cmFwL2FkZCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCB7UGVlcnN9ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4geyBQZWVyczogUGVlcnMubWFwKG1hID0+IG5ldyBNdWx0aWFkZHIobWEpKSB9O1xuICB9XG4gIHJldHVybiByZXNldDtcbn0pOyIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuaW1wb3J0IHsgTXVsdGlhZGRyIH0gZnJvbSAnbXVsdGlhZGRyJztcbmV4cG9ydCBjb25zdCBjcmVhdGVSbSA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBybShhZGRyLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnYm9vdHN0cmFwL3JtJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGFkZHIsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3Qge1BlZXJzfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIHsgUGVlcnM6IFBlZXJzLm1hcChtYSA9PiBuZXcgTXVsdGlhZGRyKG1hKSkgfTtcbiAgfVxuICByZXR1cm4gcm07XG59KTsiLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlQ2F0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uKiBjYXQocGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2NhdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwYXRoLnRvU3RyaW5nKCksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgeWllbGQqIHJlcy5pdGVyYXRvcigpO1xuICB9XG4gIHJldHVybiBjYXQ7XG59KTsiLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlQ29tbWFuZHMgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgY29uc3QgY29tbWFuZHMgPSBhc3luYyAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2NvbW1hbmRzJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgfTtcbiAgcmV0dXJuIGNvbW1hbmRzO1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlR2V0QWxsID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGNvbnN0IGdldEFsbCA9IGFzeW5jIChvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnY29uZmlnL3Nob3cnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7IC4uLm9wdGlvbnMgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbiAgcmV0dXJuIGdldEFsbDtcbn0pOyIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUdldCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBjb25zdCBnZXQgPSBhc3luYyAoa2V5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXkgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2NvbmZpZycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBrZXksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIGRhdGEuVmFsdWU7XG4gIH07XG4gIHJldHVybiBnZXQ7XG59KTsiLCJpbXBvcnQgeyBjcmVhdGVQcm9maWxlcyB9IGZyb20gJy4vcHJvZmlsZXMvaW5kZXguanMnO1xuaW1wb3J0IHsgY3JlYXRlR2V0IH0gZnJvbSAnLi9nZXQuanMnO1xuaW1wb3J0IHsgY3JlYXRlR2V0QWxsIH0gZnJvbSAnLi9nZXQtYWxsLmpzJztcbmltcG9ydCB7IGNyZWF0ZVJlcGxhY2UgfSBmcm9tICcuL3JlcGxhY2UuanMnO1xuaW1wb3J0IHsgY3JlYXRlU2V0IH0gZnJvbSAnLi9zZXQuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbmZpZyhjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXRBbGw6IGNyZWF0ZUdldEFsbChjb25maWcpLFxuICAgIGdldDogY3JlYXRlR2V0KGNvbmZpZyksXG4gICAgc2V0OiBjcmVhdGVTZXQoY29uZmlnKSxcbiAgICByZXBsYWNlOiBjcmVhdGVSZXBsYWNlKGNvbmZpZyksXG4gICAgcHJvZmlsZXM6IGNyZWF0ZVByb2ZpbGVzKGNvbmZpZylcbiAgfTtcbn0iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi8uLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVBcHBseSA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBhcHBseShwcm9maWxlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnY29uZmlnL3Byb2ZpbGUvYXBwbHknLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogcHJvZmlsZSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgb3JpZ2luYWw6IGRhdGEuT2xkQ2ZnLFxuICAgICAgdXBkYXRlZDogZGF0YS5OZXdDZmdcbiAgICB9O1xuICB9XG4gIHJldHVybiBhcHBseTtcbn0pOyIsImltcG9ydCB7IGNyZWF0ZUFwcGx5IH0gZnJvbSAnLi9hcHBseS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVMaXN0IH0gZnJvbSAnLi9saXN0LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9maWxlcyhjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBhcHBseTogY3JlYXRlQXBwbHkoY29uZmlnKSxcbiAgICBsaXN0OiBjcmVhdGVMaXN0KGNvbmZpZylcbiAgfTtcbn0iLCJpbXBvcnQgeyBvYmplY3RUb0NhbWVsIH0gZnJvbSAnLi4vLi4vbGliL29iamVjdC10by1jYW1lbC5qcyc7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi8uLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVMaXN0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3Qob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2NvbmZpZy9wcm9maWxlL2xpc3QnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiBkYXRhLm1hcChwcm9maWxlID0+IG9iamVjdFRvQ2FtZWwocHJvZmlsZSkpO1xuICB9XG4gIHJldHVybiBsaXN0O1xufSk7IiwiaW1wb3J0IHsgZnJvbVN0cmluZyBhcyB1aW50OEFycmF5RnJvbVN0cmluZyB9IGZyb20gJ3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nJztcbmltcG9ydCB7IG11bHRpcGFydFJlcXVlc3QgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvbXVsdGlwYXJ0LXJlcXVlc3QnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5pbXBvcnQgeyBhYm9ydFNpZ25hbCB9IGZyb20gJy4uL2xpYi9hYm9ydC1zaWduYWwuanMnO1xuaW1wb3J0IHsgQWJvcnRDb250cm9sbGVyIH0gZnJvbSAnbmF0aXZlLWFib3J0LWNvbnRyb2xsZXInO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlcGxhY2UgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgY29uc3QgcmVwbGFjZSA9IGFzeW5jIChjb25maWcsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gYWJvcnRTaWduYWwoY29udHJvbGxlci5zaWduYWwsIG9wdGlvbnMuc2lnbmFsKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnY29uZmlnL3JlcGxhY2UnLCB7XG4gICAgICBzaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgLi4uYXdhaXQgbXVsdGlwYXJ0UmVxdWVzdCh1aW50OEFycmF5RnJvbVN0cmluZyhKU09OLnN0cmluZ2lmeShjb25maWcpKSwgY29udHJvbGxlciwgb3B0aW9ucy5oZWFkZXJzKVxuICAgIH0pO1xuICAgIGF3YWl0IHJlcy50ZXh0KCk7XG4gIH07XG4gIHJldHVybiByZXBsYWNlO1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlU2V0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGNvbnN0IHNldCA9IGFzeW5jIChrZXksIHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgLi4uZW5jb2RlUGFyYW0oa2V5LCB2YWx1ZSlcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdjb25maWcnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhwYXJhbXMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgYXdhaXQgcmVzLnRleHQoKTtcbiAgfTtcbiAgcmV0dXJuIHNldDtcbn0pO1xuY29uc3QgZW5jb2RlUGFyYW0gPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICBjYXNlICdib29sZWFuJzpcbiAgICByZXR1cm4ge1xuICAgICAgYXJnOiBbXG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWUudG9TdHJpbmcoKVxuICAgICAgXSxcbiAgICAgIGJvb2w6IHRydWVcbiAgICB9O1xuICBjYXNlICdzdHJpbmcnOlxuICAgIHJldHVybiB7XG4gICAgICBhcmc6IFtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgXVxuICAgIH07XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHtcbiAgICAgIGFyZzogW1xuICAgICAgICBrZXksXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgICAgXSxcbiAgICAgIGpzb246IHRydWVcbiAgICB9O1xuICB9XG59OyIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUV4cG9ydCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiogZGFnRXhwb3J0KHJvb3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdkYWcvZXhwb3J0Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoeyBhcmc6IHJvb3QudG9TdHJpbmcoKSB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIHlpZWxkKiByZXMuaXRlcmF0b3IoKTtcbiAgfVxuICByZXR1cm4gZGFnRXhwb3J0O1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlIH0gZnJvbSAnLi4vbGliL3Jlc29sdmUuanMnO1xuaW1wb3J0IGZpcnN0IGZyb20gJ2l0LWZpcnN0JztcbmltcG9ydCBsYXN0IGZyb20gJ2l0LWxhc3QnO1xuaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnO1xuaW1wb3J0IHsgY3JlYXRlR2V0IGFzIGNyZWF0ZUJsb2NrR2V0IH0gZnJvbSAnLi4vYmxvY2svZ2V0LmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVHZXQgPSAoY29kZWNzLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGZuID0gY29uZmlndXJlKChhcGksIG9wdHMpID0+IHtcbiAgICBjb25zdCBnZXRCbG9jayA9IGNyZWF0ZUJsb2NrR2V0KG9wdHMpO1xuICAgIGNvbnN0IGdldCA9IGFzeW5jIChjaWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMucGF0aCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IG9wdGlvbnMubG9jYWxSZXNvbHZlID8gYXdhaXQgZmlyc3QocmVzb2x2ZShjaWQsIG9wdGlvbnMucGF0aCwgY29kZWNzLCBnZXRCbG9jaywgb3B0aW9ucykpIDogYXdhaXQgbGFzdChyZXNvbHZlKGNpZCwgb3B0aW9ucy5wYXRoLCBjb2RlY3MsIGdldEJsb2NrLCBvcHRpb25zKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGVudHJ5O1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdOb3QgZm91bmQnKSwgJ0VSUl9OT1RfRk9VTkQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgY29uc3QgY29kZWMgPSBhd2FpdCBjb2RlY3MuZ2V0Q29kZWMoY2lkLmNvZGUpO1xuICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCBnZXRCbG9jayhjaWQsIG9wdGlvbnMpO1xuICAgICAgY29uc3Qgbm9kZSA9IGNvZGVjLmRlY29kZShibG9jayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbm9kZSxcbiAgICAgICAgcmVtYWluZGVyUGF0aDogJydcbiAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gZ2V0O1xuICB9KTtcbiAgcmV0dXJuIGZuKG9wdGlvbnMpO1xufTsiLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmltcG9ydCB7IGFib3J0U2lnbmFsIH0gZnJvbSAnLi4vbGliL2Fib3J0LXNpZ25hbC5qcyc7XG5pbXBvcnQgeyBtdWx0aXBhcnRSZXF1ZXN0IH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL211bHRpcGFydC1yZXF1ZXN0JztcbmltcG9ydCB7IEFib3J0Q29udHJvbGxlciB9IGZyb20gJ25hdGl2ZS1hYm9ydC1jb250cm9sbGVyJztcbmltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUltcG9ydCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiogZGFnSW1wb3J0KHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSBhYm9ydFNpZ25hbChjb250cm9sbGVyLnNpZ25hbCwgb3B0aW9ucy5zaWduYWwpO1xuICAgIGNvbnN0IHtoZWFkZXJzLCBib2R5fSA9IGF3YWl0IG11bHRpcGFydFJlcXVlc3Qoc291cmNlLCBjb250cm9sbGVyLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdkYWcvaW1wb3J0Jywge1xuICAgICAgc2lnbmFsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHksXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHsgJ3Bpbi1yb290cyc6IG9wdGlvbnMucGluUm9vdHMgfSlcbiAgICB9KTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHtSb290fSBvZiByZXMubmRqc29uKCkpIHtcbiAgICAgIGlmIChSb290ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIENpZDogeycvJzogQ2lkfSxcbiAgICAgICAgICBQaW5FcnJvck1zZ1xuICAgICAgICB9ID0gUm9vdDtcbiAgICAgICAgeWllbGQge1xuICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgIGNpZDogQ0lELnBhcnNlKENpZCksXG4gICAgICAgICAgICBwaW5FcnJvck1zZzogUGluRXJyb3JNc2dcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYWdJbXBvcnQ7XG59KTsiLCJpbXBvcnQgeyBjcmVhdGVFeHBvcnQgfSBmcm9tICcuL2V4cG9ydC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVHZXQgfSBmcm9tICcuL2dldC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVJbXBvcnQgfSBmcm9tICcuL2ltcG9ydC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVQdXQgfSBmcm9tICcuL3B1dC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZlIH0gZnJvbSAnLi9yZXNvbHZlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEYWcoY29kZWNzLCBjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBleHBvcnQ6IGNyZWF0ZUV4cG9ydChjb25maWcpLFxuICAgIGdldDogY3JlYXRlR2V0KGNvZGVjcywgY29uZmlnKSxcbiAgICBpbXBvcnQ6IGNyZWF0ZUltcG9ydChjb25maWcpLFxuICAgIHB1dDogY3JlYXRlUHV0KGNvZGVjcywgY29uZmlnKSxcbiAgICByZXNvbHZlOiBjcmVhdGVSZXNvbHZlKGNvbmZpZylcbiAgfTtcbn0iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgbXVsdGlwYXJ0UmVxdWVzdCB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9tdWx0aXBhcnQtcmVxdWVzdCc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5pbXBvcnQgeyBhYm9ydFNpZ25hbCB9IGZyb20gJy4uL2xpYi9hYm9ydC1zaWduYWwuanMnO1xuaW1wb3J0IHsgQWJvcnRDb250cm9sbGVyIH0gZnJvbSAnbmF0aXZlLWFib3J0LWNvbnRyb2xsZXInO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVB1dCA9IChjb2RlY3MsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZm4gPSBjb25maWd1cmUoYXBpID0+IHtcbiAgICBjb25zdCBwdXQgPSBhc3luYyAoZGFnTm9kZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgICAgZm9ybWF0OiAnZGFnLWNib3InLFxuICAgICAgICBoYXNoQWxnOiAnc2hhMi0yNTYnLFxuICAgICAgICBpbnB1dEVuYzogJ3JhdycsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBjb2RlYyA9IGF3YWl0IGNvZGVjcy5nZXRDb2RlYyhzZXR0aW5ncy5mb3JtYXQpO1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IGNvZGVjLmVuY29kZShkYWdOb2RlKTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSBhYm9ydFNpZ25hbChjb250cm9sbGVyLnNpZ25hbCwgc2V0dGluZ3Muc2lnbmFsKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdkYWcvcHV0Jywge1xuICAgICAgICB0aW1lb3V0OiBzZXR0aW5ncy50aW1lb3V0LFxuICAgICAgICBzaWduYWwsXG4gICAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoc2V0dGluZ3MpLFxuICAgICAgICAuLi5hd2FpdCBtdWx0aXBhcnRSZXF1ZXN0KHNlcmlhbGl6ZWQsIGNvbnRyb2xsZXIsIHNldHRpbmdzLmhlYWRlcnMpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgcmV0dXJuIENJRC5wYXJzZShkYXRhLkNpZFsnLyddKTtcbiAgICB9O1xuICAgIHJldHVybiBwdXQ7XG4gIH0pO1xuICByZXR1cm4gZm4ob3B0aW9ucyk7XG59OyIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUmVzb2x2ZSA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBjb25zdCByZXNvbHZlID0gYXN5bmMgKGlwZnNQYXRoLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZGFnL3Jlc29sdmUnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogYCR7IGlwZnNQYXRoIH0keyBvcHRpb25zLnBhdGggPyBgLyR7IG9wdGlvbnMucGF0aCB9YC5yZXBsYWNlKC9cXC9bL10rL2csICcvJykgOiAnJyB9YCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2lkOiBDSUQucGFyc2UoZGF0YS5DaWRbJy8nXSksXG4gICAgICByZW1haW5kZXJQYXRoOiBkYXRhLlJlbVBhdGhcbiAgICB9O1xuICB9O1xuICByZXR1cm4gcmVzb2x2ZTtcbn0pOyIsImltcG9ydCB7IE11bHRpYWRkciB9IGZyb20gJ211bHRpYWRkcic7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmltcG9ydCB7IEZpbmFsUGVlciB9IGZyb20gJy4vcmVzcG9uc2UtdHlwZXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUZpbmRQZWVyID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGZpbmRQZWVyKHBlZXJJZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2RodC9maW5kcGVlcicsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwZWVySWQsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBkYXRhIG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgaWYgKGRhdGEuVHlwZSA9PT0gRmluYWxQZWVyICYmIGRhdGEuUmVzcG9uc2VzKSB7XG4gICAgICAgIGNvbnN0IHtJRCwgQWRkcnN9ID0gZGF0YS5SZXNwb25zZXNbMF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IElELFxuICAgICAgICAgIGFkZHJzOiAoQWRkcnMgfHwgW10pLm1hcChhID0+IG5ldyBNdWx0aWFkZHIoYSkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignbm90IGZvdW5kJyk7XG4gIH1cbiAgcmV0dXJuIGZpbmRQZWVyO1xufSk7IiwiaW1wb3J0IHsgTXVsdGlhZGRyIH0gZnJvbSAnbXVsdGlhZGRyJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICcuL3Jlc3BvbnNlLXR5cGVzLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVGaW5kUHJvdnMgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24qIGZpbmRQcm92cyhjaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdkaHQvZmluZHByb3ZzJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGNpZC50b1N0cmluZygpLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGZvciBhd2FpdCAoY29uc3QgbWVzc2FnZSBvZiByZXMubmRqc29uKCkpIHtcbiAgICAgIGlmIChtZXNzYWdlLlR5cGUgPT09IFByb3ZpZGVyICYmIG1lc3NhZ2UuUmVzcG9uc2VzKSB7XG4gICAgICAgIGZvciAoY29uc3Qge0lELCBBZGRyc30gb2YgbWVzc2FnZS5SZXNwb25zZXMpIHtcbiAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICBpZDogSUQsXG4gICAgICAgICAgICBhZGRyczogKEFkZHJzIHx8IFtdKS5tYXAoYSA9PiBuZXcgTXVsdGlhZGRyKGEpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbmRQcm92cztcbn0pOyIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tICcuL3Jlc3BvbnNlLXR5cGVzLmpzJztcbmltcG9ydCB7IGZyb21TdHJpbmcgYXMgdWludDhBcnJheUZyb21TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy9mcm9tLXN0cmluZyc7XG5pbXBvcnQgeyB0b1N0cmluZyBhcyB1aW50OEFycmF5VG9TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy90by1zdHJpbmcnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUdldCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBnZXQoa2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZGh0L2dldCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gdWludDhBcnJheVRvU3RyaW5nKGtleSkgOiBrZXksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBtZXNzYWdlIG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgaWYgKG1lc3NhZ2UuVHlwZSA9PT0gVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKG1lc3NhZ2UuRXh0cmEsICdiYXNlNjRwYWQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgZm91bmQnKTtcbiAgfVxuICByZXR1cm4gZ2V0O1xufSk7IiwiaW1wb3J0IHsgY3JlYXRlRmluZFBlZXIgfSBmcm9tICcuL2ZpbmQtcGVlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVGaW5kUHJvdnMgfSBmcm9tICcuL2ZpbmQtcHJvdnMuanMnO1xuaW1wb3J0IHsgY3JlYXRlR2V0IH0gZnJvbSAnLi9nZXQuanMnO1xuaW1wb3J0IHsgY3JlYXRlUHJvdmlkZSB9IGZyb20gJy4vcHJvdmlkZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVQdXQgfSBmcm9tICcuL3B1dC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVRdWVyeSB9IGZyb20gJy4vcXVlcnkuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURodChjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBmaW5kUGVlcjogY3JlYXRlRmluZFBlZXIoY29uZmlnKSxcbiAgICBmaW5kUHJvdnM6IGNyZWF0ZUZpbmRQcm92cyhjb25maWcpLFxuICAgIGdldDogY3JlYXRlR2V0KGNvbmZpZyksXG4gICAgcHJvdmlkZTogY3JlYXRlUHJvdmlkZShjb25maWcpLFxuICAgIHB1dDogY3JlYXRlUHV0KGNvbmZpZyksXG4gICAgcXVlcnk6IGNyZWF0ZVF1ZXJ5KGNvbmZpZylcbiAgfTtcbn0iLCJpbXBvcnQgeyBNdWx0aWFkZHIgfSBmcm9tICdtdWx0aWFkZHInO1xuaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4uL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUHJvdmlkZSA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiogcHJvdmlkZShjaWRzLCBvcHRpb25zID0geyByZWN1cnNpdmU6IGZhbHNlIH0pIHtcbiAgICBjb25zdCBjaWRBcnIgPSBBcnJheS5pc0FycmF5KGNpZHMpID8gY2lkcyA6IFtjaWRzXTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZGh0L3Byb3ZpZGUnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogY2lkQXJyLm1hcChjaWQgPT4gY2lkLnRvU3RyaW5nKCkpLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGZvciBhd2FpdCAobGV0IG1lc3NhZ2Ugb2YgcmVzLm5kanNvbigpKSB7XG4gICAgICBtZXNzYWdlID0gb2JqZWN0VG9DYW1lbChtZXNzYWdlKTtcbiAgICAgIGlmIChtZXNzYWdlLnJlc3BvbnNlcykge1xuICAgICAgICBtZXNzYWdlLnJlc3BvbnNlcyA9IG1lc3NhZ2UucmVzcG9uc2VzLm1hcCgoe0lELCBBZGRyc30pID0+ICh7XG4gICAgICAgICAgaWQ6IElELFxuICAgICAgICAgIGFkZHJzOiAoQWRkcnMgfHwgW10pLm1hcChhID0+IG5ldyBNdWx0aWFkZHIoYSkpXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UucmVzcG9uc2VzID0gW107XG4gICAgICB9XG4gICAgICB5aWVsZCBtZXNzYWdlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvdmlkZTtcbn0pOyIsImltcG9ydCB7IE11bHRpYWRkciB9IGZyb20gJ211bHRpYWRkcic7XG5pbXBvcnQgeyBvYmplY3RUb0NhbWVsIH0gZnJvbSAnLi4vbGliL29iamVjdC10by1jYW1lbC5qcyc7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmltcG9ydCB7IG11bHRpcGFydFJlcXVlc3QgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvbXVsdGlwYXJ0LXJlcXVlc3QnO1xuaW1wb3J0IHsgYWJvcnRTaWduYWwgfSBmcm9tICcuLi9saWIvYWJvcnQtc2lnbmFsLmpzJztcbmltcG9ydCB7IEFib3J0Q29udHJvbGxlciB9IGZyb20gJ25hdGl2ZS1hYm9ydC1jb250cm9sbGVyJztcbmltcG9ydCB7IHRvU3RyaW5nIGFzIHVpbnQ4QXJyYXlUb1N0cmluZyB9IGZyb20gJ3VpbnQ4YXJyYXlzL3RvLXN0cmluZyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUHV0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uKiBwdXQoa2V5LCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSBhYm9ydFNpZ25hbChjb250cm9sbGVyLnNpZ25hbCwgb3B0aW9ucy5zaWduYWwpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdkaHQvcHV0Jywge1xuICAgICAgc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogdWludDhBcnJheVRvU3RyaW5nKGtleSksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgLi4uYXdhaXQgbXVsdGlwYXJ0UmVxdWVzdCh2YWx1ZSwgY29udHJvbGxlciwgb3B0aW9ucy5oZWFkZXJzKVxuICAgIH0pO1xuICAgIGZvciBhd2FpdCAobGV0IG1lc3NhZ2Ugb2YgcmVzLm5kanNvbigpKSB7XG4gICAgICBtZXNzYWdlID0gb2JqZWN0VG9DYW1lbChtZXNzYWdlKTtcbiAgICAgIGlmIChtZXNzYWdlLnJlc3BvbnNlcykge1xuICAgICAgICBtZXNzYWdlLnJlc3BvbnNlcyA9IG1lc3NhZ2UucmVzcG9uc2VzLm1hcCgoe0lELCBBZGRyc30pID0+ICh7XG4gICAgICAgICAgaWQ6IElELFxuICAgICAgICAgIGFkZHJzOiAoQWRkcnMgfHwgW10pLm1hcChhID0+IG5ldyBNdWx0aWFkZHIoYSkpXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIG1lc3NhZ2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBwdXQ7XG59KTsiLCJpbXBvcnQgeyBNdWx0aWFkZHIgfSBmcm9tICdtdWx0aWFkZHInO1xuaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4uL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUXVlcnkgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24qIHF1ZXJ5KHBlZXJJZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2RodC9xdWVyeScsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwZWVySWQudG9TdHJpbmcoKSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBmb3IgYXdhaXQgKGxldCBtZXNzYWdlIG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgbWVzc2FnZSA9IG9iamVjdFRvQ2FtZWwobWVzc2FnZSk7XG4gICAgICBtZXNzYWdlLnJlc3BvbnNlcyA9IChtZXNzYWdlLnJlc3BvbnNlcyB8fCBbXSkubWFwKCh7SUQsIEFkZHJzfSkgPT4gKHtcbiAgICAgICAgaWQ6IElELFxuICAgICAgICBhZGRyczogKEFkZHJzIHx8IFtdKS5tYXAoYSA9PiBuZXcgTXVsdGlhZGRyKGEpKVxuICAgICAgfSkpO1xuICAgICAgeWllbGQgbWVzc2FnZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5O1xufSk7IiwiZXhwb3J0IGNvbnN0IFNlbmRpbmdRdWVyeSA9IDA7XG5leHBvcnQgY29uc3QgUGVlclJlc3BvbnNlID0gMTtcbmV4cG9ydCBjb25zdCBGaW5hbFBlZXIgPSAyO1xuZXhwb3J0IGNvbnN0IFF1ZXJ5RXJyb3IgPSAzO1xuZXhwb3J0IGNvbnN0IFByb3ZpZGVyID0gNDtcbmV4cG9ydCBjb25zdCBWYWx1ZSA9IDU7XG5leHBvcnQgY29uc3QgQWRkaW5nUGVlciA9IDY7XG5leHBvcnQgY29uc3QgRGlhbGluZ1BlZXIgPSA3OyIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNtZHMgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gY21kcyhvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZGlhZy9jbWRzJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgfVxuICByZXR1cm4gY21kcztcbn0pOyIsImltcG9ydCB7IGNyZWF0ZUNtZHMgfSBmcm9tICcuL2NtZHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlTmV0IH0gZnJvbSAnLi9uZXQuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3lzIH0gZnJvbSAnLi9zeXMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURpYWcoY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgY21kczogY3JlYXRlQ21kcyhjb25maWcpLFxuICAgIG5ldDogY3JlYXRlTmV0KGNvbmZpZyksXG4gICAgc3lzOiBjcmVhdGVTeXMoY29uZmlnKVxuICB9O1xufSIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU5ldCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBuZXQob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2RpYWcvbmV0Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgfVxuICByZXR1cm4gbmV0O1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlU3lzID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIHN5cyhvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZGlhZy9zeXMnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiByZXMuanNvbigpO1xuICB9XG4gIHJldHVybiBzeXM7XG59KTsiLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlRG5zID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGNvbnN0IGRucyA9IGFzeW5jIChkb21haW4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdkbnMnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogZG9tYWluLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiBkYXRhLlBhdGg7XG4gIH07XG4gIHJldHVybiBkbnM7XG59KTsiLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVDaG1vZCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBjaG1vZChwYXRoLCBtb2RlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZmlsZXMvY2htb2QnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogcGF0aCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBhd2FpdCByZXMudGV4dCgpO1xuICB9XG4gIHJldHVybiBjaG1vZDtcbn0pOyIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlQ3AgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gY3Aoc291cmNlcywgZGVzdGluYXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHNvdXJjZUFyciA9IEFycmF5LmlzQXJyYXkoc291cmNlcykgPyBzb3VyY2VzIDogW3NvdXJjZXNdO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdmaWxlcy9jcCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBzb3VyY2VBcnIuY29uY2F0KGRlc3RpbmF0aW9uKS5tYXAoc3JjID0+IENJRC5hc0NJRChzcmMpID8gYC9pcGZzLyR7IHNyYyB9YCA6IHNyYyksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgYXdhaXQgcmVzLnRleHQoKTtcbiAgfVxuICByZXR1cm4gY3A7XG59KTsiLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUZsdXNoID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGZsdXNoKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghcGF0aCB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaXBmcy5maWxlcy5mbHVzaCByZXF1aXJlcyBhIHBhdGgnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2ZpbGVzL2ZsdXNoJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IHBhdGgsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIENJRC5wYXJzZShkYXRhLkNpZCk7XG4gIH1cbiAgcmV0dXJuIGZsdXNoO1xufSk7IiwiaW1wb3J0IHsgY3JlYXRlQ2htb2QgfSBmcm9tICcuL2NobW9kLmpzJztcbmltcG9ydCB7IGNyZWF0ZUNwIH0gZnJvbSAnLi9jcC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVGbHVzaCB9IGZyb20gJy4vZmx1c2guanMnO1xuaW1wb3J0IHsgY3JlYXRlTHMgfSBmcm9tICcuL2xzLmpzJztcbmltcG9ydCB7IGNyZWF0ZU1rZGlyIH0gZnJvbSAnLi9ta2Rpci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVNdiB9IGZyb20gJy4vbXYuanMnO1xuaW1wb3J0IHsgY3JlYXRlUmVhZCB9IGZyb20gJy4vcmVhZC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVSbSB9IGZyb20gJy4vcm0uanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RhdCB9IGZyb20gJy4vc3RhdC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVUb3VjaCB9IGZyb20gJy4vdG91Y2guanMnO1xuaW1wb3J0IHsgY3JlYXRlV3JpdGUgfSBmcm9tICcuL3dyaXRlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWxlcyhjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBjaG1vZDogY3JlYXRlQ2htb2QoY29uZmlnKSxcbiAgICBjcDogY3JlYXRlQ3AoY29uZmlnKSxcbiAgICBmbHVzaDogY3JlYXRlRmx1c2goY29uZmlnKSxcbiAgICBsczogY3JlYXRlTHMoY29uZmlnKSxcbiAgICBta2RpcjogY3JlYXRlTWtkaXIoY29uZmlnKSxcbiAgICBtdjogY3JlYXRlTXYoY29uZmlnKSxcbiAgICByZWFkOiBjcmVhdGVSZWFkKGNvbmZpZyksXG4gICAgcm06IGNyZWF0ZVJtKGNvbmZpZyksXG4gICAgc3RhdDogY3JlYXRlU3RhdChjb25maWcpLFxuICAgIHRvdWNoOiBjcmVhdGVUb3VjaChjb25maWcpLFxuICAgIHdyaXRlOiBjcmVhdGVXcml0ZShjb25maWcpXG4gIH07XG59IiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5pbXBvcnQgeyBvYmplY3RUb0NhbWVsV2l0aE1ldGFkYXRhIH0gZnJvbSAnLi4vbGliL29iamVjdC10by1jYW1lbC13aXRoLW1ldGFkYXRhLmpzJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUxzID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uKiBscyhwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaXBmcy5maWxlcy5scyByZXF1aXJlcyBhIHBhdGgnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2ZpbGVzL2xzJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IENJRC5hc0NJRChwYXRoKSA/IGAvaXBmcy8keyBwYXRoIH1gIDogcGF0aCxcbiAgICAgICAgbG9uZzogdHJ1ZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc3RyZWFtOiB0cnVlXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGZvciBhd2FpdCAoY29uc3QgcmVzdWx0IG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgaWYgKCdFbnRyaWVzJyBpbiByZXN1bHQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiByZXN1bHQuRW50cmllcyB8fCBbXSkge1xuICAgICAgICAgIHlpZWxkIHRvQ29yZUludGVyZmFjZShvYmplY3RUb0NhbWVsV2l0aE1ldGFkYXRhKGVudHJ5KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIHRvQ29yZUludGVyZmFjZShvYmplY3RUb0NhbWVsV2l0aE1ldGFkYXRhKHJlc3VsdCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbHM7XG59KTtcbmZ1bmN0aW9uIHRvQ29yZUludGVyZmFjZShlbnRyeSkge1xuICBpZiAoZW50cnkuaGFzaCkge1xuICAgIGVudHJ5LmNpZCA9IENJRC5wYXJzZShlbnRyeS5oYXNoKTtcbiAgfVxuICBkZWxldGUgZW50cnkuaGFzaDtcbiAgZW50cnkudHlwZSA9IGVudHJ5LnR5cGUgPT09IDEgPyAnZGlyZWN0b3J5JyA6ICdmaWxlJztcbiAgcmV0dXJuIGVudHJ5O1xufSIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU1rZGlyID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIG1rZGlyKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdmaWxlcy9ta2RpcicsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwYXRoLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGF3YWl0IHJlcy50ZXh0KCk7XG4gIH1cbiAgcmV0dXJuIG1rZGlyO1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlTXYgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gbXYoc291cmNlcywgZGVzdGluYXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzb3VyY2VzKSkge1xuICAgICAgc291cmNlcyA9IFtzb3VyY2VzXTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2ZpbGVzL212Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IHNvdXJjZXMuY29uY2F0KGRlc3RpbmF0aW9uKSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBhd2FpdCByZXMudGV4dCgpO1xuICB9XG4gIHJldHVybiBtdjtcbn0pOyIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuaW1wb3J0IHRvSXRlcmFibGUgZnJvbSAnc3RyZWFtLXRvLWl0L3NvdXJjZS5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUmVhZCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiogcmVhZChwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZmlsZXMvcmVhZCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwYXRoLFxuICAgICAgICBjb3VudDogb3B0aW9ucy5sZW5ndGgsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgeWllbGQqIHRvSXRlcmFibGUocmVzLmJvZHkpO1xuICB9XG4gIHJldHVybiByZWFkO1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUm0gPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gcm0ocGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2ZpbGVzL3JtJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IHBhdGgsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgYXdhaXQgcmVzLnRleHQoKTtcbiAgfVxuICByZXR1cm4gcm07XG59KTsiLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IG9iamVjdFRvQ2FtZWxXaXRoTWV0YWRhdGEgfSBmcm9tICcuLi9saWIvb2JqZWN0LXRvLWNhbWVsLXdpdGgtbWV0YWRhdGEuanMnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlU3RhdCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBzdGF0KHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdmaWxlcy9zdGF0Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IHBhdGgsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgZGF0YS5XaXRoTG9jYWxpdHkgPSBkYXRhLldpdGhMb2NhbGl0eSB8fCBmYWxzZTtcbiAgICByZXR1cm4gdG9Db3JlSW50ZXJmYWNlKG9iamVjdFRvQ2FtZWxXaXRoTWV0YWRhdGEoZGF0YSkpO1xuICB9XG4gIHJldHVybiBzdGF0O1xufSk7XG5mdW5jdGlvbiB0b0NvcmVJbnRlcmZhY2UoZW50cnkpIHtcbiAgZW50cnkuY2lkID0gQ0lELnBhcnNlKGVudHJ5Lmhhc2gpO1xuICBkZWxldGUgZW50cnkuaGFzaDtcbiAgcmV0dXJuIGVudHJ5O1xufSIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVRvdWNoID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIHRvdWNoKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdmaWxlcy90b3VjaCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwYXRoLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGF3YWl0IHJlcy50ZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHRvdWNoO1xufSk7IiwiaW1wb3J0IHsgbW9kZVRvU3RyaW5nIH0gZnJvbSAnLi4vbGliL21vZGUtdG8tc3RyaW5nLmpzJztcbmltcG9ydCB7IHBhcnNlTXRpbWUgfSBmcm9tICcuLi9saWIvcGFyc2UtbXRpbWUuanMnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyBtdWx0aXBhcnRSZXF1ZXN0IH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL211bHRpcGFydC1yZXF1ZXN0JztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmltcG9ydCB7IGFib3J0U2lnbmFsIH0gZnJvbSAnLi4vbGliL2Fib3J0LXNpZ25hbC5qcyc7XG5pbXBvcnQgeyBBYm9ydENvbnRyb2xsZXIgfSBmcm9tICduYXRpdmUtYWJvcnQtY29udHJvbGxlcic7XG5leHBvcnQgY29uc3QgY3JlYXRlV3JpdGUgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gd3JpdGUocGF0aCwgaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gYWJvcnRTaWduYWwoY29udHJvbGxlci5zaWduYWwsIG9wdGlvbnMuc2lnbmFsKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZmlsZXMvd3JpdGUnLCB7XG4gICAgICBzaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwYXRoLFxuICAgICAgICBzdHJlYW1DaGFubmVsczogdHJ1ZSxcbiAgICAgICAgY291bnQ6IG9wdGlvbnMubGVuZ3RoLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIC4uLmF3YWl0IG11bHRpcGFydFJlcXVlc3Qoe1xuICAgICAgICBjb250ZW50OiBpbnB1dCxcbiAgICAgICAgcGF0aDogJ2FyZycsXG4gICAgICAgIG1vZGU6IG1vZGVUb1N0cmluZyhvcHRpb25zLm1vZGUpLFxuICAgICAgICBtdGltZTogcGFyc2VNdGltZShvcHRpb25zLm10aW1lKVxuICAgICAgfSwgY29udHJvbGxlciwgb3B0aW9ucy5oZWFkZXJzKVxuICAgIH0pO1xuICAgIGF3YWl0IHJlcy50ZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHdyaXRlO1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi9saWIvY29uZmlndXJlLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVHZXRFbmRwb2ludENvbmZpZyA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXBpLm9wdHMuYmFzZSB8fCAnJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvc3Q6IHVybC5ob3N0bmFtZSxcbiAgICAgIHBvcnQ6IHVybC5wb3J0LFxuICAgICAgcHJvdG9jb2w6IHVybC5wcm90b2NvbCxcbiAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICAnYXBpLXBhdGgnOiB1cmwucGF0aG5hbWVcbiAgICB9O1xuICB9O1xufSk7IiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlR2V0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uKiBnZXQocGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGFyZzogYCR7IHBhdGggaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gQ0lELmRlY29kZShwYXRoKSA6IHBhdGggfWAsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBpZiAob3B0cy5jb21wcmVzc2lvbkxldmVsKSB7XG4gICAgICBvcHRzWydjb21wcmVzc2lvbi1sZXZlbCddID0gb3B0cy5jb21wcmVzc2lvbkxldmVsO1xuICAgICAgZGVsZXRlIG9wdHMuY29tcHJlc3Npb25MZXZlbDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2dldCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdHMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgeWllbGQqIHJlcy5pdGVyYXRvcigpO1xuICB9XG4gIHJldHVybiBnZXQ7XG59KTsiLCJpbXBvcnQgeyBvYmplY3RUb0NhbWVsIH0gZnJvbSAnLi9saWIvb2JqZWN0LXRvLWNhbWVsLmpzJztcbmltcG9ydCB7IE11bHRpYWRkciB9IGZyb20gJ211bHRpYWRkcic7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlSWQgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gaWQob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2lkJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IG9wdGlvbnMucGVlcklkID8gb3B0aW9ucy5wZWVySWQudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCBvdXRwdXQgPSB7IC4uLm9iamVjdFRvQ2FtZWwoZGF0YSkgfTtcbiAgICBpZiAob3V0cHV0LmFkZHJlc3Nlcykge1xuICAgICAgb3V0cHV0LmFkZHJlc3NlcyA9IG91dHB1dC5hZGRyZXNzZXMubWFwKG1hID0+IG5ldyBNdWx0aWFkZHIobWEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICByZXR1cm4gaWQ7XG59KTsiLCJpbXBvcnQgeyBNdWx0aWJhc2VzIH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL211bHRpYmFzZXMnO1xuaW1wb3J0IHsgTXVsdGljb2RlY3MgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvbXVsdGljb2RlY3MnO1xuaW1wb3J0IHsgTXVsdGloYXNoZXMgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvbXVsdGloYXNoZXMnO1xuaW1wb3J0ICogYXMgZGFnUEIgZnJvbSAnQGlwbGQvZGFnLXBiJztcbmltcG9ydCAqIGFzIGRhZ0NCT1IgZnJvbSAnQGlwbGQvZGFnLWNib3InO1xuaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tICdtdWx0aWZvcm1hdHMvaGFzaGVzL2lkZW50aXR5JztcbmltcG9ydCB7XG4gIGJhc2VzLFxuICBoYXNoZXMsXG4gIGNvZGVjc1xufSBmcm9tICdtdWx0aWZvcm1hdHMvYmFzaWNzJztcbmltcG9ydCB7IGNyZWF0ZUJpdHN3YXAgfSBmcm9tICcuL2JpdHN3YXAvaW5kZXguanMnO1xuaW1wb3J0IHsgY3JlYXRlQmxvY2sgfSBmcm9tICcuL2Jsb2NrL2luZGV4LmpzJztcbmltcG9ydCB7IGNyZWF0ZUJvb3RzdHJhcCB9IGZyb20gJy4vYm9vdHN0cmFwL2luZGV4LmpzJztcbmltcG9ydCB7IGNyZWF0ZUNvbmZpZyB9IGZyb20gJy4vY29uZmlnL2luZGV4LmpzJztcbmltcG9ydCB7IGNyZWF0ZURhZyB9IGZyb20gJy4vZGFnL2luZGV4LmpzJztcbmltcG9ydCB7IGNyZWF0ZURodCB9IGZyb20gJy4vZGh0L2luZGV4LmpzJztcbmltcG9ydCB7IGNyZWF0ZURpYWcgfSBmcm9tICcuL2RpYWcvaW5kZXguanMnO1xuaW1wb3J0IHsgY3JlYXRlRmlsZXMgfSBmcm9tICcuL2ZpbGVzL2luZGV4LmpzJztcbmltcG9ydCB7IGNyZWF0ZUtleSB9IGZyb20gJy4va2V5L2luZGV4LmpzJztcbmltcG9ydCB7IGNyZWF0ZUxvZyB9IGZyb20gJy4vbG9nL2luZGV4LmpzJztcbmltcG9ydCB7IGNyZWF0ZU5hbWUgfSBmcm9tICcuL25hbWUvaW5kZXguanMnO1xuaW1wb3J0IHsgY3JlYXRlT2JqZWN0IH0gZnJvbSAnLi9vYmplY3QvaW5kZXguanMnO1xuaW1wb3J0IHsgY3JlYXRlUGluIH0gZnJvbSAnLi9waW4vaW5kZXguanMnO1xuaW1wb3J0IHsgY3JlYXRlUHVic3ViIH0gZnJvbSAnLi9wdWJzdWIvaW5kZXguanMnO1xuaW1wb3J0IHsgY3JlYXRlUmVmcyB9IGZyb20gJy4vcmVmcy9pbmRleC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVSZXBvIH0gZnJvbSAnLi9yZXBvL2luZGV4LmpzJztcbmltcG9ydCB7IGNyZWF0ZVN0YXRzIH0gZnJvbSAnLi9zdGF0cy9pbmRleC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTd2FybSB9IGZyb20gJy4vc3dhcm0vaW5kZXguanMnO1xuaW1wb3J0IHsgY3JlYXRlQWRkIH0gZnJvbSAnLi9hZGQuanMnO1xuaW1wb3J0IHsgY3JlYXRlQWRkQWxsIH0gZnJvbSAnLi9hZGQtYWxsLmpzJztcbmltcG9ydCB7IGNyZWF0ZUNhdCB9IGZyb20gJy4vY2F0LmpzJztcbmltcG9ydCB7IGNyZWF0ZUNvbW1hbmRzIH0gZnJvbSAnLi9jb21tYW5kcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVEbnMgfSBmcm9tICcuL2Rucy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVHZXRFbmRwb2ludENvbmZpZyB9IGZyb20gJy4vZ2V0LWVuZHBvaW50LWNvbmZpZy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVHZXQgfSBmcm9tICcuL2dldC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVJZCB9IGZyb20gJy4vaWQuanMnO1xuaW1wb3J0IHsgY3JlYXRlSXNPbmxpbmUgfSBmcm9tICcuL2lzLW9ubGluZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVMcyB9IGZyb20gJy4vbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlTW91bnQgfSBmcm9tICcuL21vdW50LmpzJztcbmltcG9ydCB7IGNyZWF0ZVBpbmcgfSBmcm9tICcuL3BpbmcuanMnO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2ZSB9IGZyb20gJy4vcmVzb2x2ZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdGFydCB9IGZyb20gJy4vc3RhcnQuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RvcCB9IGZyb20gJy4vc3RvcC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVWZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmltcG9ydCBnbG9iU291cmNlSW1wb3J0IGZyb20gJ2lwZnMtdXRpbHMvc3JjL2ZpbGVzL2dsb2Itc291cmNlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGlkID0ge1xuICAgIG5hbWU6IGlkZW50aXR5Lm5hbWUsXG4gICAgY29kZTogaWRlbnRpdHkuY29kZSxcbiAgICBlbmNvZGU6IGlkID0+IGlkLFxuICAgIGRlY29kZTogaWQgPT4gaWRcbiAgfTtcbiAgY29uc3QgbXVsdGliYXNlQ29kZWNzID0gT2JqZWN0LnZhbHVlcyhiYXNlcyk7XG4gIChvcHRpb25zLmlwbGQgJiYgb3B0aW9ucy5pcGxkLmJhc2VzID8gb3B0aW9ucy5pcGxkLmJhc2VzIDogW10pLmZvckVhY2goYmFzZSA9PiBtdWx0aWJhc2VDb2RlY3MucHVzaChiYXNlKSk7XG4gIGNvbnN0IG11bHRpYmFzZXMgPSBuZXcgTXVsdGliYXNlcyh7XG4gICAgYmFzZXM6IG11bHRpYmFzZUNvZGVjcyxcbiAgICBsb2FkQmFzZTogb3B0aW9ucy5pcGxkICYmIG9wdGlvbnMuaXBsZC5sb2FkQmFzZVxuICB9KTtcbiAgY29uc3QgYmxvY2tDb2RlY3MgPSBPYmplY3QudmFsdWVzKGNvZGVjcyk7XG4gIFtcbiAgICBkYWdQQixcbiAgICBkYWdDQk9SLFxuICAgIGlkXG4gIF0uY29uY2F0KG9wdGlvbnMuaXBsZCAmJiBvcHRpb25zLmlwbGQuY29kZWNzIHx8IFtdKS5mb3JFYWNoKGNvZGVjID0+IGJsb2NrQ29kZWNzLnB1c2goY29kZWMpKTtcbiAgY29uc3QgbXVsdGljb2RlY3MgPSBuZXcgTXVsdGljb2RlY3Moe1xuICAgIGNvZGVjczogYmxvY2tDb2RlY3MsXG4gICAgbG9hZENvZGVjOiBvcHRpb25zLmlwbGQgJiYgb3B0aW9ucy5pcGxkLmxvYWRDb2RlY1xuICB9KTtcbiAgY29uc3QgbXVsdGloYXNoSGFzaGVycyA9IE9iamVjdC52YWx1ZXMoaGFzaGVzKTtcbiAgKG9wdGlvbnMuaXBsZCAmJiBvcHRpb25zLmlwbGQuaGFzaGVycyA/IG9wdGlvbnMuaXBsZC5oYXNoZXJzIDogW10pLmZvckVhY2goaGFzaGVyID0+IG11bHRpaGFzaEhhc2hlcnMucHVzaChoYXNoZXIpKTtcbiAgY29uc3QgbXVsdGloYXNoZXMgPSBuZXcgTXVsdGloYXNoZXMoe1xuICAgIGhhc2hlcnM6IG11bHRpaGFzaEhhc2hlcnMsXG4gICAgbG9hZEhhc2hlcjogb3B0aW9ucy5pcGxkICYmIG9wdGlvbnMuaXBsZC5sb2FkSGFzaGVyXG4gIH0pO1xuICBjb25zdCBjbGllbnQgPSB7XG4gICAgYWRkOiBjcmVhdGVBZGQob3B0aW9ucyksXG4gICAgYWRkQWxsOiBjcmVhdGVBZGRBbGwob3B0aW9ucyksXG4gICAgYml0c3dhcDogY3JlYXRlQml0c3dhcChvcHRpb25zKSxcbiAgICBibG9jazogY3JlYXRlQmxvY2sob3B0aW9ucyksXG4gICAgYm9vdHN0cmFwOiBjcmVhdGVCb290c3RyYXAob3B0aW9ucyksXG4gICAgY2F0OiBjcmVhdGVDYXQob3B0aW9ucyksXG4gICAgY29tbWFuZHM6IGNyZWF0ZUNvbW1hbmRzKG9wdGlvbnMpLFxuICAgIGNvbmZpZzogY3JlYXRlQ29uZmlnKG9wdGlvbnMpLFxuICAgIGRhZzogY3JlYXRlRGFnKG11bHRpY29kZWNzLCBvcHRpb25zKSxcbiAgICBkaHQ6IGNyZWF0ZURodChvcHRpb25zKSxcbiAgICBkaWFnOiBjcmVhdGVEaWFnKG9wdGlvbnMpLFxuICAgIGRuczogY3JlYXRlRG5zKG9wdGlvbnMpLFxuICAgIGZpbGVzOiBjcmVhdGVGaWxlcyhvcHRpb25zKSxcbiAgICBnZXQ6IGNyZWF0ZUdldChvcHRpb25zKSxcbiAgICBnZXRFbmRwb2ludENvbmZpZzogY3JlYXRlR2V0RW5kcG9pbnRDb25maWcob3B0aW9ucyksXG4gICAgaWQ6IGNyZWF0ZUlkKG9wdGlvbnMpLFxuICAgIGlzT25saW5lOiBjcmVhdGVJc09ubGluZShvcHRpb25zKSxcbiAgICBrZXk6IGNyZWF0ZUtleShvcHRpb25zKSxcbiAgICBsb2c6IGNyZWF0ZUxvZyhvcHRpb25zKSxcbiAgICBsczogY3JlYXRlTHMob3B0aW9ucyksXG4gICAgbW91bnQ6IGNyZWF0ZU1vdW50KG9wdGlvbnMpLFxuICAgIG5hbWU6IGNyZWF0ZU5hbWUob3B0aW9ucyksXG4gICAgb2JqZWN0OiBjcmVhdGVPYmplY3QobXVsdGljb2RlY3MsIG9wdGlvbnMpLFxuICAgIHBpbjogY3JlYXRlUGluKG9wdGlvbnMpLFxuICAgIHBpbmc6IGNyZWF0ZVBpbmcob3B0aW9ucyksXG4gICAgcHVic3ViOiBjcmVhdGVQdWJzdWIob3B0aW9ucyksXG4gICAgcmVmczogY3JlYXRlUmVmcyhvcHRpb25zKSxcbiAgICByZXBvOiBjcmVhdGVSZXBvKG9wdGlvbnMpLFxuICAgIHJlc29sdmU6IGNyZWF0ZVJlc29sdmUob3B0aW9ucyksXG4gICAgc3RhcnQ6IGNyZWF0ZVN0YXJ0KG9wdGlvbnMpLFxuICAgIHN0YXRzOiBjcmVhdGVTdGF0cyhvcHRpb25zKSxcbiAgICBzdG9wOiBjcmVhdGVTdG9wKG9wdGlvbnMpLFxuICAgIHN3YXJtOiBjcmVhdGVTd2FybShvcHRpb25zKSxcbiAgICB2ZXJzaW9uOiBjcmVhdGVWZXJzaW9uKG9wdGlvbnMpLFxuICAgIGJhc2VzOiBtdWx0aWJhc2VzLFxuICAgIGNvZGVjczogbXVsdGljb2RlY3MsXG4gICAgaGFzaGVyczogbXVsdGloYXNoZXNcbiAgfTtcbiAgcmV0dXJuIGNsaWVudDtcbn1cbmV4cG9ydCB7XG4gIENJRFxufSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmV4cG9ydCB7XG4gIE11bHRpYWRkciBhcyBtdWx0aWFkZHJcbn0gZnJvbSAnbXVsdGlhZGRyJztcbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdXJsU291cmNlXG59IGZyb20gJ2lwZnMtdXRpbHMvc3JjL2ZpbGVzL3VybC1zb3VyY2UuanMnO1xuZXhwb3J0IGNvbnN0IGdsb2JTb3VyY2UgPSBnbG9iU291cmNlSW1wb3J0OyIsImltcG9ydCB7IGNyZWF0ZUlkIH0gZnJvbSAnLi9pZC5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlSXNPbmxpbmUgPSBvcHRpb25zID0+IHtcbiAgY29uc3QgaWQgPSBjcmVhdGVJZChvcHRpb25zKTtcbiAgYXN5bmMgZnVuY3Rpb24gaXNPbmxpbmUob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaWQob3B0aW9ucyk7XG4gICAgcmV0dXJuIEJvb2xlYW4ocmVzICYmIHJlcy5hZGRyZXNzZXMgJiYgcmVzLmFkZHJlc3Nlcy5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBpc09ubGluZTtcbn07IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgZXJyQ29kZSBmcm9tICdlcnItY29kZSc7XG5leHBvcnQgY29uc3QgY3JlYXRlRXhwb3J0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGNvbnN0IGV4cG9ydEtleSA9IGFzeW5jIChuYW1lLCBwYXNzd29yZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpLCAnRVJSX05PVF9JTVBMRU1FTlRFRCcpO1xuICB9O1xuICByZXR1cm4gZXhwb3J0S2V5O1xufSk7IiwiaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4uL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlR2VuID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGdlbihuYW1lLCBvcHRpb25zID0ge1xuICAgIHR5cGU6ICdyc2EnLFxuICAgIHNpemU6IDIwNDhcbiAgfSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdrZXkvZ2VuJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IG5hbWUsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIG9iamVjdFRvQ2FtZWwoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGdlbjtcbn0pOyIsImltcG9ydCB7IG9iamVjdFRvQ2FtZWwgfSBmcm9tICcuLi9saWIvb2JqZWN0LXRvLWNhbWVsLmpzJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUltcG9ydCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBpbXBvcnRLZXkobmFtZSwgcGVtLCBwYXNzd29yZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ2tleS9pbXBvcnQnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogbmFtZSxcbiAgICAgICAgcGVtLFxuICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gb2JqZWN0VG9DYW1lbChkYXRhKTtcbiAgfVxuICByZXR1cm4gaW1wb3J0S2V5O1xufSk7IiwiaW1wb3J0IHsgY3JlYXRlRXhwb3J0IH0gZnJvbSAnLi9leHBvcnQuanMnO1xuaW1wb3J0IHsgY3JlYXRlR2VuIH0gZnJvbSAnLi9nZW4uanMnO1xuaW1wb3J0IHsgY3JlYXRlSW1wb3J0IH0gZnJvbSAnLi9pbXBvcnQuanMnO1xuaW1wb3J0IHsgY3JlYXRlSW5mbyB9IGZyb20gJy4vaW5mby5qcyc7XG5pbXBvcnQgeyBjcmVhdGVMaXN0IH0gZnJvbSAnLi9saXN0LmpzJztcbmltcG9ydCB7IGNyZWF0ZVJlbmFtZSB9IGZyb20gJy4vcmVuYW1lLmpzJztcbmltcG9ydCB7IGNyZWF0ZVJtIH0gZnJvbSAnLi9ybS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlS2V5KGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGV4cG9ydDogY3JlYXRlRXhwb3J0KGNvbmZpZyksXG4gICAgZ2VuOiBjcmVhdGVHZW4oY29uZmlnKSxcbiAgICBpbXBvcnQ6IGNyZWF0ZUltcG9ydChjb25maWcpLFxuICAgIGluZm86IGNyZWF0ZUluZm8oY29uZmlnKSxcbiAgICBsaXN0OiBjcmVhdGVMaXN0KGNvbmZpZyksXG4gICAgcmVuYW1lOiBjcmVhdGVSZW5hbWUoY29uZmlnKSxcbiAgICBybTogY3JlYXRlUm0oY29uZmlnKVxuICB9O1xufSIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUluZm8gPSBjb25maWd1cmUoYXBpID0+IHtcbiAgY29uc3QgaW5mbyA9IGFzeW5jIChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyksICdFUlJfTk9UX0lNUExFTUVOVEVEJyk7XG4gIH07XG4gIHJldHVybiBpbmZvO1xufSk7IiwiaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4uL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlTGlzdCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBsaXN0KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdrZXkvbGlzdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIChkYXRhLktleXMgfHwgW10pLm1hcChrID0+IG9iamVjdFRvQ2FtZWwoaykpO1xuICB9XG4gIHJldHVybiBsaXN0O1xufSk7IiwiaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4uL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUmVuYW1lID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIHJlbmFtZShvbGROYW1lLCBuZXdOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgna2V5L3JlbmFtZScsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBbXG4gICAgICAgICAgb2xkTmFtZSxcbiAgICAgICAgICBuZXdOYW1lXG4gICAgICAgIF0sXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIG9iamVjdFRvQ2FtZWwoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgcmV0dXJuIHJlbmFtZTtcbn0pOyIsImltcG9ydCB7IG9iamVjdFRvQ2FtZWwgfSBmcm9tICcuLi9saWIvb2JqZWN0LXRvLWNhbWVsLmpzJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJtID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIHJtKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdrZXkvcm0nLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogbmFtZSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gb2JqZWN0VG9DYW1lbChkYXRhLktleXNbMF0pO1xuICB9XG4gIHJldHVybiBybTtcbn0pOyIsImltcG9ydCB7IGFueVNpZ25hbCB9IGZyb20gJ2FueS1zaWduYWwnO1xuZnVuY3Rpb24gZmlsdGVyKHNpZ25hbHMpIHtcbiAgcmV0dXJuIHNpZ25hbHMuZmlsdGVyKEJvb2xlYW4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFib3J0U2lnbmFsKC4uLnNpZ25hbHMpIHtcbiAgcmV0dXJuIGFueVNpZ25hbChmaWx0ZXIoc2lnbmFscykpO1xufSIsImltcG9ydCB7IENsaWVudCB9IGZyb20gJy4vY29yZS5qcyc7XG5leHBvcnQgY29uc3QgY29uZmlndXJlID0gZm4gPT4ge1xuICByZXR1cm4gb3B0aW9ucyA9PiB7XG4gICAgcmV0dXJuIGZuKG5ldyBDbGllbnQob3B0aW9ucyksIG9wdGlvbnMpO1xuICB9O1xufTsiLCJpbXBvcnQgeyBNdWx0aWFkZHIgfSBmcm9tICdtdWx0aWFkZHInO1xuaW1wb3J0IHtcbiAgaXNCcm93c2VyLFxuICBpc1dlYldvcmtlcixcbiAgaXNOb2RlXG59IGZyb20gJ2lwZnMtdXRpbHMvc3JjL2Vudi5qcyc7XG5pbXBvcnQgcGFyc2VEdXJhdGlvbiBmcm9tICdwYXJzZS1kdXJhdGlvbic7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IEhUVFAgZnJvbSAnaXBmcy11dGlscy9zcmMvaHR0cC5qcyc7XG5pbXBvcnQgbWVyZ2VPcHRzIGZyb20gJ21lcmdlLW9wdGlvbnMnO1xuaW1wb3J0IHsgdG9VcmxTdHJpbmcgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvdG8tdXJsLXN0cmluZyc7XG5pbXBvcnQgZ2V0QWdlbnQgZnJvbSAnaXBmcy1jb3JlLXV0aWxzL2FnZW50JztcbmNvbnN0IGxvZyA9IGRlYnVnKCdpcGZzLWh0dHAtY2xpZW50OmxpYjplcnJvci1oYW5kbGVyJyk7XG5jb25zdCBtZXJnZSA9IG1lcmdlT3B0cy5iaW5kKHsgaWdub3JlVW5kZWZpbmVkOiB0cnVlIH0pO1xuY29uc3QgREVGQVVMVF9QUk9UT0NPTCA9IGlzQnJvd3NlciB8fCBpc1dlYldvcmtlciA/IGxvY2F0aW9uLnByb3RvY29sIDogJ2h0dHAnO1xuY29uc3QgREVGQVVMVF9IT1NUID0gaXNCcm93c2VyIHx8IGlzV2ViV29ya2VyID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0JztcbmNvbnN0IERFRkFVTFRfUE9SVCA9IGlzQnJvd3NlciB8fCBpc1dlYldvcmtlciA/IGxvY2F0aW9uLnBvcnQgOiAnNTAwMSc7XG5jb25zdCBub3JtYWxpemVPcHRpb25zID0gKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBsZXQgdXJsO1xuICBsZXQgb3B0cyA9IHt9O1xuICBsZXQgYWdlbnQ7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycgfHwgTXVsdGlhZGRyLmlzTXVsdGlhZGRyKG9wdGlvbnMpKSB7XG4gICAgdXJsID0gbmV3IFVSTCh0b1VybFN0cmluZyhvcHRpb25zKSk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHVybCA9IG9wdGlvbnM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMudXJsID09PSAnc3RyaW5nJyB8fCBNdWx0aWFkZHIuaXNNdWx0aWFkZHIob3B0aW9ucy51cmwpKSB7XG4gICAgdXJsID0gbmV3IFVSTCh0b1VybFN0cmluZyhvcHRpb25zLnVybCkpO1xuICAgIG9wdHMgPSBvcHRpb25zO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMudXJsIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgdXJsID0gb3B0aW9ucy51cmw7XG4gICAgb3B0cyA9IG9wdGlvbnM7XG4gIH0gZWxzZSB7XG4gICAgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcHJvdG9jb2wgPSAob3B0cy5wcm90b2NvbCB8fCBERUZBVUxUX1BST1RPQ09MKS5yZXBsYWNlKCc6JywgJycpO1xuICAgIGNvbnN0IGhvc3QgPSAob3B0cy5ob3N0IHx8IERFRkFVTFRfSE9TVCkuc3BsaXQoJzonKVswXTtcbiAgICBjb25zdCBwb3J0ID0gb3B0cy5wb3J0IHx8IERFRkFVTFRfUE9SVDtcbiAgICB1cmwgPSBuZXcgVVJMKGAkeyBwcm90b2NvbCB9Oi8vJHsgaG9zdCB9OiR7IHBvcnQgfWApO1xuICB9XG4gIGlmIChvcHRzLmFwaVBhdGgpIHtcbiAgICB1cmwucGF0aG5hbWUgPSBvcHRzLmFwaVBhdGg7XG4gIH0gZWxzZSBpZiAodXJsLnBhdGhuYW1lID09PSAnLycgfHwgdXJsLnBhdGhuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB1cmwucGF0aG5hbWUgPSAnYXBpL3YwJztcbiAgfVxuICBpZiAoaXNOb2RlKSB7XG4gICAgY29uc3QgQWdlbnQgPSBnZXRBZ2VudCh1cmwpO1xuICAgIGFnZW50ID0gb3B0cy5hZ2VudCB8fCBuZXcgQWdlbnQoe1xuICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAgbWF4U29ja2V0czogNlxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4ub3B0cyxcbiAgICBob3N0OiB1cmwuaG9zdCxcbiAgICBwcm90b2NvbDogdXJsLnByb3RvY29sLnJlcGxhY2UoJzonLCAnJyksXG4gICAgcG9ydDogTnVtYmVyKHVybC5wb3J0KSxcbiAgICBhcGlQYXRoOiB1cmwucGF0aG5hbWUsXG4gICAgdXJsLFxuICAgIGFnZW50XG4gIH07XG59O1xuZXhwb3J0IGNvbnN0IGVycm9ySGFuZGxlciA9IGFzeW5jIHJlc3BvbnNlID0+IHtcbiAgbGV0IG1zZztcbiAgdHJ5IHtcbiAgICBpZiAoKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSB8fCAnJykuc3RhcnRzV2l0aCgnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgbG9nKGRhdGEpO1xuICAgICAgbXNnID0gZGF0YS5NZXNzYWdlIHx8IGRhdGEubWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbXNnID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nKCdGYWlsZWQgdG8gcGFyc2UgZXJyb3IgcmVzcG9uc2UnLCBlcnIpO1xuICAgIG1zZyA9IGVyci5tZXNzYWdlO1xuICB9XG4gIGxldCBlcnJvciA9IG5ldyBIVFRQLkhUVFBFcnJvcihyZXNwb25zZSk7XG4gIGlmIChtc2cpIHtcbiAgICBpZiAobXNnLmluY2x1ZGVzKCdkZWFkbGluZSBoYXMgZWxhcHNlZCcpKSB7XG4gICAgICBlcnJvciA9IG5ldyBIVFRQLlRpbWVvdXRFcnJvcigpO1xuICAgIH1cbiAgICBpZiAobXNnICYmIG1zZy5pbmNsdWRlcygnY29udGV4dCBkZWFkbGluZSBleGNlZWRlZCcpKSB7XG4gICAgICBlcnJvciA9IG5ldyBIVFRQLlRpbWVvdXRFcnJvcigpO1xuICAgIH1cbiAgfVxuICBpZiAobXNnICYmIG1zZy5pbmNsdWRlcygncmVxdWVzdCB0aW1lZCBvdXQnKSkge1xuICAgIGVycm9yID0gbmV3IEhUVFAuVGltZW91dEVycm9yKCk7XG4gIH1cbiAgaWYgKG1zZykge1xuICAgIGVycm9yLm1lc3NhZ2UgPSBtc2c7XG4gIH1cbiAgdGhyb3cgZXJyb3I7XG59O1xuY29uc3QgS0VCQUJfUkVHRVggPSAvW0EtWlxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBERV0vZztcbmNvbnN0IGtlYmFiQ2FzZSA9IHN0ciA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShLRUJBQl9SRUdFWCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuICctJyArIG1hdGNoLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufTtcbmNvbnN0IHBhcnNlVGltZW91dCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUR1cmF0aW9uKHZhbHVlKSA6IHZhbHVlO1xufTtcbmV4cG9ydCBjbGFzcyBDbGllbnQgZXh0ZW5kcyBIVFRQIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgc3VwZXIoe1xuICAgICAgdGltZW91dDogcGFyc2VUaW1lb3V0KG9wdHMudGltZW91dCB8fCAwKSB8fCB1bmRlZmluZWQsXG4gICAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnMsXG4gICAgICBiYXNlOiBgJHsgb3B0cy51cmwgfWAsXG4gICAgICBoYW5kbGVFcnJvcjogZXJyb3JIYW5kbGVyLFxuICAgICAgdHJhbnNmb3JtU2VhcmNoUGFyYW1zOiBzZWFyY2ggPT4ge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNlYXJjaCkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09ICdudWxsJyAmJiBrZXkgIT09ICdzaWduYWwnKSB7XG4gICAgICAgICAgICBvdXQuYXBwZW5kKGtlYmFiQ2FzZShrZXkpLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXkgPT09ICd0aW1lb3V0JyAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBvdXQuYXBwZW5kKGtlYmFiQ2FzZShrZXkpLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9LFxuICAgICAgYWdlbnQ6IG9wdHMuYWdlbnRcbiAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5nZXQ7XG4gICAgZGVsZXRlIHRoaXMucHV0O1xuICAgIGRlbGV0ZSB0aGlzLmRlbGV0ZTtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZldGNoID0gdGhpcy5mZXRjaDtcbiAgICB0aGlzLmZldGNoID0gKHJlc291cmNlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnICYmICFyZXNvdXJjZS5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmVzb3VyY2UgPSBgJHsgb3B0cy51cmwgfS8keyByZXNvdXJjZSB9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmZXRjaC5jYWxsKHRoaXMsIHJlc291cmNlLCBtZXJnZShvcHRpb25zLCB7IG1ldGhvZDogJ1BPU1QnIH0pKTtcbiAgICB9O1xuICB9XG59XG5leHBvcnQgY29uc3QgSFRUUEVycm9yID0gSFRUUC5IVFRQRXJyb3I7IiwiZXhwb3J0IGZ1bmN0aW9uIG1vZGVUb1N0cmluZyhtb2RlKSB7XG4gIGlmIChtb2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbW9kZTtcbiAgfVxuICByZXR1cm4gbW9kZS50b1N0cmluZyg4KS5wYWRTdGFydCg0LCAnMCcpO1xufSIsImltcG9ydCB7IG9iamVjdFRvQ2FtZWwgfSBmcm9tICcuL29iamVjdC10by1jYW1lbC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0VG9DYW1lbFdpdGhNZXRhZGF0YShlbnRyeSkge1xuICBjb25zdCBmaWxlID0gb2JqZWN0VG9DYW1lbChlbnRyeSk7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZmlsZSwgJ21vZGUnKSkge1xuICAgIGZpbGUubW9kZSA9IHBhcnNlSW50KGZpbGUubW9kZSwgOCk7XG4gIH1cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmaWxlLCAnbXRpbWUnKSkge1xuICAgIGZpbGUubXRpbWUgPSB7XG4gICAgICBzZWNzOiBmaWxlLm10aW1lLFxuICAgICAgbnNlY3M6IGZpbGUubXRpbWVOc2VjcyB8fCAwXG4gICAgfTtcbiAgICBkZWxldGUgZmlsZS5tdGltZU5zZWNzO1xuICB9XG4gIHJldHVybiBmaWxlO1xufSIsImV4cG9ydCBmdW5jdGlvbiBvYmplY3RUb0NhbWVsKG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGNvbnN0IGNhcHMgPSAvXltBLVpdKyQvO1xuICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChjYW1lbE9iaiwgaykgPT4ge1xuICAgIGlmIChjYXBzLnRlc3QoaykpIHtcbiAgICAgIGNhbWVsT2JqW2sudG9Mb3dlckNhc2UoKV0gPSBvYmpba107XG4gICAgfSBlbHNlIGlmIChjYXBzLnRlc3Qoa1swXSkpIHtcbiAgICAgIGNhbWVsT2JqW2tbMF0udG9Mb3dlckNhc2UoKSArIGsuc2xpY2UoMSldID0gb2JqW2tdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW1lbE9ialtrXSA9IG9ialtrXTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbWVsT2JqO1xuICB9LCBvdXRwdXQpO1xufSIsImltcG9ydCBlcnJDb2RlIGZyb20gJ2Vyci1jb2RlJztcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU10aW1lKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgbXRpbWU7XG4gIGlmIChpbnB1dC5zZWNzICE9IG51bGwpIHtcbiAgICBtdGltZSA9IHtcbiAgICAgIHNlY3M6IGlucHV0LnNlY3MsXG4gICAgICBuc2VjczogaW5wdXQubnNlY3NcbiAgICB9O1xuICB9XG4gIGlmIChpbnB1dC5TZWNvbmRzICE9IG51bGwpIHtcbiAgICBtdGltZSA9IHtcbiAgICAgIHNlY3M6IGlucHV0LlNlY29uZHMsXG4gICAgICBuc2VjczogaW5wdXQuRnJhY3Rpb25hbE5hbm9zZWNvbmRzXG4gICAgfTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICBtdGltZSA9IHtcbiAgICAgIHNlY3M6IGlucHV0WzBdLFxuICAgICAgbnNlY3M6IGlucHV0WzFdXG4gICAgfTtcbiAgfVxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgY29uc3QgbXMgPSBpbnB1dC5nZXRUaW1lKCk7XG4gICAgY29uc3Qgc2VjcyA9IE1hdGguZmxvb3IobXMgLyAxMDAwKTtcbiAgICBtdGltZSA9IHtcbiAgICAgIHNlY3M6IHNlY3MsXG4gICAgICBuc2VjczogKG1zIC0gc2VjcyAqIDEwMDApICogMTAwMFxuICAgIH07XG4gIH1cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobXRpbWUsICdzZWNzJykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChtdGltZSAhPSBudWxsICYmIG10aW1lLm5zZWNzICE9IG51bGwgJiYgKG10aW1lLm5zZWNzIDwgMCB8fCBtdGltZS5uc2VjcyA+IDk5OTk5OTk5OSkpIHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignbXRpbWUtbnNlY3MgbXVzdCBiZSB3aXRoaW4gdGhlIHJhbmdlIFswLDk5OTk5OTk5OV0nKSwgJ0VSUl9JTlZBTElEX01USU1FX05TRUNTJyk7XG4gIH1cbiAgcmV0dXJuIG10aW1lO1xufSIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiByZXNvbHZlKGNpZCwgcGF0aCwgY29kZWNzLCBnZXRCbG9jaywgb3B0aW9ucykge1xuICBjb25zdCBsb2FkID0gYXN5bmMgY2lkID0+IHtcbiAgICBjb25zdCBjb2RlYyA9IGF3YWl0IGNvZGVjcy5nZXRDb2RlYyhjaWQuY29kZSk7XG4gICAgY29uc3QgYmxvY2sgPSBhd2FpdCBnZXRCbG9jayhjaWQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjb2RlYy5kZWNvZGUoYmxvY2spO1xuICB9O1xuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCB2YWx1ZSA9IGF3YWl0IGxvYWQoY2lkKTtcbiAgbGV0IGxhc3RDaWQgPSBjaWQ7XG4gIGlmICghcGFydHMubGVuZ3RoKSB7XG4gICAgeWllbGQge1xuICAgICAgdmFsdWUsXG4gICAgICByZW1haW5kZXJQYXRoOiAnJ1xuICAgIH07XG4gIH1cbiAgd2hpbGUgKHBhcnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSBwYXRoIFwiJHsgcGF0aCB9XCJgKSwgJ0VSUl9JTlZBTElEX1BBVEgnKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgICAgeWllbGQge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgcmVtYWluZGVyUGF0aDogcGFydHMuam9pbignLycpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcihgbm8gbGluayBuYW1lZCBcIiR7IGtleSB9XCIgdW5kZXIgJHsgbGFzdENpZCB9YCksICdFUlJfTk9fTElOSycpO1xuICAgIH1cbiAgICBjb25zdCBjaWQgPSBDSUQuYXNDSUQodmFsdWUpO1xuICAgIGlmIChjaWQpIHtcbiAgICAgIGxhc3RDaWQgPSBjaWQ7XG4gICAgICB2YWx1ZSA9IGF3YWl0IGxvYWQodmFsdWUpO1xuICAgIH1cbiAgfVxufSIsImltcG9ydCB7IG1vZGVUb1N0cmluZyB9IGZyb20gJy4vbW9kZS10by1zdHJpbmcuanMnO1xuaW1wb3J0IHsgcGFyc2VNdGltZSB9IGZyb20gJy4uL2xpYi9wYXJzZS1tdGltZS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gdG9VcmxTZWFyY2hQYXJhbXMoe2FyZywgc2VhcmNoUGFyYW1zLCBoYXNoQWxnLCBtdGltZSwgbW9kZSwgLi4ub3B0aW9uc30gPSB7fSkge1xuICBpZiAoc2VhcmNoUGFyYW1zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAuLi5zZWFyY2hQYXJhbXNcbiAgICB9O1xuICB9XG4gIGlmIChoYXNoQWxnKSB7XG4gICAgb3B0aW9ucy5oYXNoID0gaGFzaEFsZztcbiAgfVxuICBpZiAobXRpbWUgIT0gbnVsbCkge1xuICAgIG10aW1lID0gcGFyc2VNdGltZShtdGltZSk7XG4gICAgb3B0aW9ucy5tdGltZSA9IG10aW1lLnNlY3M7XG4gICAgb3B0aW9ucy5tdGltZU5zZWNzID0gbXRpbWUubnNlY3M7XG4gIH1cbiAgaWYgKG1vZGUgIT0gbnVsbCkge1xuICAgIG9wdGlvbnMubW9kZSA9IG1vZGVUb1N0cmluZyhtb2RlKTtcbiAgfVxuICBpZiAob3B0aW9ucy50aW1lb3V0ICYmICFpc05hTihvcHRpb25zLnRpbWVvdXQpKSB7XG4gICAgb3B0aW9ucy50aW1lb3V0ID0gYCR7IG9wdGlvbnMudGltZW91dCB9bXNgO1xuICB9XG4gIGlmIChhcmcgPT09IHVuZGVmaW5lZCB8fCBhcmcgPT09IG51bGwpIHtcbiAgICBhcmcgPSBbXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgYXJnID0gW2FyZ107XG4gIH1cbiAgY29uc3QgdXJsU2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zKTtcbiAgYXJnLmZvckVhY2goYXJnID0+IHVybFNlYXJjaFBhcmFtcy5hcHBlbmQoJ2FyZycsIGFyZykpO1xuICByZXR1cm4gdXJsU2VhcmNoUGFyYW1zO1xufSIsImltcG9ydCB7IGNyZWF0ZUxldmVsIH0gZnJvbSAnLi9sZXZlbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVMcyB9IGZyb20gJy4vbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlVGFpbCB9IGZyb20gJy4vdGFpbC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTG9nKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGxldmVsOiBjcmVhdGVMZXZlbChjb25maWcpLFxuICAgIGxzOiBjcmVhdGVMcyhjb25maWcpLFxuICAgIHRhaWw6IGNyZWF0ZVRhaWwoY29uZmlnKVxuICB9O1xufSIsImltcG9ydCB7IG9iamVjdFRvQ2FtZWwgfSBmcm9tICcuLi9saWIvb2JqZWN0LXRvLWNhbWVsLmpzJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUxldmVsID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGxldmVsKHN1YnN5c3RlbSwgbGV2ZWwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdsb2cvbGV2ZWwnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogW1xuICAgICAgICAgIHN1YnN5c3RlbSxcbiAgICAgICAgICBsZXZlbFxuICAgICAgICBdLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBvYmplY3RUb0NhbWVsKGF3YWl0IHJlcy5qc29uKCkpO1xuICB9XG4gIHJldHVybiBsZXZlbDtcbn0pOyIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUxzID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGxzKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdsb2cvbHMnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiBkYXRhLlN0cmluZ3M7XG4gIH1cbiAgcmV0dXJuIGxzO1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlVGFpbCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiogdGFpbChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnbG9nL3RhaWwnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIHlpZWxkKiByZXMubmRqc29uKCk7XG4gIH1cbiAgcmV0dXJuIHRhaWw7XG59KTsiLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN0YXQgfSBmcm9tICcuL2ZpbGVzL3N0YXQuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUxzID0gY29uZmlndXJlKChhcGksIG9wdHMpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24qIGxzKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHBhdGhTdHIgPSBgJHsgcGF0aCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBDSUQuZGVjb2RlKHBhdGgpIDogcGF0aCB9YDtcbiAgICBhc3luYyBmdW5jdGlvbiBtYXBMaW5rKGxpbmspIHtcbiAgICAgIGxldCBoYXNoID0gbGluay5IYXNoO1xuICAgICAgaWYgKGhhc2guaW5jbHVkZXMoJy8nKSkge1xuICAgICAgICBjb25zdCBpcGZzUGF0aCA9IGhhc2guc3RhcnRzV2l0aCgnL2lwZnMvJykgPyBoYXNoIDogYC9pcGZzLyR7IGhhc2ggfWA7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgY3JlYXRlU3RhdChvcHRzKShpcGZzUGF0aCk7XG4gICAgICAgIGhhc2ggPSBzdGF0cy5jaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNoID0gQ0lELnBhcnNlKGhhc2gpO1xuICAgICAgfVxuICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgIG5hbWU6IGxpbmsuTmFtZSxcbiAgICAgICAgcGF0aDogcGF0aFN0ciArIChsaW5rLk5hbWUgPyBgLyR7IGxpbmsuTmFtZSB9YCA6ICcnKSxcbiAgICAgICAgc2l6ZTogbGluay5TaXplLFxuICAgICAgICBjaWQ6IGhhc2gsXG4gICAgICAgIHR5cGU6IHR5cGVPZihsaW5rKVxuICAgICAgfTtcbiAgICAgIGlmIChsaW5rLk1vZGUpIHtcbiAgICAgICAgZW50cnkubW9kZSA9IHBhcnNlSW50KGxpbmsuTW9kZSwgOCk7XG4gICAgICB9XG4gICAgICBpZiAobGluay5NdGltZSAhPT0gdW5kZWZpbmVkICYmIGxpbmsuTXRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgZW50cnkubXRpbWUgPSB7IHNlY3M6IGxpbmsuTXRpbWUgfTtcbiAgICAgICAgaWYgKGxpbmsuTXRpbWVOc2VjcyAhPT0gdW5kZWZpbmVkICYmIGxpbmsuTXRpbWVOc2VjcyAhPT0gbnVsbCkge1xuICAgICAgICAgIGVudHJ5Lm10aW1lLm5zZWNzID0gbGluay5NdGltZU5zZWNzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdscycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwYXRoU3RyLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGZvciBhd2FpdCAobGV0IHJlc3VsdCBvZiByZXMubmRqc29uKCkpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5PYmplY3RzO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCAuT2JqZWN0cyBpbiByZXN1bHRzJyk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSByZXN1bHRbMF07XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIG9uZSBhcnJheSBpbiByZXN1bHRzLk9iamVjdHMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmtzID0gcmVzdWx0LkxpbmtzO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpbmtzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIG9uZSBhcnJheSBpbiByZXN1bHRzLk9iamVjdHNbMF0uTGlua3MnKTtcbiAgICAgIH1cbiAgICAgIGlmICghbGlua3MubGVuZ3RoKSB7XG4gICAgICAgIHlpZWxkIG1hcExpbmsocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgeWllbGQqIGxpbmtzLm1hcChtYXBMaW5rKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxzO1xufSk7XG5mdW5jdGlvbiB0eXBlT2YobGluaykge1xuICBzd2l0Y2ggKGxpbmsuVHlwZSkge1xuICBjYXNlIDE6XG4gIGNhc2UgNTpcbiAgICByZXR1cm4gJ2Rpcic7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gJ2ZpbGUnO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiAnZmlsZSc7XG4gIH1cbn0iLCJpbXBvcnQgeyBvYmplY3RUb0NhbWVsIH0gZnJvbSAnLi9saWIvb2JqZWN0LXRvLWNhbWVsLmpzJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVNb3VudCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBtb3VudChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnZG5zJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqZWN0VG9DYW1lbChhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICByZXR1cm4gbW91bnQ7XG59KTsiLCJpbXBvcnQgeyBjcmVhdGVQdWJsaXNoIH0gZnJvbSAnLi9wdWJsaXNoLmpzJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmUgfSBmcm9tICcuL3Jlc29sdmUuanMnO1xuaW1wb3J0IHsgY3JlYXRlUHVic3ViIH0gZnJvbSAnLi9wdWJzdWIvaW5kZXguanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5hbWUoY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgcHVibGlzaDogY3JlYXRlUHVibGlzaChjb25maWcpLFxuICAgIHJlc29sdmU6IGNyZWF0ZVJlc29sdmUoY29uZmlnKSxcbiAgICBwdWJzdWI6IGNyZWF0ZVB1YnN1Yihjb25maWcpXG4gIH07XG59IiwiaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4uL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUHVibGlzaCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBwdWJsaXNoKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCduYW1lL3B1Ymxpc2gnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogYCR7IHBhdGggfWAsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIG9iamVjdFRvQ2FtZWwoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgcmV0dXJuIHB1Ymxpc2g7XG59KTsiLCJpbXBvcnQgeyBvYmplY3RUb0NhbWVsIH0gZnJvbSAnLi4vLi4vbGliL29iamVjdC10by1jYW1lbC5qcyc7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi8uLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVDYW5jZWwgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gY2FuY2VsKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCduYW1lL3B1YnN1Yi9jYW5jZWwnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogbmFtZSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqZWN0VG9DYW1lbChhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICByZXR1cm4gY2FuY2VsO1xufSk7IiwiaW1wb3J0IHsgY3JlYXRlQ2FuY2VsIH0gZnJvbSAnLi9jYW5jZWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RhdGUgfSBmcm9tICcuL3N0YXRlLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN1YnMgfSBmcm9tICcuL3N1YnMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVB1YnN1Yihjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBjYW5jZWw6IGNyZWF0ZUNhbmNlbChjb25maWcpLFxuICAgIHN0YXRlOiBjcmVhdGVTdGF0ZShjb25maWcpLFxuICAgIHN1YnM6IGNyZWF0ZVN1YnMoY29uZmlnKVxuICB9O1xufSIsImltcG9ydCB7IG9iamVjdFRvQ2FtZWwgfSBmcm9tICcuLi8uLi9saWIvb2JqZWN0LXRvLWNhbWVsLmpzJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uLy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi8uLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0YXRlID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXRlKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCduYW1lL3B1YnN1Yi9zdGF0ZScsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIG9iamVjdFRvQ2FtZWwoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uLy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlU3VicyA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBzdWJzKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCduYW1lL3B1YnN1Yi9zdWJzJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YS5TdHJpbmdzIHx8IFtdO1xuICB9XG4gIHJldHVybiBzdWJzO1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUmVzb2x2ZSA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiogcmVzb2x2ZShwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnbmFtZS9yZXNvbHZlJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IHBhdGgsXG4gICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHJlc3VsdCBvZiByZXMubmRqc29uKCkpIHtcbiAgICAgIHlpZWxkIHJlc3VsdC5QYXRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzb2x2ZTtcbn0pOyIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlRGF0YSA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBkYXRhKGNpZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ29iamVjdC9kYXRhJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGAkeyBjaWQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gQ0lELmRlY29kZShjaWQpIDogY2lkIH1gLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuYXJyYXlCdWZmZXIoKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn0pOyIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5pbXBvcnQgeyBmcm9tU3RyaW5nIGFzIHVpbnQ4QXJyYXlGcm9tU3RyaW5nIH0gZnJvbSAndWludDhhcnJheXMvZnJvbS1zdHJpbmcnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUdldCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBnZXQoY2lkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnb2JqZWN0L2dldCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBgJHsgY2lkIGluc3RhbmNlb2YgVWludDhBcnJheSA/IENJRC5kZWNvZGUoY2lkKSA6IGNpZCB9YCxcbiAgICAgICAgZGF0YUVuY29kaW5nOiAnYmFzZTY0JyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgRGF0YTogdWludDhBcnJheUZyb21TdHJpbmcoZGF0YS5EYXRhLCAnYmFzZTY0cGFkJyksXG4gICAgICBMaW5rczogKGRhdGEuTGlua3MgfHwgW10pLm1hcChsaW5rID0+ICh7XG4gICAgICAgIE5hbWU6IGxpbmsuTmFtZSxcbiAgICAgICAgSGFzaDogQ0lELnBhcnNlKGxpbmsuSGFzaCksXG4gICAgICAgIFRzaXplOiBsaW5rLlNpemVcbiAgICAgIH0pKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGdldDtcbn0pOyIsImltcG9ydCB7IGNyZWF0ZURhdGEgfSBmcm9tICcuL2RhdGEuanMnO1xuaW1wb3J0IHsgY3JlYXRlR2V0IH0gZnJvbSAnLi9nZXQuanMnO1xuaW1wb3J0IHsgY3JlYXRlTGlua3MgfSBmcm9tICcuL2xpbmtzLmpzJztcbmltcG9ydCB7IGNyZWF0ZU5ldyB9IGZyb20gJy4vbmV3LmpzJztcbmltcG9ydCB7IGNyZWF0ZVB1dCB9IGZyb20gJy4vcHV0LmpzJztcbmltcG9ydCB7IGNyZWF0ZVN0YXQgfSBmcm9tICcuL3N0YXQuanMnO1xuaW1wb3J0IHsgY3JlYXRlUGF0Y2ggfSBmcm9tICcuL3BhdGNoL2luZGV4LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPYmplY3QoY29kZWNzLCBjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBjcmVhdGVEYXRhKGNvbmZpZyksXG4gICAgZ2V0OiBjcmVhdGVHZXQoY29uZmlnKSxcbiAgICBsaW5rczogY3JlYXRlTGlua3MoY29uZmlnKSxcbiAgICBuZXc6IGNyZWF0ZU5ldyhjb25maWcpLFxuICAgIHB1dDogY3JlYXRlUHV0KGNvZGVjcywgY29uZmlnKSxcbiAgICBzdGF0OiBjcmVhdGVTdGF0KGNvbmZpZyksXG4gICAgcGF0Y2g6IGNyZWF0ZVBhdGNoKGNvbmZpZylcbiAgfTtcbn0iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUxpbmtzID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGxpbmtzKGNpZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ29iamVjdC9saW5rcycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBgJHsgY2lkIGluc3RhbmNlb2YgVWludDhBcnJheSA/IENJRC5kZWNvZGUoY2lkKSA6IGNpZCB9YCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gKGRhdGEuTGlua3MgfHwgW10pLm1hcChsID0+ICh7XG4gICAgICBOYW1lOiBsLk5hbWUsXG4gICAgICBUc2l6ZTogbC5TaXplLFxuICAgICAgSGFzaDogQ0lELnBhcnNlKGwuSGFzaClcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIGxpbmtzO1xufSk7IiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVOZXcgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gbmV3T2JqZWN0KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdvYmplY3QvbmV3Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IG9wdGlvbnMudGVtcGxhdGUsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3Qge0hhc2h9ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gQ0lELnBhcnNlKEhhc2gpO1xuICB9XG4gIHJldHVybiBuZXdPYmplY3Q7XG59KTsiLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uLy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi8uLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUFkZExpbmsgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gYWRkTGluayhjaWQsIGRMaW5rLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnb2JqZWN0L3BhdGNoL2FkZC1saW5rJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IFtcbiAgICAgICAgICBgJHsgY2lkIH1gLFxuICAgICAgICAgIGRMaW5rLk5hbWUgfHwgZExpbmsubmFtZSB8fCAnJyxcbiAgICAgICAgICAoZExpbmsuSGFzaCB8fCBkTGluay5jaWQgfHwgJycpLnRvU3RyaW5nKCkgfHwgbnVsbFxuICAgICAgICBdLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHtIYXNofSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIENJRC5wYXJzZShIYXNoKTtcbiAgfVxuICByZXR1cm4gYWRkTGluaztcbn0pOyIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgbXVsdGlwYXJ0UmVxdWVzdCB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9tdWx0aXBhcnQtcmVxdWVzdCc7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi8uLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmltcG9ydCB7IGFib3J0U2lnbmFsIH0gZnJvbSAnLi4vLi4vbGliL2Fib3J0LXNpZ25hbC5qcyc7XG5pbXBvcnQgeyBBYm9ydENvbnRyb2xsZXIgfSBmcm9tICduYXRpdmUtYWJvcnQtY29udHJvbGxlcic7XG5leHBvcnQgY29uc3QgY3JlYXRlQXBwZW5kRGF0YSA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBhcHBlbmREYXRhKGNpZCwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSBhYm9ydFNpZ25hbChjb250cm9sbGVyLnNpZ25hbCwgb3B0aW9ucy5zaWduYWwpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdvYmplY3QvcGF0Y2gvYXBwZW5kLWRhdGEnLCB7XG4gICAgICBzaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBgJHsgY2lkIH1gLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIC4uLmF3YWl0IG11bHRpcGFydFJlcXVlc3QoZGF0YSwgY29udHJvbGxlciwgb3B0aW9ucy5oZWFkZXJzKVxuICAgIH0pO1xuICAgIGNvbnN0IHtIYXNofSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIENJRC5wYXJzZShIYXNoKTtcbiAgfVxuICByZXR1cm4gYXBwZW5kRGF0YTtcbn0pOyIsImltcG9ydCB7IGNyZWF0ZUFkZExpbmsgfSBmcm9tICcuL2FkZC1saW5rLmpzJztcbmltcG9ydCB7IGNyZWF0ZUFwcGVuZERhdGEgfSBmcm9tICcuL2FwcGVuZC1kYXRhLmpzJztcbmltcG9ydCB7IGNyZWF0ZVJtTGluayB9IGZyb20gJy4vcm0tbGluay5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTZXREYXRhIH0gZnJvbSAnLi9zZXQtZGF0YS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGF0Y2goY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgYWRkTGluazogY3JlYXRlQWRkTGluayhjb25maWcpLFxuICAgIGFwcGVuZERhdGE6IGNyZWF0ZUFwcGVuZERhdGEoY29uZmlnKSxcbiAgICBybUxpbms6IGNyZWF0ZVJtTGluayhjb25maWcpLFxuICAgIHNldERhdGE6IGNyZWF0ZVNldERhdGEoY29uZmlnKVxuICB9O1xufSIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uLy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUm1MaW5rID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIHJtTGluayhjaWQsIGRMaW5rLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnb2JqZWN0L3BhdGNoL3JtLWxpbmsnLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFyZzogW1xuICAgICAgICAgIGAkeyBjaWQgfWAsXG4gICAgICAgICAgZExpbmsuTmFtZSB8fCBkTGluay5uYW1lIHx8IG51bGxcbiAgICAgICAgXSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCB7SGFzaH0gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiBDSUQucGFyc2UoSGFzaCk7XG4gIH1cbiAgcmV0dXJuIHJtTGluaztcbn0pOyIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgbXVsdGlwYXJ0UmVxdWVzdCB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9tdWx0aXBhcnQtcmVxdWVzdCc7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi8uLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmltcG9ydCB7IGFib3J0U2lnbmFsIH0gZnJvbSAnLi4vLi4vbGliL2Fib3J0LXNpZ25hbC5qcyc7XG5pbXBvcnQgeyBBYm9ydENvbnRyb2xsZXIgfSBmcm9tICduYXRpdmUtYWJvcnQtY29udHJvbGxlcic7XG5leHBvcnQgY29uc3QgY3JlYXRlU2V0RGF0YSA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBzZXREYXRhKGNpZCwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSBhYm9ydFNpZ25hbChjb250cm9sbGVyLnNpZ25hbCwgb3B0aW9ucy5zaWduYWwpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdvYmplY3QvcGF0Y2gvc2V0LWRhdGEnLCB7XG4gICAgICBzaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBbYCR7IGNpZCB9YF0sXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgLi4uYXdhaXQgbXVsdGlwYXJ0UmVxdWVzdChkYXRhLCBjb250cm9sbGVyLCBvcHRpb25zLmhlYWRlcnMpXG4gICAgfSk7XG4gICAgY29uc3Qge0hhc2h9ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gQ0lELnBhcnNlKEhhc2gpO1xuICB9XG4gIHJldHVybiBzZXREYXRhO1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVQdXQgYXMgY3JlYXRlRGFnUHV0IH0gZnJvbSAnLi4vZGFnL3B1dC5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUHV0ID0gKGNvZGVjcywgb3B0aW9ucykgPT4ge1xuICBjb25zdCBmbiA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICAgIGNvbnN0IGRhZ1B1dCA9IGNyZWF0ZURhZ1B1dChjb2RlY3MsIG9wdGlvbnMpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIHB1dChvYmosIG9wdGlvbnMgPSB7fSkge1xuICAgICAgcmV0dXJuIGRhZ1B1dChvYmosIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgZm9ybWF0OiAnZGFnLXBiJyxcbiAgICAgICAgaGFzaEFsZzogJ3NoYTItMjU2JyxcbiAgICAgICAgdmVyc2lvbjogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwdXQ7XG4gIH0pO1xuICByZXR1cm4gZm4ob3B0aW9ucyk7XG59OyIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlU3RhdCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBzdGF0KGNpZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ29iamVjdC9zdGF0Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGAkeyBjaWQgfWAsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ub3V0cHV0LFxuICAgICAgSGFzaDogQ0lELnBhcnNlKG91dHB1dC5IYXNoKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXQ7XG59KTsiLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXNlSW5wdXQgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvcGlucy9ub3JtYWxpc2UtaW5wdXQnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUFkZEFsbCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiogYWRkQWxsKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCB7cGF0aCwgcmVjdXJzaXZlLCBtZXRhZGF0YX0gb2Ygbm9ybWFsaXNlSW5wdXQoc291cmNlKSkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3Bpbi9hZGQnLCB7XG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgYXJnOiBwYXRoLFxuICAgICAgICAgIHJlY3Vyc2l2ZSxcbiAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEgPyBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgc3RyZWFtOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICAgIH0pO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBwaW4gb2YgcmVzLm5kanNvbigpKSB7XG4gICAgICAgIGlmIChwaW4uUGlucykge1xuICAgICAgICAgIGZvciAoY29uc3QgY2lkIG9mIHBpbi5QaW5zKSB7XG4gICAgICAgICAgICB5aWVsZCBDSUQucGFyc2UoY2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgQ0lELnBhcnNlKHBpbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhZGRBbGw7XG59KTsiLCJpbXBvcnQgeyBjcmVhdGVBZGRBbGwgfSBmcm9tICcuL2FkZC1hbGwuanMnO1xuaW1wb3J0IGxhc3QgZnJvbSAnaXQtbGFzdCc7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBZGQoY29uZmlnKSB7XG4gIGNvbnN0IGFsbCA9IGNyZWF0ZUFkZEFsbChjb25maWcpO1xuICByZXR1cm4gY29uZmlndXJlKCgpID0+IHtcbiAgICBhc3luYyBmdW5jdGlvbiBhZGQocGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICByZXR1cm4gbGFzdChhbGwoW3tcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfV0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZDtcbiAgfSkoY29uZmlnKTtcbn0iLCJpbXBvcnQgeyBjcmVhdGVBZGRBbGwgfSBmcm9tICcuL2FkZC1hbGwuanMnO1xuaW1wb3J0IHsgY3JlYXRlQWRkIH0gZnJvbSAnLi9hZGQuanMnO1xuaW1wb3J0IHsgY3JlYXRlTHMgfSBmcm9tICcuL2xzLmpzJztcbmltcG9ydCB7IGNyZWF0ZVJtQWxsIH0gZnJvbSAnLi9ybS1hbGwuanMnO1xuaW1wb3J0IHsgY3JlYXRlUm0gfSBmcm9tICcuL3JtLmpzJztcbmltcG9ydCB7IGNyZWF0ZVJlbW90ZSB9IGZyb20gJy4vcmVtb3RlL2luZGV4LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQaW4oY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgYWRkQWxsOiBjcmVhdGVBZGRBbGwoY29uZmlnKSxcbiAgICBhZGQ6IGNyZWF0ZUFkZChjb25maWcpLFxuICAgIGxzOiBjcmVhdGVMcyhjb25maWcpLFxuICAgIHJtQWxsOiBjcmVhdGVSbUFsbChjb25maWcpLFxuICAgIHJtOiBjcmVhdGVSbShjb25maWcpLFxuICAgIHJlbW90ZTogY3JlYXRlUmVtb3RlKGNvbmZpZylcbiAgfTtcbn0iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZnVuY3Rpb24gdG9QaW4odHlwZSwgY2lkLCBtZXRhZGF0YSkge1xuICBjb25zdCBwaW4gPSB7XG4gICAgdHlwZSxcbiAgICBjaWQ6IENJRC5wYXJzZShjaWQpXG4gIH07XG4gIGlmIChtZXRhZGF0YSkge1xuICAgIHBpbi5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICB9XG4gIHJldHVybiBwaW47XG59XG5leHBvcnQgY29uc3QgY3JlYXRlTHMgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24qIGxzKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBwYXRocyA9IFtdO1xuICAgIGlmIChvcHRpb25zLnBhdGhzKSB7XG4gICAgICBwYXRocyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRocykgPyBvcHRpb25zLnBhdGhzIDogW29wdGlvbnMucGF0aHNdO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgncGluL2xzJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBhcmc6IHBhdGhzLm1hcChwYXRoID0+IGAkeyBwYXRoIH1gKSxcbiAgICAgICAgc3RyZWFtOiB0cnVlXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGluIG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgaWYgKHBpbi5LZXlzKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2lkIG9mIE9iamVjdC5rZXlzKHBpbi5LZXlzKSkge1xuICAgICAgICAgIHlpZWxkIHRvUGluKHBpbi5LZXlzW2NpZF0uVHlwZSwgY2lkLCBwaW4uS2V5c1tjaWRdLk1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB5aWVsZCB0b1BpbihwaW4uVHlwZSwgcGluLkNpZCwgcGluLk1ldGFkYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxzO1xufSk7IiwiaW1wb3J0IHtcbiAgZW5jb2RlQWRkUGFyYW1zLFxuICBkZWNvZGVQaW5cbn0gZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWRkKGNsaWVudCkge1xuICBhc3luYyBmdW5jdGlvbiBhZGQoY2lkLCB7dGltZW91dCwgc2lnbmFsLCBoZWFkZXJzLCAuLi5xdWVyeX0pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5wb3N0KCdwaW4vcmVtb3RlL2FkZCcsIHtcbiAgICAgIHRpbWVvdXQsXG4gICAgICBzaWduYWwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2VhcmNoUGFyYW1zOiBlbmNvZGVBZGRQYXJhbXMoe1xuICAgICAgICBjaWQsXG4gICAgICAgIC4uLnF1ZXJ5XG4gICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBkZWNvZGVQaW4oYXdhaXQgcmVzcG9uc2UuanNvbigpKTtcbiAgfVxuICByZXR1cm4gYWRkO1xufSIsImltcG9ydCB7IENsaWVudCB9IGZyb20gJy4uLy4uL2xpYi9jb3JlLmpzJztcbmltcG9ydCB7IGNyZWF0ZUFkZCB9IGZyb20gJy4vYWRkLmpzJztcbmltcG9ydCB7IGNyZWF0ZUxzIH0gZnJvbSAnLi9scy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVSbSB9IGZyb20gJy4vcm0uanMnO1xuaW1wb3J0IHsgY3JlYXRlUm1BbGwgfSBmcm9tICcuL3JtLWFsbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlL2luZGV4LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZW1vdGUoY29uZmlnKSB7XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoY29uZmlnKTtcbiAgcmV0dXJuIHtcbiAgICBhZGQ6IGNyZWF0ZUFkZChjbGllbnQpLFxuICAgIGxzOiBjcmVhdGVMcyhjbGllbnQpLFxuICAgIHJtOiBjcmVhdGVSbShjbGllbnQpLFxuICAgIHJtQWxsOiBjcmVhdGVSbUFsbChjbGllbnQpLFxuICAgIHNlcnZpY2U6IGNyZWF0ZVNlcnZpY2UoY29uZmlnKVxuICB9O1xufSIsImltcG9ydCB7XG4gIGVuY29kZVF1ZXJ5LFxuICBkZWNvZGVQaW5cbn0gZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTHMoY2xpZW50KSB7XG4gIGFzeW5jIGZ1bmN0aW9uKiBscyh7dGltZW91dCwgc2lnbmFsLCBoZWFkZXJzLCAuLi5xdWVyeX0pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5wb3N0KCdwaW4vcmVtb3RlL2xzJywge1xuICAgICAgdGltZW91dCxcbiAgICAgIHNpZ25hbCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZWFyY2hQYXJhbXM6IGVuY29kZVF1ZXJ5KHF1ZXJ5KVxuICAgIH0pO1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGluIG9mIHJlc3BvbnNlLm5kanNvbigpKSB7XG4gICAgICB5aWVsZCBkZWNvZGVQaW4ocGluKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxzO1xufSIsImltcG9ydCB7IGVuY29kZVF1ZXJ5IH0gZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm1BbGwoY2xpZW50KSB7XG4gIGFzeW5jIGZ1bmN0aW9uIHJtQWxsKHt0aW1lb3V0LCBzaWduYWwsIGhlYWRlcnMsIC4uLnF1ZXJ5fSkge1xuICAgIGF3YWl0IGNsaWVudC5wb3N0KCdwaW4vcmVtb3RlL3JtJywge1xuICAgICAgdGltZW91dCxcbiAgICAgIHNpZ25hbCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZWFyY2hQYXJhbXM6IGVuY29kZVF1ZXJ5KHtcbiAgICAgICAgLi4ucXVlcnksXG4gICAgICAgIGFsbDogdHJ1ZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcm1BbGw7XG59IiwiaW1wb3J0IHsgZW5jb2RlUXVlcnkgfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSbShjbGllbnQpIHtcbiAgYXN5bmMgZnVuY3Rpb24gcm0oe3RpbWVvdXQsIHNpZ25hbCwgaGVhZGVycywgLi4ucXVlcnl9KSB7XG4gICAgYXdhaXQgY2xpZW50LnBvc3QoJ3Bpbi9yZW1vdGUvcm0nLCB7XG4gICAgICB0aW1lb3V0LFxuICAgICAgc2lnbmFsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNlYXJjaFBhcmFtczogZW5jb2RlUXVlcnkoe1xuICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgYWxsOiBmYWxzZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcm07XG59IiwiaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuaW1wb3J0IHsgZW5jb2RlRW5kcG9pbnQgfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBZGQoY2xpZW50KSB7XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZChuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2VuZHBvaW50LCBrZXksIGhlYWRlcnMsIHRpbWVvdXQsIHNpZ25hbH0gPSBvcHRpb25zO1xuICAgIGF3YWl0IGNsaWVudC5wb3N0KCdwaW4vcmVtb3RlL3NlcnZpY2UvYWRkJywge1xuICAgICAgdGltZW91dCxcbiAgICAgIHNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IFtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGVuY29kZUVuZHBvaW50KGVuZHBvaW50KSxcbiAgICAgICAgICBrZXlcbiAgICAgICAgXVxuICAgICAgfSksXG4gICAgICBoZWFkZXJzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFkZDtcbn0iLCJpbXBvcnQgeyBDbGllbnQgfSBmcm9tICcuLi8uLi8uLi9saWIvY29yZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVBZGQgfSBmcm9tICcuL2FkZC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVMcyB9IGZyb20gJy4vbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlUm0gfSBmcm9tICcuL3JtLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZXJ2aWNlKGNvbmZpZykge1xuICBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KGNvbmZpZyk7XG4gIHJldHVybiB7XG4gICAgYWRkOiBjcmVhdGVBZGQoY2xpZW50KSxcbiAgICBsczogY3JlYXRlTHMoY2xpZW50KSxcbiAgICBybTogY3JlYXRlUm0oY2xpZW50KVxuICB9O1xufSIsImltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmltcG9ydCB7IGRlY29kZVJlbW90ZVNlcnZpY2UgfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMcyhjbGllbnQpIHtcbiAgYXN5bmMgZnVuY3Rpb24gbHMob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge3N0YXQsIGhlYWRlcnMsIHRpbWVvdXQsIHNpZ25hbH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnBvc3QoJ3Bpbi9yZW1vdGUvc2VydmljZS9scycsIHtcbiAgICAgIHRpbWVvdXQsXG4gICAgICBzaWduYWwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2VhcmNoUGFyYW1zOiBzdGF0ID09PSB0cnVlID8gdG9VcmxTZWFyY2hQYXJhbXMoeyBzdGF0IH0pIDogdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgY29uc3Qge1JlbW90ZVNlcnZpY2VzfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gUmVtb3RlU2VydmljZXMubWFwKGRlY29kZVJlbW90ZVNlcnZpY2UpO1xuICB9XG4gIHJldHVybiBscztcbn0iLCJpbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm0oY2xpZW50KSB7XG4gIGFzeW5jIGZ1bmN0aW9uIHJtKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGF3YWl0IGNsaWVudC5wb3N0KCdwaW4vcmVtb3RlL3NlcnZpY2Uvcm0nLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7IGFyZzogbmFtZSB9KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBybTtcbn0iLCJleHBvcnQgZnVuY3Rpb24gZW5jb2RlRW5kcG9pbnQodXJsKSB7XG4gIGNvbnN0IGhyZWYgPSBTdHJpbmcodXJsKTtcbiAgaWYgKGhyZWYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2VuZHBvaW50IGlzIHJlcXVpcmVkJyk7XG4gIH1cbiAgcmV0dXJuIGhyZWZbaHJlZi5sZW5ndGggLSAxXSA9PT0gJy8nID8gaHJlZi5zbGljZSgwLCAtMSkgOiBocmVmO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVJlbW90ZVNlcnZpY2UoanNvbikge1xuICByZXR1cm4ge1xuICAgIHNlcnZpY2U6IGpzb24uU2VydmljZSxcbiAgICBlbmRwb2ludDogbmV3IFVSTChqc29uLkFwaUVuZHBvaW50KSxcbiAgICAuLi5qc29uLlN0YXQgJiYgeyBzdGF0OiBkZWNvZGVTdGF0KGpzb24uU3RhdCkgfVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVN0YXQoanNvbikge1xuICBzd2l0Y2ggKGpzb24uU3RhdHVzKSB7XG4gIGNhc2UgJ3ZhbGlkJzoge1xuICAgICAgY29uc3Qge1Bpbm5pbmcsIFBpbm5lZCwgUXVldWVkLCBGYWlsZWR9ID0ganNvbi5QaW5Db3VudDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ3ZhbGlkJyxcbiAgICAgICAgcGluQ291bnQ6IHtcbiAgICAgICAgICBxdWV1ZWQ6IFF1ZXVlZCxcbiAgICAgICAgICBwaW5uaW5nOiBQaW5uaW5nLFxuICAgICAgICAgIHBpbm5lZDogUGlubmVkLFxuICAgICAgICAgIGZhaWxlZDogRmFpbGVkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICBjYXNlICdpbnZhbGlkJzoge1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnaW52YWxpZCcgfTtcbiAgICB9XG4gIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiB7IHN0YXR1czoganNvbi5TdGF0dXMgfTtcbiAgICB9XG4gIH1cbn0iLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBkZWNvZGVQaW4gPSAoe1xuICBOYW1lOiBuYW1lLFxuICBTdGF0dXM6IHN0YXR1cyxcbiAgQ2lkOiBjaWRcbn0pID0+IHtcbiAgcmV0dXJuIHtcbiAgICBjaWQ6IENJRC5wYXJzZShjaWQpLFxuICAgIG5hbWUsXG4gICAgc3RhdHVzXG4gIH07XG59O1xuZXhwb3J0IGNvbnN0IGVuY29kZVNlcnZpY2UgPSBzZXJ2aWNlID0+IHtcbiAgaWYgKHR5cGVvZiBzZXJ2aWNlID09PSAnc3RyaW5nJyAmJiBzZXJ2aWNlICE9PSAnJykge1xuICAgIHJldHVybiBzZXJ2aWNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NlcnZpY2UgbmFtZSBtdXN0IGJlIHBhc3NlZCcpO1xuICB9XG59O1xuZXhwb3J0IGNvbnN0IGVuY29kZUNJRCA9IGNpZCA9PiB7XG4gIGlmIChDSUQuYXNDSUQoY2lkKSkge1xuICAgIHJldHVybiBjaWQudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDSUQgaW5zdGFuY2UgZXhwZWN0ZWQgaW5zdGVhZCBvZiAkeyB0eXBlb2YgY2lkIH1gKTtcbiAgfVxufTtcbmV4cG9ydCBjb25zdCBlbmNvZGVRdWVyeSA9ICh7c2VydmljZSwgY2lkLCBuYW1lLCBzdGF0dXMsIGFsbH0pID0+IHtcbiAgY29uc3QgcXVlcnkgPSB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgc2VydmljZTogZW5jb2RlU2VydmljZShzZXJ2aWNlKSxcbiAgICBuYW1lLFxuICAgIGZvcmNlOiBhbGwgPyB0cnVlIDogdW5kZWZpbmVkXG4gIH0pO1xuICBpZiAoY2lkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBjaWQpIHtcbiAgICAgIHF1ZXJ5LmFwcGVuZCgnY2lkJywgZW5jb2RlQ0lEKHZhbHVlKSk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0dXMpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHN0YXR1cykge1xuICAgICAgcXVlcnkuYXBwZW5kKCdzdGF0dXMnLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBxdWVyeTtcbn07XG5leHBvcnQgY29uc3QgZW5jb2RlQWRkUGFyYW1zID0gKHtjaWQsIHNlcnZpY2UsIGJhY2tncm91bmQsIG5hbWUsIG9yaWdpbnN9KSA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICBhcmc6IGVuY29kZUNJRChjaWQpLFxuICAgIHNlcnZpY2U6IGVuY29kZVNlcnZpY2Uoc2VydmljZSksXG4gICAgbmFtZSxcbiAgICBiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kID8gdHJ1ZSA6IHVuZGVmaW5lZFxuICB9KTtcbiAgaWYgKG9yaWdpbnMpIHtcbiAgICBmb3IgKGNvbnN0IG9yaWdpbiBvZiBvcmlnaW5zKSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKCdvcmlnaW4nLCBvcmlnaW4udG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbXM7XG59OyIsImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyBub3JtYWxpc2VJbnB1dCB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9waW5zL25vcm1hbGlzZS1pbnB1dCc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUm1BbGwgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24qIHJtQWxsKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCB7cGF0aCwgcmVjdXJzaXZlfSBvZiBub3JtYWxpc2VJbnB1dChzb3VyY2UpKSB7XG4gICAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnMuc2VhcmNoUGFyYW1zKTtcbiAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoJ2FyZycsIGAkeyBwYXRoIH1gKTtcbiAgICAgIGlmIChyZWN1cnNpdmUgIT0gbnVsbClcbiAgICAgICAgc2VhcmNoUGFyYW1zLnNldCgncmVjdXJzaXZlJywgU3RyaW5nKHJlY3Vyc2l2ZSkpO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3Bpbi9ybScsIHtcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIGFyZzogYCR7IHBhdGggfWAsXG4gICAgICAgICAgcmVjdXJzaXZlXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgcGluIG9mIHJlcy5uZGpzb24oKSkge1xuICAgICAgICBpZiAocGluLlBpbnMpIHtcbiAgICAgICAgICB5aWVsZCogcGluLlBpbnMubWFwKGNpZCA9PiBDSUQucGFyc2UoY2lkKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgQ0lELnBhcnNlKHBpbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBybUFsbDtcbn0pOyIsImltcG9ydCB7IGNyZWF0ZVJtQWxsIH0gZnJvbSAnLi9ybS1hbGwuanMnO1xuaW1wb3J0IGxhc3QgZnJvbSAnaXQtbGFzdCc7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVSbSA9IGNvbmZpZyA9PiB7XG4gIGNvbnN0IGFsbCA9IGNyZWF0ZVJtQWxsKGNvbmZpZyk7XG4gIHJldHVybiBjb25maWd1cmUoKCkgPT4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIHJtKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgcmV0dXJuIGxhc3QoYWxsKFt7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH1dLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBybTtcbiAgfSkoY29uZmlnKTtcbn07IiwiaW1wb3J0IHsgb2JqZWN0VG9DYW1lbCB9IGZyb20gJy4vbGliL29iamVjdC10by1jYW1lbC5qcyc7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlUGluZyA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiogcGluZyhwZWVySWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdwaW5nJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGAkeyBwZWVySWQgfWAsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgdHJhbnNmb3JtOiBvYmplY3RUb0NhbWVsXG4gICAgfSk7XG4gICAgeWllbGQqIHJlcy5uZGpzb24oKTtcbiAgfVxuICByZXR1cm4gcGluZztcbn0pOyIsImltcG9ydCB7IGNyZWF0ZUxzIH0gZnJvbSAnLi9scy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVQZWVycyB9IGZyb20gJy4vcGVlcnMuanMnO1xuaW1wb3J0IHsgY3JlYXRlUHVibGlzaCB9IGZyb20gJy4vcHVibGlzaC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdWJzY3JpYmUgfSBmcm9tICcuL3N1YnNjcmliZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVVbnN1YnNjcmliZSB9IGZyb20gJy4vdW5zdWJzY3JpYmUuanMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uVHJhY2tlciB9IGZyb20gJy4vc3Vic2NyaXB0aW9uLXRyYWNrZXIuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVB1YnN1Yihjb25maWcpIHtcbiAgY29uc3Qgc3Vic2NyaXB0aW9uVHJhY2tlciA9IG5ldyBTdWJzY3JpcHRpb25UcmFja2VyKCk7XG4gIHJldHVybiB7XG4gICAgbHM6IGNyZWF0ZUxzKGNvbmZpZyksXG4gICAgcGVlcnM6IGNyZWF0ZVBlZXJzKGNvbmZpZyksXG4gICAgcHVibGlzaDogY3JlYXRlUHVibGlzaChjb25maWcpLFxuICAgIHN1YnNjcmliZTogY3JlYXRlU3Vic2NyaWJlKGNvbmZpZywgc3Vic2NyaXB0aW9uVHJhY2tlciksXG4gICAgdW5zdWJzY3JpYmU6IGNyZWF0ZVVuc3Vic2NyaWJlKGNvbmZpZywgc3Vic2NyaXB0aW9uVHJhY2tlcilcbiAgfTtcbn0iLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVMcyA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBscyhvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7U3RyaW5nc30gPSBhd2FpdCAoYXdhaXQgYXBpLnBvc3QoJ3B1YnN1Yi9scycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSkpLmpzb24oKTtcbiAgICByZXR1cm4gU3RyaW5ncyB8fCBbXTtcbiAgfVxuICByZXR1cm4gbHM7XG59KTsiLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVQZWVycyA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBwZWVycyh0b3BpYywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3B1YnN1Yi9wZWVycycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiB0b3BpYyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCB7U3RyaW5nc30gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiBTdHJpbmdzIHx8IFtdO1xuICB9XG4gIHJldHVybiBwZWVycztcbn0pOyIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuaW1wb3J0IHsgbXVsdGlwYXJ0UmVxdWVzdCB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9tdWx0aXBhcnQtcmVxdWVzdCc7XG5pbXBvcnQgeyBhYm9ydFNpZ25hbCB9IGZyb20gJy4uL2xpYi9hYm9ydC1zaWduYWwuanMnO1xuaW1wb3J0IHsgQWJvcnRDb250cm9sbGVyIH0gZnJvbSAnbmF0aXZlLWFib3J0LWNvbnRyb2xsZXInO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVB1Ymxpc2ggPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gcHVibGlzaCh0b3BpYywgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgYXJnOiB0b3BpYyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0U2lnbmFsKGNvbnRyb2xsZXIuc2lnbmFsLCBvcHRpb25zLnNpZ25hbCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3B1YnN1Yi9wdWInLCB7XG4gICAgICBzaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXMsXG4gICAgICAuLi5hd2FpdCBtdWx0aXBhcnRSZXF1ZXN0KGRhdGEsIGNvbnRyb2xsZXIsIG9wdGlvbnMuaGVhZGVycylcbiAgICB9KTtcbiAgICBhd2FpdCByZXMudGV4dCgpO1xuICB9XG4gIHJldHVybiBwdWJsaXNoO1xufSk7IiwiaW1wb3J0IHsgZnJvbVN0cmluZyBhcyB1aW50OEFycmF5RnJvbVN0cmluZyB9IGZyb20gJ3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nJztcbmltcG9ydCB7IHRvU3RyaW5nIGFzIHVpbnQ4QXJyYXlUb1N0cmluZyB9IGZyb20gJ3VpbnQ4YXJyYXlzL3RvLXN0cmluZyc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5jb25zdCBsb2cgPSBkZWJ1ZygnaXBmcy1odHRwLWNsaWVudDpwdWJzdWI6c3Vic2NyaWJlJyk7XG5leHBvcnQgY29uc3QgY3JlYXRlU3Vic2NyaWJlID0gKG9wdGlvbnMsIHN1YnNUcmFja2VyKSA9PiB7XG4gIHJldHVybiBjb25maWd1cmUoYXBpID0+IHtcbiAgICBhc3luYyBmdW5jdGlvbiBzdWJzY3JpYmUodG9waWMsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgb3B0aW9ucy5zaWduYWwgPSBzdWJzVHJhY2tlci5zdWJzY3JpYmUodG9waWMsIGhhbmRsZXIsIG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgIGxldCBkb25lO1xuICAgICAgbGV0IGZhaWw7XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGRvbmUgPSByZXNvbHZlO1xuICAgICAgICBmYWlsID0gcmVqZWN0O1xuICAgICAgfSk7XG4gICAgICBjb25zdCBmZldvcmthcm91bmQgPSBzZXRUaW1lb3V0KCgpID0+IGRvbmUoKSwgMTAwMCk7XG4gICAgICBhcGkucG9zdCgncHVic3ViL3N1YicsIHtcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgYXJnOiB0b3BpYyxcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHN1YnNUcmFja2VyLnVuc3Vic2NyaWJlKHRvcGljLCBoYW5kbGVyKTtcbiAgICAgICAgZmFpbChlcnIpO1xuICAgICAgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChmZldvcmthcm91bmQpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlYWRNZXNzYWdlcyhyZXNwb25zZSwge1xuICAgICAgICAgIG9uTWVzc2FnZTogaGFuZGxlcixcbiAgICAgICAgICBvbkVuZDogKCkgPT4gc3Vic1RyYWNrZXIudW5zdWJzY3JpYmUodG9waWMsIGhhbmRsZXIpLFxuICAgICAgICAgIG9uRXJyb3I6IG9wdGlvbnMub25FcnJvclxuICAgICAgICB9KTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gc3Vic2NyaWJlO1xuICB9KShvcHRpb25zKTtcbn07XG5hc3luYyBmdW5jdGlvbiByZWFkTWVzc2FnZXMocmVzcG9uc2UsIHtvbk1lc3NhZ2UsIG9uRW5kLCBvbkVycm9yfSkge1xuICBvbkVycm9yID0gb25FcnJvciB8fCBsb2c7XG4gIHRyeSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBtc2cgb2YgcmVzcG9uc2UubmRqc29uKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbXNnLmZyb20pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvbk1lc3NhZ2Uoe1xuICAgICAgICAgIGZyb206IHVpbnQ4QXJyYXlUb1N0cmluZyh1aW50OEFycmF5RnJvbVN0cmluZyhtc2cuZnJvbSwgJ2Jhc2U2NHBhZCcpLCAnYmFzZTU4YnRjJyksXG4gICAgICAgICAgZGF0YTogdWludDhBcnJheUZyb21TdHJpbmcobXNnLmRhdGEsICdiYXNlNjRwYWQnKSxcbiAgICAgICAgICBzZXFubzogdWludDhBcnJheUZyb21TdHJpbmcobXNnLnNlcW5vLCAnYmFzZTY0cGFkJyksXG4gICAgICAgICAgdG9waWNJRHM6IG1zZy50b3BpY0lEc1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnIubWVzc2FnZSA9IGBGYWlsZWQgdG8gcGFyc2UgcHVic3ViIG1lc3NhZ2U6ICR7IGVyci5tZXNzYWdlIH1gO1xuICAgICAgICBvbkVycm9yKGVyciwgZmFsc2UsIG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoIWlzQWJvcnRFcnJvcihlcnIpKSB7XG4gICAgICBvbkVycm9yKGVyciwgdHJ1ZSk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIG9uRW5kKCk7XG4gIH1cbn1cbmNvbnN0IGlzQWJvcnRFcnJvciA9IGVycm9yID0+IHtcbiAgc3dpdGNoIChlcnJvci50eXBlKSB7XG4gIGNhc2UgJ2Fib3J0ZWQnOlxuICAgIHJldHVybiB0cnVlO1xuICBjYXNlICdhYm9ydCc6XG4gICAgcmV0dXJuIHRydWU7XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJztcbiAgfVxufTsiLCJpbXBvcnQgeyBBYm9ydENvbnRyb2xsZXIgfSBmcm9tICduYXRpdmUtYWJvcnQtY29udHJvbGxlcic7XG5leHBvcnQgY2xhc3MgU3Vic2NyaXB0aW9uVHJhY2tlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3N1YnMgPSBuZXcgTWFwKCk7XG4gIH1cbiAgc3Vic2NyaWJlKHRvcGljLCBoYW5kbGVyLCBzaWduYWwpIHtcbiAgICBjb25zdCB0b3BpY1N1YnMgPSB0aGlzLl9zdWJzLmdldCh0b3BpYykgfHwgW107XG4gICAgaWYgKHRvcGljU3Vicy5maW5kKHMgPT4gcy5oYW5kbGVyID09PSBoYW5kbGVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbHJlYWR5IHN1YnNjcmliZWQgdG8gJHsgdG9waWMgfSB3aXRoIHRoaXMgaGFuZGxlcmApO1xuICAgIH1cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuX3N1YnMuc2V0KHRvcGljLCBbe1xuICAgICAgICBoYW5kbGVyLFxuICAgICAgICBjb250cm9sbGVyXG4gICAgICB9XS5jb25jYXQodG9waWNTdWJzKSk7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpcy51bnN1YnNjcmliZSh0b3BpYywgaGFuZGxlcikpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG4gIH1cbiAgdW5zdWJzY3JpYmUodG9waWMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBzdWJzID0gdGhpcy5fc3Vicy5nZXQodG9waWMpIHx8IFtdO1xuICAgIGxldCB1bnN1YnM7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX3N1YnMuc2V0KHRvcGljLCBzdWJzLmZpbHRlcihzID0+IHMuaGFuZGxlciAhPT0gaGFuZGxlcikpO1xuICAgICAgdW5zdWJzID0gc3Vicy5maWx0ZXIocyA9PiBzLmhhbmRsZXIgPT09IGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdWJzLnNldCh0b3BpYywgW10pO1xuICAgICAgdW5zdWJzID0gc3VicztcbiAgICB9XG4gICAgaWYgKCEodGhpcy5fc3Vicy5nZXQodG9waWMpIHx8IFtdKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N1YnMuZGVsZXRlKHRvcGljKTtcbiAgICB9XG4gICAgdW5zdWJzLmZvckVhY2gocyA9PiBzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gIH1cbn0iLCJleHBvcnQgY29uc3QgY3JlYXRlVW5zdWJzY3JpYmUgPSAob3B0aW9ucywgc3Vic1RyYWNrZXIpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gdW5zdWJzY3JpYmUodG9waWMsIGhhbmRsZXIpIHtcbiAgICBzdWJzVHJhY2tlci51bnN1YnNjcmliZSh0b3BpYywgaGFuZGxlcik7XG4gIH1cbiAgcmV0dXJuIHVuc3Vic2NyaWJlO1xufTsiLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IG9iamVjdFRvQ2FtZWwgfSBmcm9tICcuLi9saWIvb2JqZWN0LXRvLWNhbWVsLmpzJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYWwgfSBmcm9tICcuL2xvY2FsLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVSZWZzID0gY29uZmlndXJlKChhcGksIG9wdHMpID0+IHtcbiAgY29uc3QgcmVmcyA9IGFzeW5jIGZ1bmN0aW9uKiAoYXJncywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYXJnc0FyciA9IEFycmF5LmlzQXJyYXkoYXJncykgPyBhcmdzIDogW2FyZ3NdO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdyZWZzJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGFyZ3NBcnIubWFwKGFyZyA9PiBgJHsgYXJnIGluc3RhbmNlb2YgVWludDhBcnJheSA/IENJRC5kZWNvZGUoYXJnKSA6IGFyZyB9YCksXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgdHJhbnNmb3JtOiBvYmplY3RUb0NhbWVsXG4gICAgfSk7XG4gICAgeWllbGQqIHJlcy5uZGpzb24oKTtcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocmVmcywgeyBsb2NhbDogY3JlYXRlTG9jYWwob3B0cykgfSk7XG59KTsiLCJpbXBvcnQgeyBvYmplY3RUb0NhbWVsIH0gZnJvbSAnLi4vbGliL29iamVjdC10by1jYW1lbC5qcyc7XG5pbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVMb2NhbCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiogcmVmc0xvY2FsKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdyZWZzL2xvY2FsJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHRyYW5zZm9ybTogb2JqZWN0VG9DYW1lbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICB5aWVsZCogcmVzLm5kanNvbigpO1xuICB9XG4gIHJldHVybiByZWZzTG9jYWw7XG59KTsiLCJpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUdjID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uKiBnYyhvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgncmVwby9nYycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgdHJhbnNmb3JtOiByZXMgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVycjogcmVzLkVycm9yID8gbmV3IEVycm9yKHJlcy5FcnJvcikgOiBudWxsLFxuICAgICAgICAgIGNpZDogKHJlcy5LZXkgfHwge30pWycvJ10gPyBDSUQucGFyc2UocmVzLktleVsnLyddKSA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB5aWVsZCogcmVzLm5kanNvbigpO1xuICB9XG4gIHJldHVybiBnYztcbn0pOyIsImltcG9ydCB7IGNyZWF0ZUdjIH0gZnJvbSAnLi9nYy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdGF0IH0gZnJvbSAnLi9zdGF0LmpzJztcbmltcG9ydCB7IGNyZWF0ZVZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlcG8oY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgZ2M6IGNyZWF0ZUdjKGNvbmZpZyksXG4gICAgc3RhdDogY3JlYXRlU3RhdChjb25maWcpLFxuICAgIHZlcnNpb246IGNyZWF0ZVZlcnNpb24oY29uZmlnKVxuICB9O1xufSIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0YXQgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gc3RhdChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgncmVwby9zdGF0Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtT2JqZWN0czogQmlnSW50KGRhdGEuTnVtT2JqZWN0cyksXG4gICAgICByZXBvU2l6ZTogQmlnSW50KGRhdGEuUmVwb1NpemUpLFxuICAgICAgcmVwb1BhdGg6IGRhdGEuUmVwb1BhdGgsXG4gICAgICB2ZXJzaW9uOiBkYXRhLlZlcnNpb24sXG4gICAgICBzdG9yYWdlTWF4OiBCaWdJbnQoZGF0YS5TdG9yYWdlTWF4KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXQ7XG59KTsiLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vbGliL3RvLXVybC1zZWFyY2gtcGFyYW1zLmpzJztcbmV4cG9ydCBjb25zdCBjcmVhdGVWZXJzaW9uID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIHZlcnNpb24ob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgKGF3YWl0IGFwaS5wb3N0KCdyZXBvL3ZlcnNpb24nLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pKS5qc29uKCk7XG4gICAgcmV0dXJuIHJlcy5WZXJzaW9uO1xuICB9XG4gIHJldHVybiB2ZXJzaW9uO1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlc29sdmUgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZShwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgncmVzb2x2ZScsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBwYXRoLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHtQYXRofSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIFBhdGg7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmU7XG59KTsiLCJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICcuL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0YXJ0ID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGNvbnN0IHN0YXJ0ID0gYXN5bmMgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKSwgJ0VSUl9OT1RfSU1QTEVNRU5URUQnKTtcbiAgfTtcbiAgcmV0dXJuIHN0YXJ0O1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlQncgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24qIGJ3KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdzdGF0cy9idycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgdHJhbnNmb3JtOiBzdGF0cyA9PiAoe1xuICAgICAgICB0b3RhbEluOiBCaWdJbnQoc3RhdHMuVG90YWxJbiksXG4gICAgICAgIHRvdGFsT3V0OiBCaWdJbnQoc3RhdHMuVG90YWxPdXQpLFxuICAgICAgICByYXRlSW46IHBhcnNlRmxvYXQoc3RhdHMuUmF0ZUluKSxcbiAgICAgICAgcmF0ZU91dDogcGFyc2VGbG9hdChzdGF0cy5SYXRlT3V0KVxuICAgICAgfSlcbiAgICB9KTtcbiAgICB5aWVsZCogcmVzLm5kanNvbigpO1xuICB9XG4gIHJldHVybiBidztcbn0pOyIsImltcG9ydCB7IGNyZWF0ZVN0YXQgYXMgY3JlYXRlQml0c3dhcCB9IGZyb20gJy4uL2JpdHN3YXAvc3RhdC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdGF0IGFzIGNyZWF0ZVJlcG8gfSBmcm9tICcuLi9yZXBvL3N0YXQuanMnO1xuaW1wb3J0IHsgY3JlYXRlQncgfSBmcm9tICcuL2J3LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGF0cyhjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBiaXRzd2FwOiBjcmVhdGVCaXRzd2FwKGNvbmZpZyksXG4gICAgcmVwbzogY3JlYXRlUmVwbyhjb25maWcpLFxuICAgIGJ3OiBjcmVhdGVCdyhjb25maWcpXG4gIH07XG59IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0b3AgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gc3RvcChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnc2h1dGRvd24nLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0b1VybFNlYXJjaFBhcmFtcyhvcHRpb25zKSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGF3YWl0IHJlcy50ZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHN0b3A7XG59KTsiLCJpbXBvcnQgeyBNdWx0aWFkZHIgfSBmcm9tICdtdWx0aWFkZHInO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlQWRkcnMgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gYWRkcnMob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLnBvc3QoJ3N3YXJtL2FkZHJzJywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMob3B0aW9ucyksXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCB7QWRkcnN9ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoQWRkcnMpLm1hcChpZCA9PiAoe1xuICAgICAgaWQsXG4gICAgICBhZGRyczogKEFkZHJzW2lkXSB8fCBbXSkubWFwKGEgPT4gbmV3IE11bHRpYWRkcihhKSlcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIGFkZHJzO1xufSk7IiwiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlQ29ubmVjdCA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBjb25uZWN0KGFkZHIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdzd2FybS9jb25uZWN0Jywge1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgIHNlYXJjaFBhcmFtczogdG9VcmxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhcmc6IGFkZHIsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3Qge1N0cmluZ3N9ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gU3RyaW5ncyB8fCBbXTtcbiAgfVxuICByZXR1cm4gY29ubmVjdDtcbn0pOyIsImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURpc2Nvbm5lY3QgPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gZGlzY29ubmVjdChhZGRyLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgnc3dhcm0vZGlzY29ubmVjdCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYXJnOiBhZGRyLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHtTdHJpbmdzfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIFN0cmluZ3MgfHwgW107XG4gIH1cbiAgcmV0dXJuIGRpc2Nvbm5lY3Q7XG59KTsiLCJpbXBvcnQgeyBjcmVhdGVBZGRycyB9IGZyb20gJy4vYWRkcnMuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ29ubmVjdCB9IGZyb20gJy4vY29ubmVjdC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVEaXNjb25uZWN0IH0gZnJvbSAnLi9kaXNjb25uZWN0LmpzJztcbmltcG9ydCB7IGNyZWF0ZUxvY2FsQWRkcnMgfSBmcm9tICcuL2xvY2FsLWFkZHJzLmpzJztcbmltcG9ydCB7IGNyZWF0ZVBlZXJzIH0gZnJvbSAnLi9wZWVycy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3dhcm0oY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgYWRkcnM6IGNyZWF0ZUFkZHJzKGNvbmZpZyksXG4gICAgY29ubmVjdDogY3JlYXRlQ29ubmVjdChjb25maWcpLFxuICAgIGRpc2Nvbm5lY3Q6IGNyZWF0ZURpc2Nvbm5lY3QoY29uZmlnKSxcbiAgICBsb2NhbEFkZHJzOiBjcmVhdGVMb2NhbEFkZHJzKGNvbmZpZyksXG4gICAgcGVlcnM6IGNyZWF0ZVBlZXJzKGNvbmZpZylcbiAgfTtcbn0iLCJpbXBvcnQgeyBNdWx0aWFkZHIgfSBmcm9tICdtdWx0aWFkZHInO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi4vbGliL2NvbmZpZ3VyZS5qcyc7XG5pbXBvcnQgeyB0b1VybFNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2xpYi90by11cmwtc2VhcmNoLXBhcmFtcy5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlTG9jYWxBZGRycyA9IGNvbmZpZ3VyZShhcGkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBsb2NhbEFkZHJzKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdzd2FybS9hZGRycy9sb2NhbCcsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3Qge1N0cmluZ3N9ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gKFN0cmluZ3MgfHwgW10pLm1hcChhID0+IG5ldyBNdWx0aWFkZHIoYSkpO1xuICB9XG4gIHJldHVybiBsb2NhbEFkZHJzO1xufSk7IiwiaW1wb3J0IHsgTXVsdGlhZGRyIH0gZnJvbSAnbXVsdGlhZGRyJztcbmltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJy4uL2xpYi9jb25maWd1cmUuanMnO1xuaW1wb3J0IHsgdG9VcmxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVBlZXJzID0gY29uZmlndXJlKGFwaSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIHBlZXJzKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCdzd2FybS9wZWVycycsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3Qge1BlZXJzfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIChQZWVycyB8fCBbXSkubWFwKHBlZXIgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcjogbmV3IE11bHRpYWRkcihwZWVyLkFkZHIpLFxuICAgICAgICBwZWVyOiBwZWVyLlBlZXIsXG4gICAgICAgIG11eGVyOiBwZWVyLk11eGVyLFxuICAgICAgICBsYXRlbmN5OiBwZWVyLkxhdGVuY3ksXG4gICAgICAgIHN0cmVhbXM6IHBlZXIuU3RyZWFtcyxcbiAgICAgICAgZGlyZWN0aW9uOiBwZWVyLkRpcmVjdGlvbiA9PSBudWxsID8gdW5kZWZpbmVkIDogcGVlci5EaXJlY3Rpb24gPT09IDAgPyAnaW5ib3VuZCcgOiAnb3V0Ym91bmQnXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBwZWVycztcbn0pOyIsImltcG9ydCB7IG9iamVjdFRvQ2FtZWwgfSBmcm9tICcuL2xpYi9vYmplY3QtdG8tY2FtZWwuanMnO1xuaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnLi9saWIvY29uZmlndXJlLmpzJztcbmltcG9ydCB7IHRvVXJsU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi9saWIvdG8tdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZlcnNpb24gPSBjb25maWd1cmUoYXBpID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gdmVyc2lvbihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkucG9zdCgndmVyc2lvbicsIHtcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICBzZWFyY2hQYXJhbXM6IHRvVXJsU2VhcmNoUGFyYW1zKG9wdGlvbnMpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm9iamVjdFRvQ2FtZWwoYXdhaXQgcmVzLmpzb24oKSksXG4gICAgICAnaXBmcy1odHRwLWNsaWVudCc6ICcxLjAuMCdcbiAgICB9O1xuICB9XG4gIHJldHVybiB2ZXJzaW9uO1xufSk7IiwiaW1wb3J0IGVycmNvZGUgZnJvbSAnZXJyLWNvZGUnO1xuaW1wb3J0ICogYXMgUGIgZnJvbSAnLi91bml4ZnMuanMnO1xuY29uc3QgUEJEYXRhID0gUGIuRGF0YTtcbmNvbnN0IHR5cGVzID0gW1xuICAncmF3JyxcbiAgJ2RpcmVjdG9yeScsXG4gICdmaWxlJyxcbiAgJ21ldGFkYXRhJyxcbiAgJ3N5bWxpbmsnLFxuICAnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeSdcbl07XG5jb25zdCBkaXJUeXBlcyA9IFtcbiAgJ2RpcmVjdG9yeScsXG4gICdoYW10LXNoYXJkZWQtZGlyZWN0b3J5J1xuXTtcbmNvbnN0IERFRkFVTFRfRklMRV9NT0RFID0gcGFyc2VJbnQoJzA2NDQnLCA4KTtcbmNvbnN0IERFRkFVTFRfRElSRUNUT1JZX01PREUgPSBwYXJzZUludCgnMDc1NScsIDgpO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTW9kZShtb2RlKSB7XG4gIGlmIChtb2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbW9kZSAmIDQwOTU7XG4gIH1cbiAgbW9kZSA9IG1vZGUudG9TdHJpbmcoKTtcbiAgaWYgKG1vZGUuc3Vic3RyaW5nKDAsIDEpID09PSAnMCcpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQobW9kZSwgOCkgJiA0MDk1O1xuICB9XG4gIHJldHVybiBwYXJzZUludChtb2RlLCAxMCkgJiA0MDk1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTXRpbWUoaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCBtdGltZTtcbiAgaWYgKGlucHV0LnNlY3MgIT0gbnVsbCkge1xuICAgIG10aW1lID0ge1xuICAgICAgc2VjczogaW5wdXQuc2VjcyxcbiAgICAgIG5zZWNzOiBpbnB1dC5uc2Vjc1xuICAgIH07XG4gIH1cbiAgaWYgKGlucHV0LlNlY29uZHMgIT0gbnVsbCkge1xuICAgIG10aW1lID0ge1xuICAgICAgc2VjczogaW5wdXQuU2Vjb25kcyxcbiAgICAgIG5zZWNzOiBpbnB1dC5GcmFjdGlvbmFsTmFub3NlY29uZHNcbiAgICB9O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIG10aW1lID0ge1xuICAgICAgc2VjczogaW5wdXRbMF0sXG4gICAgICBuc2VjczogaW5wdXRbMV1cbiAgICB9O1xuICB9XG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBjb25zdCBtcyA9IGlucHV0LmdldFRpbWUoKTtcbiAgICBjb25zdCBzZWNzID0gTWF0aC5mbG9vcihtcyAvIDEwMDApO1xuICAgIG10aW1lID0ge1xuICAgICAgc2Vjczogc2VjcyxcbiAgICAgIG5zZWNzOiAobXMgLSBzZWNzICogMTAwMCkgKiAxMDAwXG4gICAgfTtcbiAgfVxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtdGltZSwgJ3NlY3MnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG10aW1lICE9IG51bGwgJiYgbXRpbWUubnNlY3MgIT0gbnVsbCAmJiAobXRpbWUubnNlY3MgPCAwIHx8IG10aW1lLm5zZWNzID4gOTk5OTk5OTk5KSkge1xuICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKCdtdGltZS1uc2VjcyBtdXN0IGJlIHdpdGhpbiB0aGUgcmFuZ2UgWzAsOTk5OTk5OTk5XScpLCAnRVJSX0lOVkFMSURfTVRJTUVfTlNFQ1MnKTtcbiAgfVxuICByZXR1cm4gbXRpbWU7XG59XG5jbGFzcyBVbml4RlMge1xuICBzdGF0aWMgdW5tYXJzaGFsKG1hcnNoYWxlZCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBQQkRhdGEuZGVjb2RlKG1hcnNoYWxlZCk7XG4gICAgY29uc3QgZGVjb2RlZCA9IFBCRGF0YS50b09iamVjdChtZXNzYWdlLCB7XG4gICAgICBkZWZhdWx0czogZmFsc2UsXG4gICAgICBhcnJheXM6IHRydWUsXG4gICAgICBsb25nczogTnVtYmVyLFxuICAgICAgb2JqZWN0czogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVuaXhGUyh7XG4gICAgICB0eXBlOiB0eXBlc1tkZWNvZGVkLlR5cGVdLFxuICAgICAgZGF0YTogZGVjb2RlZC5EYXRhLFxuICAgICAgYmxvY2tTaXplczogZGVjb2RlZC5ibG9ja3NpemVzLFxuICAgICAgbW9kZTogZGVjb2RlZC5tb2RlLFxuICAgICAgbXRpbWU6IGRlY29kZWQubXRpbWUgPyB7XG4gICAgICAgIHNlY3M6IGRlY29kZWQubXRpbWUuU2Vjb25kcyxcbiAgICAgICAgbnNlY3M6IGRlY29kZWQubXRpbWUuRnJhY3Rpb25hbE5hbm9zZWNvbmRzXG4gICAgICB9IDogdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgZGF0YS5fb3JpZ2luYWxNb2RlID0gZGVjb2RlZC5tb2RlIHx8IDA7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHsgdHlwZTogJ2ZpbGUnIH0pIHtcbiAgICBjb25zdCB7dHlwZSwgZGF0YSwgYmxvY2tTaXplcywgaGFzaFR5cGUsIGZhbm91dCwgbXRpbWUsIG1vZGV9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZSAmJiAhdHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKCdUeXBlOiAnICsgdHlwZSArICcgaXMgbm90IHZhbGlkJyksICdFUlJfSU5WQUxJRF9UWVBFJyk7XG4gICAgfVxuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgJ2ZpbGUnO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5oYXNoVHlwZSA9IGhhc2hUeXBlO1xuICAgIHRoaXMuZmFub3V0ID0gZmFub3V0O1xuICAgIHRoaXMuYmxvY2tTaXplcyA9IGJsb2NrU2l6ZXMgfHwgW107XG4gICAgdGhpcy5fb3JpZ2luYWxNb2RlID0gMDtcbiAgICB0aGlzLm1vZGUgPSBwYXJzZU1vZGUobW9kZSk7XG4gICAgaWYgKG10aW1lKSB7XG4gICAgICB0aGlzLm10aW1lID0gcGFyc2VNdGltZShtdGltZSk7XG4gICAgICBpZiAodGhpcy5tdGltZSAmJiAhdGhpcy5tdGltZS5uc2Vjcykge1xuICAgICAgICB0aGlzLm10aW1lLm5zZWNzID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2V0IG1vZGUobW9kZSkge1xuICAgIHRoaXMuX21vZGUgPSB0aGlzLmlzRGlyZWN0b3J5KCkgPyBERUZBVUxUX0RJUkVDVE9SWV9NT0RFIDogREVGQVVMVF9GSUxFX01PREU7XG4gICAgY29uc3QgcGFyc2VkTW9kZSA9IHBhcnNlTW9kZShtb2RlKTtcbiAgICBpZiAocGFyc2VkTW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9tb2RlID0gcGFyc2VkTW9kZTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gIH1cbiAgaXNEaXJlY3RvcnkoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy50eXBlICYmIGRpclR5cGVzLmluY2x1ZGVzKHRoaXMudHlwZSkpO1xuICB9XG4gIGFkZEJsb2NrU2l6ZShzaXplKSB7XG4gICAgdGhpcy5ibG9ja1NpemVzLnB1c2goc2l6ZSk7XG4gIH1cbiAgcmVtb3ZlQmxvY2tTaXplKGluZGV4KSB7XG4gICAgdGhpcy5ibG9ja1NpemVzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgZmlsZVNpemUoKSB7XG4gICAgaWYgKHRoaXMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBzdW0gPSAwO1xuICAgIHRoaXMuYmxvY2tTaXplcy5mb3JFYWNoKHNpemUgPT4ge1xuICAgICAgc3VtICs9IHNpemU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgc3VtICs9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG4gIH1cbiAgbWFyc2hhbCgpIHtcbiAgICBsZXQgdHlwZTtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLlJhdztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RpcmVjdG9yeSc6XG4gICAgICB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLkRpcmVjdG9yeTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5GaWxlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbWV0YWRhdGEnOlxuICAgICAgdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5NZXRhZGF0YTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3N5bWxpbmsnOlxuICAgICAgdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5TeW1saW5rO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeSc6XG4gICAgICB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLkhBTVRTaGFyZDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcignVHlwZTogJyArIHR5cGUgKyAnIGlzIG5vdCB2YWxpZCcpLCAnRVJSX0lOVkFMSURfVFlQRScpO1xuICAgIH1cbiAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCAhdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IG1vZGU7XG4gICAgaWYgKHRoaXMubW9kZSAhPSBudWxsKSB7XG4gICAgICBtb2RlID0gdGhpcy5fb3JpZ2luYWxNb2RlICYgNDI5NDk2MzIwMCB8IChwYXJzZU1vZGUodGhpcy5tb2RlKSB8fCAwKTtcbiAgICAgIGlmIChtb2RlID09PSBERUZBVUxUX0ZJTEVfTU9ERSAmJiAhdGhpcy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIG1vZGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAobW9kZSA9PT0gREVGQVVMVF9ESVJFQ1RPUllfTU9ERSAmJiB0aGlzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgbW9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG10aW1lO1xuICAgIGlmICh0aGlzLm10aW1lICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTXRpbWUodGhpcy5tdGltZSk7XG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIG10aW1lID0ge1xuICAgICAgICAgIFNlY29uZHM6IHBhcnNlZC5zZWNzLFxuICAgICAgICAgIEZyYWN0aW9uYWxOYW5vc2Vjb25kczogcGFyc2VkLm5zZWNzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtdGltZS5GcmFjdGlvbmFsTmFub3NlY29uZHMgPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgbXRpbWUuRnJhY3Rpb25hbE5hbm9zZWNvbmRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBiRGF0YSA9IHtcbiAgICAgIFR5cGU6IHR5cGUsXG4gICAgICBEYXRhOiBkYXRhLFxuICAgICAgZmlsZXNpemU6IHRoaXMuaXNEaXJlY3RvcnkoKSA/IHVuZGVmaW5lZCA6IHRoaXMuZmlsZVNpemUoKSxcbiAgICAgIGJsb2Nrc2l6ZXM6IHRoaXMuYmxvY2tTaXplcyxcbiAgICAgIGhhc2hUeXBlOiB0aGlzLmhhc2hUeXBlLFxuICAgICAgZmFub3V0OiB0aGlzLmZhbm91dCxcbiAgICAgIG1vZGUsXG4gICAgICBtdGltZVxuICAgIH07XG4gICAgcmV0dXJuIFBCRGF0YS5lbmNvZGUocGJEYXRhKS5maW5pc2goKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgVW5peEZTXG59OyIsImltcG9ydCAkcHJvdG9idWYgZnJvbSAncHJvdG9idWZqcy9taW5pbWFsLmpzJztcbmNvbnN0ICRSZWFkZXIgPSAkcHJvdG9idWYuUmVhZGVyLCAkV3JpdGVyID0gJHByb3RvYnVmLldyaXRlciwgJHV0aWwgPSAkcHJvdG9idWYudXRpbDtcbmNvbnN0ICRyb290ID0gJHByb3RvYnVmLnJvb3RzWydpcGZzLXVuaXhmcyddIHx8ICgkcHJvdG9idWYucm9vdHNbJ2lwZnMtdW5peGZzJ10gPSB7fSk7XG5leHBvcnQgY29uc3QgRGF0YSA9ICRyb290LkRhdGEgPSAoKCkgPT4ge1xuICBmdW5jdGlvbiBEYXRhKHApIHtcbiAgICB0aGlzLmJsb2Nrc2l6ZXMgPSBbXTtcbiAgICBpZiAocClcbiAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gIH1cbiAgRGF0YS5wcm90b3R5cGUuVHlwZSA9IDA7XG4gIERhdGEucHJvdG90eXBlLkRhdGEgPSAkdXRpbC5uZXdCdWZmZXIoW10pO1xuICBEYXRhLnByb3RvdHlwZS5maWxlc2l6ZSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIHRydWUpIDogMDtcbiAgRGF0YS5wcm90b3R5cGUuYmxvY2tzaXplcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gIERhdGEucHJvdG90eXBlLmhhc2hUeXBlID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgdHJ1ZSkgOiAwO1xuICBEYXRhLnByb3RvdHlwZS5mYW5vdXQgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCB0cnVlKSA6IDA7XG4gIERhdGEucHJvdG90eXBlLm1vZGUgPSAwO1xuICBEYXRhLnByb3RvdHlwZS5tdGltZSA9IG51bGw7XG4gIERhdGEuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG0sIHcpIHtcbiAgICBpZiAoIXcpXG4gICAgICB3ID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICB3LnVpbnQzMig4KS5pbnQzMihtLlR5cGUpO1xuICAgIGlmIChtLkRhdGEgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCAnRGF0YScpKVxuICAgICAgdy51aW50MzIoMTgpLmJ5dGVzKG0uRGF0YSk7XG4gICAgaWYgKG0uZmlsZXNpemUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCAnZmlsZXNpemUnKSlcbiAgICAgIHcudWludDMyKDI0KS51aW50NjQobS5maWxlc2l6ZSk7XG4gICAgaWYgKG0uYmxvY2tzaXplcyAhPSBudWxsICYmIG0uYmxvY2tzaXplcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5ibG9ja3NpemVzLmxlbmd0aDsgKytpKVxuICAgICAgICB3LnVpbnQzMigzMikudWludDY0KG0uYmxvY2tzaXplc1tpXSk7XG4gICAgfVxuICAgIGlmIChtLmhhc2hUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwgJ2hhc2hUeXBlJykpXG4gICAgICB3LnVpbnQzMig0MCkudWludDY0KG0uaGFzaFR5cGUpO1xuICAgIGlmIChtLmZhbm91dCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sICdmYW5vdXQnKSlcbiAgICAgIHcudWludDMyKDQ4KS51aW50NjQobS5mYW5vdXQpO1xuICAgIGlmIChtLm1vZGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCAnbW9kZScpKVxuICAgICAgdy51aW50MzIoNTYpLnVpbnQzMihtLm1vZGUpO1xuICAgIGlmIChtLm10aW1lICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwgJ210aW1lJykpXG4gICAgICAkcm9vdC5Vbml4VGltZS5lbmNvZGUobS5tdGltZSwgdy51aW50MzIoNjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgcmV0dXJuIHc7XG4gIH07XG4gIERhdGEuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC5EYXRhKCk7XG4gICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIG0uVHlwZSA9IHIuaW50MzIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIG0uRGF0YSA9IHIuYnl0ZXMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIG0uZmlsZXNpemUgPSByLnVpbnQ2NCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgaWYgKCEobS5ibG9ja3NpemVzICYmIG0uYmxvY2tzaXplcy5sZW5ndGgpKVxuICAgICAgICAgIG0uYmxvY2tzaXplcyA9IFtdO1xuICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgIHZhciBjMiA9IHIudWludDMyKCkgKyByLnBvcztcbiAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgIG0uYmxvY2tzaXplcy5wdXNoKHIudWludDY0KCkpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBtLmJsb2Nrc2l6ZXMucHVzaChyLnVpbnQ2NCgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIG0uaGFzaFR5cGUgPSByLnVpbnQ2NCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgbS5mYW5vdXQgPSByLnVpbnQ2NCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgbS5tb2RlID0gci51aW50MzIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDg6XG4gICAgICAgIG0ubXRpbWUgPSAkcm9vdC5Vbml4VGltZS5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW0uaGFzT3duUHJvcGVydHkoJ1R5cGUnKSlcbiAgICAgIHRocm93ICR1dGlsLlByb3RvY29sRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgXFwnVHlwZVxcJycsIHsgaW5zdGFuY2U6IG0gfSk7XG4gICAgcmV0dXJuIG07XG4gIH07XG4gIERhdGEuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3QoZCkge1xuICAgIGlmIChkIGluc3RhbmNlb2YgJHJvb3QuRGF0YSlcbiAgICAgIHJldHVybiBkO1xuICAgIHZhciBtID0gbmV3ICRyb290LkRhdGEoKTtcbiAgICBzd2l0Y2ggKGQuVHlwZSkge1xuICAgIGNhc2UgJ1Jhdyc6XG4gICAgY2FzZSAwOlxuICAgICAgbS5UeXBlID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgY2FzZSAxOlxuICAgICAgbS5UeXBlID0gMTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0ZpbGUnOlxuICAgIGNhc2UgMjpcbiAgICAgIG0uVHlwZSA9IDI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNZXRhZGF0YSc6XG4gICAgY2FzZSAzOlxuICAgICAgbS5UeXBlID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1N5bWxpbmsnOlxuICAgIGNhc2UgNDpcbiAgICAgIG0uVHlwZSA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdIQU1UU2hhcmQnOlxuICAgIGNhc2UgNTpcbiAgICAgIG0uVHlwZSA9IDU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGQuRGF0YSAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGQuRGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUoZC5EYXRhLCBtLkRhdGEgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChkLkRhdGEpKSwgMCk7XG4gICAgICBlbHNlIGlmIChkLkRhdGEubGVuZ3RoKVxuICAgICAgICBtLkRhdGEgPSBkLkRhdGE7XG4gICAgfVxuICAgIGlmIChkLmZpbGVzaXplICE9IG51bGwpIHtcbiAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAobS5maWxlc2l6ZSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKGQuZmlsZXNpemUpKS51bnNpZ25lZCA9IHRydWU7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZC5maWxlc2l6ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIG0uZmlsZXNpemUgPSBwYXJzZUludChkLmZpbGVzaXplLCAxMCk7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZC5maWxlc2l6ZSA9PT0gJ251bWJlcicpXG4gICAgICAgIG0uZmlsZXNpemUgPSBkLmZpbGVzaXplO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGQuZmlsZXNpemUgPT09ICdvYmplY3QnKVxuICAgICAgICBtLmZpbGVzaXplID0gbmV3ICR1dGlsLkxvbmdCaXRzKGQuZmlsZXNpemUubG93ID4+PiAwLCBkLmZpbGVzaXplLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgIH1cbiAgICBpZiAoZC5ibG9ja3NpemVzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZC5ibG9ja3NpemVzKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCcuRGF0YS5ibG9ja3NpemVzOiBhcnJheSBleHBlY3RlZCcpO1xuICAgICAgbS5ibG9ja3NpemVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGQuYmxvY2tzaXplcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAobS5ibG9ja3NpemVzW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUoZC5ibG9ja3NpemVzW2ldKSkudW5zaWduZWQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZC5ibG9ja3NpemVzW2ldID09PSAnc3RyaW5nJylcbiAgICAgICAgICBtLmJsb2Nrc2l6ZXNbaV0gPSBwYXJzZUludChkLmJsb2Nrc2l6ZXNbaV0sIDEwKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQuYmxvY2tzaXplc1tpXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgbS5ibG9ja3NpemVzW2ldID0gZC5ibG9ja3NpemVzW2ldO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZC5ibG9ja3NpemVzW2ldID09PSAnb2JqZWN0JylcbiAgICAgICAgICBtLmJsb2Nrc2l6ZXNbaV0gPSBuZXcgJHV0aWwuTG9uZ0JpdHMoZC5ibG9ja3NpemVzW2ldLmxvdyA+Pj4gMCwgZC5ibG9ja3NpemVzW2ldLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZC5oYXNoVHlwZSAhPSBudWxsKSB7XG4gICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgKG0uaGFzaFR5cGUgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShkLmhhc2hUeXBlKSkudW5zaWduZWQgPSB0cnVlO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGQuaGFzaFR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgICBtLmhhc2hUeXBlID0gcGFyc2VJbnQoZC5oYXNoVHlwZSwgMTApO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGQuaGFzaFR5cGUgPT09ICdudW1iZXInKVxuICAgICAgICBtLmhhc2hUeXBlID0gZC5oYXNoVHlwZTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmhhc2hUeXBlID09PSAnb2JqZWN0JylcbiAgICAgICAgbS5oYXNoVHlwZSA9IG5ldyAkdXRpbC5Mb25nQml0cyhkLmhhc2hUeXBlLmxvdyA+Pj4gMCwgZC5oYXNoVHlwZS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKTtcbiAgICB9XG4gICAgaWYgKGQuZmFub3V0ICE9IG51bGwpIHtcbiAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAobS5mYW5vdXQgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShkLmZhbm91dCkpLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmZhbm91dCA9PT0gJ3N0cmluZycpXG4gICAgICAgIG0uZmFub3V0ID0gcGFyc2VJbnQoZC5mYW5vdXQsIDEwKTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmZhbm91dCA9PT0gJ251bWJlcicpXG4gICAgICAgIG0uZmFub3V0ID0gZC5mYW5vdXQ7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZC5mYW5vdXQgPT09ICdvYmplY3QnKVxuICAgICAgICBtLmZhbm91dCA9IG5ldyAkdXRpbC5Mb25nQml0cyhkLmZhbm91dC5sb3cgPj4+IDAsIGQuZmFub3V0LmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgIH1cbiAgICBpZiAoZC5tb2RlICE9IG51bGwpIHtcbiAgICAgIG0ubW9kZSA9IGQubW9kZSA+Pj4gMDtcbiAgICB9XG4gICAgaWYgKGQubXRpbWUgIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBkLm10aW1lICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCcuRGF0YS5tdGltZTogb2JqZWN0IGV4cGVjdGVkJyk7XG4gICAgICBtLm10aW1lID0gJHJvb3QuVW5peFRpbWUuZnJvbU9iamVjdChkLm10aW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH07XG4gIERhdGEudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtLCBvKSB7XG4gICAgaWYgKCFvKVxuICAgICAgbyA9IHt9O1xuICAgIHZhciBkID0ge307XG4gICAgaWYgKG8uYXJyYXlzIHx8IG8uZGVmYXVsdHMpIHtcbiAgICAgIGQuYmxvY2tzaXplcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoby5kZWZhdWx0cykge1xuICAgICAgZC5UeXBlID0gby5lbnVtcyA9PT0gU3RyaW5nID8gJ1JhdycgOiAwO1xuICAgICAgaWYgKG8uYnl0ZXMgPT09IFN0cmluZylcbiAgICAgICAgZC5EYXRhID0gJyc7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZC5EYXRhID0gW107XG4gICAgICAgIGlmIChvLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICBkLkRhdGEgPSAkdXRpbC5uZXdCdWZmZXIoZC5EYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgIHZhciBuID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgdHJ1ZSk7XG4gICAgICAgIGQuZmlsZXNpemUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyBuLnRvU3RyaW5nKCkgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuLnRvTnVtYmVyKCkgOiBuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGQuZmlsZXNpemUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAnMCcgOiAwO1xuICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgdmFyIG4gPSBuZXcgJHV0aWwuTG9uZygwLCAwLCB0cnVlKTtcbiAgICAgICAgZC5oYXNoVHlwZSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IG4udG9TdHJpbmcoKSA6IG8ubG9uZ3MgPT09IE51bWJlciA/IG4udG9OdW1iZXIoKSA6IG47XG4gICAgICB9IGVsc2VcbiAgICAgICAgZC5oYXNoVHlwZSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/ICcwJyA6IDA7XG4gICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICB2YXIgbiA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIHRydWUpO1xuICAgICAgICBkLmZhbm91dCA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IG4udG9TdHJpbmcoKSA6IG8ubG9uZ3MgPT09IE51bWJlciA/IG4udG9OdW1iZXIoKSA6IG47XG4gICAgICB9IGVsc2VcbiAgICAgICAgZC5mYW5vdXQgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAnMCcgOiAwO1xuICAgICAgZC5tb2RlID0gMDtcbiAgICAgIGQubXRpbWUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobS5UeXBlICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnVHlwZScpKSB7XG4gICAgICBkLlR5cGUgPSBvLmVudW1zID09PSBTdHJpbmcgPyAkcm9vdC5EYXRhLkRhdGFUeXBlW20uVHlwZV0gOiBtLlR5cGU7XG4gICAgfVxuICAgIGlmIChtLkRhdGEgIT0gbnVsbCAmJiBtLmhhc093blByb3BlcnR5KCdEYXRhJykpIHtcbiAgICAgIGQuRGF0YSA9IG8uYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobS5EYXRhLCAwLCBtLkRhdGEubGVuZ3RoKSA6IG8uYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobS5EYXRhKSA6IG0uRGF0YTtcbiAgICB9XG4gICAgaWYgKG0uZmlsZXNpemUgIT0gbnVsbCAmJiBtLmhhc093blByb3BlcnR5KCdmaWxlc2l6ZScpKSB7XG4gICAgICBpZiAodHlwZW9mIG0uZmlsZXNpemUgPT09ICdudW1iZXInKVxuICAgICAgICBkLmZpbGVzaXplID0gby5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG0uZmlsZXNpemUpIDogbS5maWxlc2l6ZTtcbiAgICAgIGVsc2VcbiAgICAgICAgZC5maWxlc2l6ZSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobS5maWxlc2l6ZSkgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobS5maWxlc2l6ZS5sb3cgPj4+IDAsIG0uZmlsZXNpemUuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSkgOiBtLmZpbGVzaXplO1xuICAgIH1cbiAgICBpZiAobS5ibG9ja3NpemVzICYmIG0uYmxvY2tzaXplcy5sZW5ndGgpIHtcbiAgICAgIGQuYmxvY2tzaXplcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtLmJsb2Nrc2l6ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtLmJsb2Nrc2l6ZXNbal0gPT09ICdudW1iZXInKVxuICAgICAgICAgIGQuYmxvY2tzaXplc1tqXSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtLmJsb2Nrc2l6ZXNbal0pIDogbS5ibG9ja3NpemVzW2pdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZC5ibG9ja3NpemVzW2pdID0gby5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtLmJsb2Nrc2l6ZXNbal0pIDogby5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG0uYmxvY2tzaXplc1tqXS5sb3cgPj4+IDAsIG0uYmxvY2tzaXplc1tqXS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKSA6IG0uYmxvY2tzaXplc1tqXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG0uaGFzaFR5cGUgIT0gbnVsbCAmJiBtLmhhc093blByb3BlcnR5KCdoYXNoVHlwZScpKSB7XG4gICAgICBpZiAodHlwZW9mIG0uaGFzaFR5cGUgPT09ICdudW1iZXInKVxuICAgICAgICBkLmhhc2hUeXBlID0gby5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG0uaGFzaFR5cGUpIDogbS5oYXNoVHlwZTtcbiAgICAgIGVsc2VcbiAgICAgICAgZC5oYXNoVHlwZSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobS5oYXNoVHlwZSkgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobS5oYXNoVHlwZS5sb3cgPj4+IDAsIG0uaGFzaFR5cGUuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSkgOiBtLmhhc2hUeXBlO1xuICAgIH1cbiAgICBpZiAobS5mYW5vdXQgIT0gbnVsbCAmJiBtLmhhc093blByb3BlcnR5KCdmYW5vdXQnKSkge1xuICAgICAgaWYgKHR5cGVvZiBtLmZhbm91dCA9PT0gJ251bWJlcicpXG4gICAgICAgIGQuZmFub3V0ID0gby5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG0uZmFub3V0KSA6IG0uZmFub3V0O1xuICAgICAgZWxzZVxuICAgICAgICBkLmZhbm91dCA9IG8ubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobS5mYW5vdXQpIDogby5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG0uZmFub3V0LmxvdyA+Pj4gMCwgbS5mYW5vdXQuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSkgOiBtLmZhbm91dDtcbiAgICB9XG4gICAgaWYgKG0ubW9kZSAhPSBudWxsICYmIG0uaGFzT3duUHJvcGVydHkoJ21vZGUnKSkge1xuICAgICAgZC5tb2RlID0gbS5tb2RlO1xuICAgIH1cbiAgICBpZiAobS5tdGltZSAhPSBudWxsICYmIG0uaGFzT3duUHJvcGVydHkoJ210aW1lJykpIHtcbiAgICAgIGQubXRpbWUgPSAkcm9vdC5Vbml4VGltZS50b09iamVjdChtLm10aW1lLCBvKTtcbiAgICB9XG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIERhdGEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgfTtcbiAgRGF0YS5EYXRhVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSAnUmF3J10gPSAwO1xuICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gJ0RpcmVjdG9yeSddID0gMTtcbiAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9ICdGaWxlJ10gPSAyO1xuICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gJ01ldGFkYXRhJ10gPSAzO1xuICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzRdID0gJ1N5bWxpbmsnXSA9IDQ7XG4gICAgdmFsdWVzW3ZhbHVlc0J5SWRbNV0gPSAnSEFNVFNoYXJkJ10gPSA1O1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0oKTtcbiAgcmV0dXJuIERhdGE7XG59KSgpO1xuZXhwb3J0IGNvbnN0IFVuaXhUaW1lID0gJHJvb3QuVW5peFRpbWUgPSAoKCkgPT4ge1xuICBmdW5jdGlvbiBVbml4VGltZShwKSB7XG4gICAgaWYgKHApXG4gICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICB9XG4gIFVuaXhUaW1lLnByb3RvdHlwZS5TZWNvbmRzID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgZmFsc2UpIDogMDtcbiAgVW5peFRpbWUucHJvdG90eXBlLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyA9IDA7XG4gIFVuaXhUaW1lLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtLCB3KSB7XG4gICAgaWYgKCF3KVxuICAgICAgdyA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgdy51aW50MzIoOCkuaW50NjQobS5TZWNvbmRzKTtcbiAgICBpZiAobS5GcmFjdGlvbmFsTmFub3NlY29uZHMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCAnRnJhY3Rpb25hbE5hbm9zZWNvbmRzJykpXG4gICAgICB3LnVpbnQzMigyMSkuZml4ZWQzMihtLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyk7XG4gICAgcmV0dXJuIHc7XG4gIH07XG4gIFVuaXhUaW1lLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QuVW5peFRpbWUoKTtcbiAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgbS5TZWNvbmRzID0gci5pbnQ2NCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgbS5GcmFjdGlvbmFsTmFub3NlY29uZHMgPSByLmZpeGVkMzIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbS5oYXNPd25Qcm9wZXJ0eSgnU2Vjb25kcycpKVxuICAgICAgdGhyb3cgJHV0aWwuUHJvdG9jb2xFcnJvcignbWlzc2luZyByZXF1aXJlZCBcXCdTZWNvbmRzXFwnJywgeyBpbnN0YW5jZTogbSB9KTtcbiAgICByZXR1cm4gbTtcbiAgfTtcbiAgVW5peFRpbWUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3QoZCkge1xuICAgIGlmIChkIGluc3RhbmNlb2YgJHJvb3QuVW5peFRpbWUpXG4gICAgICByZXR1cm4gZDtcbiAgICB2YXIgbSA9IG5ldyAkcm9vdC5Vbml4VGltZSgpO1xuICAgIGlmIChkLlNlY29uZHMgIT0gbnVsbCkge1xuICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgIChtLlNlY29uZHMgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShkLlNlY29uZHMpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGQuU2Vjb25kcyA9PT0gJ3N0cmluZycpXG4gICAgICAgIG0uU2Vjb25kcyA9IHBhcnNlSW50KGQuU2Vjb25kcywgMTApO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGQuU2Vjb25kcyA9PT0gJ251bWJlcicpXG4gICAgICAgIG0uU2Vjb25kcyA9IGQuU2Vjb25kcztcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLlNlY29uZHMgPT09ICdvYmplY3QnKVxuICAgICAgICBtLlNlY29uZHMgPSBuZXcgJHV0aWwuTG9uZ0JpdHMoZC5TZWNvbmRzLmxvdyA+Pj4gMCwgZC5TZWNvbmRzLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIGlmIChkLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICBtLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyA9IGQuRnJhY3Rpb25hbE5hbm9zZWNvbmRzID4+PiAwO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfTtcbiAgVW5peFRpbWUudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtLCBvKSB7XG4gICAgaWYgKCFvKVxuICAgICAgbyA9IHt9O1xuICAgIHZhciBkID0ge307XG4gICAgaWYgKG8uZGVmYXVsdHMpIHtcbiAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgIHZhciBuID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICBkLlNlY29uZHMgPSBvLmxvbmdzID09PSBTdHJpbmcgPyBuLnRvU3RyaW5nKCkgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuLnRvTnVtYmVyKCkgOiBuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGQuU2Vjb25kcyA9IG8ubG9uZ3MgPT09IFN0cmluZyA/ICcwJyA6IDA7XG4gICAgICBkLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyA9IDA7XG4gICAgfVxuICAgIGlmIChtLlNlY29uZHMgIT0gbnVsbCAmJiBtLmhhc093blByb3BlcnR5KCdTZWNvbmRzJykpIHtcbiAgICAgIGlmICh0eXBlb2YgbS5TZWNvbmRzID09PSAnbnVtYmVyJylcbiAgICAgICAgZC5TZWNvbmRzID0gby5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG0uU2Vjb25kcykgOiBtLlNlY29uZHM7XG4gICAgICBlbHNlXG4gICAgICAgIGQuU2Vjb25kcyA9IG8ubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobS5TZWNvbmRzKSA6IG8ubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtLlNlY29uZHMubG93ID4+PiAwLCBtLlNlY29uZHMuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG0uU2Vjb25kcztcbiAgICB9XG4gICAgaWYgKG0uRnJhY3Rpb25hbE5hbm9zZWNvbmRzICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnRnJhY3Rpb25hbE5hbm9zZWNvbmRzJykpIHtcbiAgICAgIGQuRnJhY3Rpb25hbE5hbm9zZWNvbmRzID0gbS5GcmFjdGlvbmFsTmFub3NlY29uZHM7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9O1xuICBVbml4VGltZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICB9O1xuICByZXR1cm4gVW5peFRpbWU7XG59KSgpO1xuZXhwb3J0IGNvbnN0IE1ldGFkYXRhID0gJHJvb3QuTWV0YWRhdGEgPSAoKCkgPT4ge1xuICBmdW5jdGlvbiBNZXRhZGF0YShwKSB7XG4gICAgaWYgKHApXG4gICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICB9XG4gIE1ldGFkYXRhLnByb3RvdHlwZS5NaW1lVHlwZSA9ICcnO1xuICBNZXRhZGF0YS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobSwgdykge1xuICAgIGlmICghdylcbiAgICAgIHcgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgIGlmIChtLk1pbWVUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwgJ01pbWVUeXBlJykpXG4gICAgICB3LnVpbnQzMigxMCkuc3RyaW5nKG0uTWltZVR5cGUpO1xuICAgIHJldHVybiB3O1xuICB9O1xuICBNZXRhZGF0YS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290Lk1ldGFkYXRhKCk7XG4gICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIG0uTWltZVR5cGUgPSByLnN0cmluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH07XG4gIE1ldGFkYXRhLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KGQpIHtcbiAgICBpZiAoZCBpbnN0YW5jZW9mICRyb290Lk1ldGFkYXRhKVxuICAgICAgcmV0dXJuIGQ7XG4gICAgdmFyIG0gPSBuZXcgJHJvb3QuTWV0YWRhdGEoKTtcbiAgICBpZiAoZC5NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICBtLk1pbWVUeXBlID0gU3RyaW5nKGQuTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfTtcbiAgTWV0YWRhdGEudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtLCBvKSB7XG4gICAgaWYgKCFvKVxuICAgICAgbyA9IHt9O1xuICAgIHZhciBkID0ge307XG4gICAgaWYgKG8uZGVmYXVsdHMpIHtcbiAgICAgIGQuTWltZVR5cGUgPSAnJztcbiAgICB9XG4gICAgaWYgKG0uTWltZVR5cGUgIT0gbnVsbCAmJiBtLmhhc093blByb3BlcnR5KCdNaW1lVHlwZScpKSB7XG4gICAgICBkLk1pbWVUeXBlID0gbS5NaW1lVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIE1ldGFkYXRhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gIH07XG4gIHJldHVybiBNZXRhZGF0YTtcbn0pKCk7XG5leHBvcnQge1xuICAkcm9vdCBhcyBkZWZhdWx0XG59OyIsIi8qKlxuICogVGhpbiBFU00gd3JhcHBlciBmb3IgQ0pTIG5hbWVkIGV4cG9ydHMuXG4gKlxuICogUmVmOiBodHRwczovL3JlZGZpbi5lbmdpbmVlcmluZy9ub2RlLW1vZHVsZXMtYXQtd2FyLXdoeS1jb21tb25qcy1hbmQtZXMtbW9kdWxlcy1jYW50LWdldC1hbG9uZy05NjE3MTM1ZWVjYTFcbiAqL1xuXG5pbXBvcnQgbWVyZ2VPcHRpb25zIGZyb20gJy4vaW5kZXguanMnO1xuZXhwb3J0IGRlZmF1bHQgbWVyZ2VPcHRpb25zO1xuIiwiaW1wb3J0IGJhc2V4IGZyb20gJy4uLy4uL3ZlbmRvci9iYXNlLXguanMnO1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi4vYnl0ZXMuanMnO1xuY2xhc3MgRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgdGhpcy5iYXNlRW5jb2RlID0gYmFzZUVuY29kZTtcbiAgfVxuICBlbmNvZGUoYnl0ZXMpIHtcbiAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gYCR7IHRoaXMucHJlZml4IH0keyB0aGlzLmJhc2VFbmNvZGUoYnl0ZXMpIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJyk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBEZWNvZGVyIHtcbiAgY29uc3RydWN0b3IobmFtZSwgcHJlZml4LCBiYXNlRGVjb2RlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICB0aGlzLmJhc2VEZWNvZGUgPSBiYXNlRGVjb2RlO1xuICB9XG4gIGRlY29kZSh0ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgc3dpdGNoICh0ZXh0WzBdKSB7XG4gICAgICBjYXNlIHRoaXMucHJlZml4OiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZURlY29kZSh0ZXh0LnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHsgSlNPTi5zdHJpbmdpZnkodGV4dCkgfSwgJHsgdGhpcy5uYW1lIH0gZGVjb2RlciBvbmx5IHN1cHBvcnRzIGlucHV0cyBwcmVmaXhlZCB3aXRoICR7IHRoaXMucHJlZml4IH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2FuIG9ubHkgbXVsdGliYXNlIGRlY29kZSBzdHJpbmdzJyk7XG4gICAgfVxuICB9XG4gIG9yKGRlY29kZXIpIHtcbiAgICBjb25zdCBkZWNvZGVycyA9IHtcbiAgICAgIFt0aGlzLnByZWZpeF06IHRoaXMsXG4gICAgICAuLi5kZWNvZGVyLmRlY29kZXJzIHx8IHsgW2RlY29kZXIucHJlZml4XTogZGVjb2RlciB9XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IENvbXBvc2VkRGVjb2RlcihkZWNvZGVycyk7XG4gIH1cbn1cbmNsYXNzIENvbXBvc2VkRGVjb2RlciB7XG4gIGNvbnN0cnVjdG9yKGRlY29kZXJzKSB7XG4gICAgdGhpcy5kZWNvZGVycyA9IGRlY29kZXJzO1xuICB9XG4gIG9yKGRlY29kZXIpIHtcbiAgICBjb25zdCBvdGhlciA9IGRlY29kZXIuZGVjb2RlcnMgfHwgeyBbZGVjb2Rlci5wcmVmaXhdOiBkZWNvZGVyIH07XG4gICAgcmV0dXJuIG5ldyBDb21wb3NlZERlY29kZXIoe1xuICAgICAgLi4udGhpcy5kZWNvZGVycyxcbiAgICAgIC4uLm90aGVyXG4gICAgfSk7XG4gIH1cbiAgZGVjb2RlKGlucHV0KSB7XG4gICAgY29uc3QgcHJlZml4ID0gaW5wdXRbMF07XG4gICAgY29uc3QgZGVjb2RlciA9IHRoaXMuZGVjb2RlcnNbcHJlZml4XTtcbiAgICBpZiAoZGVjb2Rlcikge1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgUmFuZ2VFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7IEpTT04uc3RyaW5naWZ5KGlucHV0KSB9LCBvbmx5IGlucHV0cyBwcmVmaXhlZCB3aXRoICR7IE9iamVjdC5rZXlzKHRoaXMuZGVjb2RlcnMpIH0gYXJlIHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGNsYXNzIENvZGVjIHtcbiAgY29uc3RydWN0b3IobmFtZSwgcHJlZml4LCBiYXNlRW5jb2RlLCBiYXNlRGVjb2RlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICB0aGlzLmJhc2VFbmNvZGUgPSBiYXNlRW5jb2RlO1xuICAgIHRoaXMuYmFzZURlY29kZSA9IGJhc2VEZWNvZGU7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IEVuY29kZXIobmFtZSwgcHJlZml4LCBiYXNlRW5jb2RlKTtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgRGVjb2RlcihuYW1lLCBwcmVmaXgsIGJhc2VEZWNvZGUpO1xuICB9XG4gIGVuY29kZShpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZXIuZW5jb2RlKGlucHV0KTtcbiAgfVxuICBkZWNvZGUoaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVyLmRlY29kZShpbnB1dCk7XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBmcm9tID0gKHtuYW1lLCBwcmVmaXgsIGVuY29kZSwgZGVjb2RlfSkgPT4gbmV3IENvZGVjKG5hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGUpO1xuZXhwb3J0IGNvbnN0IGJhc2VYID0gKHtwcmVmaXgsIG5hbWUsIGFscGhhYmV0fSkgPT4ge1xuICBjb25zdCB7ZW5jb2RlLCBkZWNvZGV9ID0gYmFzZXgoYWxwaGFiZXQsIG5hbWUpO1xuICByZXR1cm4gZnJvbSh7XG4gICAgcHJlZml4LFxuICAgIG5hbWUsXG4gICAgZW5jb2RlLFxuICAgIGRlY29kZTogdGV4dCA9PiBjb2VyY2UoZGVjb2RlKHRleHQpKVxuICB9KTtcbn07XG5jb25zdCBkZWNvZGUgPSAoc3RyaW5nLCBhbHBoYWJldCwgYml0c1BlckNoYXIsIG5hbWUpID0+IHtcbiAgY29uc3QgY29kZXMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7ICsraSkge1xuICAgIGNvZGVzW2FscGhhYmV0W2ldXSA9IGk7XG4gIH1cbiAgbGV0IGVuZCA9IHN0cmluZy5sZW5ndGg7XG4gIHdoaWxlIChzdHJpbmdbZW5kIC0gMV0gPT09ICc9Jykge1xuICAgIC0tZW5kO1xuICB9XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KGVuZCAqIGJpdHNQZXJDaGFyIC8gOCB8IDApO1xuICBsZXQgYml0cyA9IDA7XG4gIGxldCBidWZmZXIgPSAwO1xuICBsZXQgd3JpdHRlbiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOyArK2kpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGNvZGVzW3N0cmluZ1tpXV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgTm9uLSR7IG5hbWUgfSBjaGFyYWN0ZXJgKTtcbiAgICB9XG4gICAgYnVmZmVyID0gYnVmZmVyIDw8IGJpdHNQZXJDaGFyIHwgdmFsdWU7XG4gICAgYml0cyArPSBiaXRzUGVyQ2hhcjtcbiAgICBpZiAoYml0cyA+PSA4KSB7XG4gICAgICBiaXRzIC09IDg7XG4gICAgICBvdXRbd3JpdHRlbisrXSA9IDI1NSAmIGJ1ZmZlciA+PiBiaXRzO1xuICAgIH1cbiAgfVxuICBpZiAoYml0cyA+PSBiaXRzUGVyQ2hhciB8fCAyNTUgJiBidWZmZXIgPDwgOCAtIGJpdHMpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGRhdGEnKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbmNvbnN0IGVuY29kZSA9IChkYXRhLCBhbHBoYWJldCwgYml0c1BlckNoYXIpID0+IHtcbiAgY29uc3QgcGFkID0gYWxwaGFiZXRbYWxwaGFiZXQubGVuZ3RoIC0gMV0gPT09ICc9JztcbiAgY29uc3QgbWFzayA9ICgxIDw8IGJpdHNQZXJDaGFyKSAtIDE7XG4gIGxldCBvdXQgPSAnJztcbiAgbGV0IGJpdHMgPSAwO1xuICBsZXQgYnVmZmVyID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyIDw8IDggfCBkYXRhW2ldO1xuICAgIGJpdHMgKz0gODtcbiAgICB3aGlsZSAoYml0cyA+IGJpdHNQZXJDaGFyKSB7XG4gICAgICBiaXRzIC09IGJpdHNQZXJDaGFyO1xuICAgICAgb3V0ICs9IGFscGhhYmV0W21hc2sgJiBidWZmZXIgPj4gYml0c107XG4gICAgfVxuICB9XG4gIGlmIChiaXRzKSB7XG4gICAgb3V0ICs9IGFscGhhYmV0W21hc2sgJiBidWZmZXIgPDwgYml0c1BlckNoYXIgLSBiaXRzXTtcbiAgfVxuICBpZiAocGFkKSB7XG4gICAgd2hpbGUgKG91dC5sZW5ndGggKiBiaXRzUGVyQ2hhciAmIDcpIHtcbiAgICAgIG91dCArPSAnPSc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuZXhwb3J0IGNvbnN0IHJmYzQ2NDggPSAoe25hbWUsIHByZWZpeCwgYml0c1BlckNoYXIsIGFscGhhYmV0fSkgPT4ge1xuICByZXR1cm4gZnJvbSh7XG4gICAgcHJlZml4LFxuICAgIG5hbWUsXG4gICAgZW5jb2RlKGlucHV0KSB7XG4gICAgICByZXR1cm4gZW5jb2RlKGlucHV0LCBhbHBoYWJldCwgYml0c1BlckNoYXIpO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICByZXR1cm4gZGVjb2RlKGlucHV0LCBhbHBoYWJldCwgYml0c1BlckNoYXIsIG5hbWUpO1xuICAgIH1cbiAgfSk7XG59OyIsImltcG9ydCB7IGJhc2VYIH0gZnJvbSAnLi9iYXNlLmpzJztcbmV4cG9ydCBjb25zdCBiYXNlMTAgPSBiYXNlWCh7XG4gIHByZWZpeDogJzknLFxuICBuYW1lOiAnYmFzZTEwJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5J1xufSk7IiwiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTE2ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ2YnLFxuICBuYW1lOiAnYmFzZTE2JyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmJyxcbiAgYml0c1BlckNoYXI6IDRcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UxNnVwcGVyID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ0YnLFxuICBuYW1lOiAnYmFzZTE2dXBwZXInLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlBQkNERUYnLFxuICBiaXRzUGVyQ2hhcjogNFxufSk7IiwiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnMCcsXG4gIG5hbWU6ICdiYXNlMicsXG4gIGFscGhhYmV0OiAnMDEnLFxuICBiaXRzUGVyQ2hhcjogMVxufSk7IiwiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTMyID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ2InLFxuICBuYW1lOiAnYmFzZTMyJyxcbiAgYWxwaGFiZXQ6ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2NycsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJ1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdCJyxcbiAgbmFtZTogJ2Jhc2UzMnVwcGVyJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJwYWQgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnYycsXG4gIG5hbWU6ICdiYXNlMzJwYWQnLFxuICBhbHBoYWJldDogJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJwYWR1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdDJyxcbiAgbmFtZTogJ2Jhc2UzMnBhZHVwcGVyJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2Nz0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ3YnLFxuICBuYW1lOiAnYmFzZTMyaGV4JyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dicsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXh1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdWJyxcbiAgbmFtZTogJ2Jhc2UzMmhleHVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXhwYWQgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAndCcsXG4gIG5hbWU6ICdiYXNlMzJoZXhwYWQnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXhwYWR1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdUJyxcbiAgbmFtZTogJ2Jhc2UzMmhleHBhZHVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVj0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyeiA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdoJyxcbiAgbmFtZTogJ2Jhc2UzMnonLFxuICBhbHBoYWJldDogJ3libmRyZmc4ZWprbWNwcXhvdDF1d2lzemEzNDVoNzY5JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pOyIsImltcG9ydCB7IGJhc2VYIH0gZnJvbSAnLi9iYXNlLmpzJztcbmV4cG9ydCBjb25zdCBiYXNlMzYgPSBiYXNlWCh7XG4gIHByZWZpeDogJ2snLFxuICBuYW1lOiAnYmFzZTM2JyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonXG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzZ1cHBlciA9IGJhc2VYKHtcbiAgcHJlZml4OiAnSycsXG4gIG5hbWU6ICdiYXNlMzZ1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJ1xufSk7IiwiaW1wb3J0IHsgYmFzZVggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGJ0YyA9IGJhc2VYKHtcbiAgbmFtZTogJ2Jhc2U1OGJ0YycsXG4gIHByZWZpeDogJ3onLFxuICBhbHBoYWJldDogJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG59KTtcbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3IgPSBiYXNlWCh7XG4gIG5hbWU6ICdiYXNlNThmbGlja3InLFxuICBwcmVmaXg6ICdaJyxcbiAgYWxwaGFiZXQ6ICcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJ1xufSk7IiwiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTY0ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ20nLFxuICBuYW1lOiAnYmFzZTY0JyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyxcbiAgYml0c1BlckNoYXI6IDZcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHBhZCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdNJyxcbiAgbmFtZTogJ2Jhc2U2NHBhZCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nLFxuICBiaXRzUGVyQ2hhcjogNlxufSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ3UnLFxuICBuYW1lOiAnYmFzZTY0dXJsJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyxcbiAgYml0c1BlckNoYXI6IDZcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybHBhZCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdVJyxcbiAgbmFtZTogJ2Jhc2U2NHVybHBhZCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz0nLFxuICBiaXRzUGVyQ2hhcjogNlxufSk7IiwiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTggPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnNycsXG4gIG5hbWU6ICdiYXNlOCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogM1xufSk7IiwiaW1wb3J0IHsgZnJvbSB9IGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQge1xuICBmcm9tU3RyaW5nLFxuICB0b1N0cmluZ1xufSBmcm9tICcuLi9ieXRlcy5qcyc7XG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSBmcm9tKHtcbiAgcHJlZml4OiAnXFwwJyxcbiAgbmFtZTogJ2lkZW50aXR5JyxcbiAgZW5jb2RlOiBidWYgPT4gdG9TdHJpbmcoYnVmKSxcbiAgZGVjb2RlOiBzdHIgPT4gZnJvbVN0cmluZyhzdHIpXG59KTsiLCJpbXBvcnQgKiBhcyBpZGVudGl0eUJhc2UgZnJvbSAnLi9iYXNlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlMiBmcm9tICcuL2Jhc2VzL2Jhc2UyLmpzJztcbmltcG9ydCAqIGFzIGJhc2U4IGZyb20gJy4vYmFzZXMvYmFzZTguanMnO1xuaW1wb3J0ICogYXMgYmFzZTEwIGZyb20gJy4vYmFzZXMvYmFzZTEwLmpzJztcbmltcG9ydCAqIGFzIGJhc2UxNiBmcm9tICcuL2Jhc2VzL2Jhc2UxNi5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlMzIgZnJvbSAnLi9iYXNlcy9iYXNlMzIuanMnO1xuaW1wb3J0ICogYXMgYmFzZTM2IGZyb20gJy4vYmFzZXMvYmFzZTM2LmpzJztcbmltcG9ydCAqIGFzIGJhc2U1OCBmcm9tICcuL2Jhc2VzL2Jhc2U1OC5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlNjQgZnJvbSAnLi9iYXNlcy9iYXNlNjQuanMnO1xuaW1wb3J0ICogYXMgc2hhMiBmcm9tICcuL2hhc2hlcy9zaGEyLmpzJztcbmltcG9ydCAqIGFzIGlkZW50aXR5IGZyb20gJy4vaGFzaGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCAqIGFzIHJhdyBmcm9tICcuL2NvZGVjcy9yYXcuanMnO1xuaW1wb3J0ICogYXMganNvbiBmcm9tICcuL2NvZGVjcy9qc29uLmpzJztcbmltcG9ydCB7XG4gIENJRCxcbiAgaGFzaGVyLFxuICBkaWdlc3QsXG4gIHZhcmludCxcbiAgYnl0ZXNcbn0gZnJvbSAnLi9pbmRleC5qcyc7XG5jb25zdCBiYXNlcyA9IHtcbiAgLi4uaWRlbnRpdHlCYXNlLFxuICAuLi5iYXNlMixcbiAgLi4uYmFzZTgsXG4gIC4uLmJhc2UxMCxcbiAgLi4uYmFzZTE2LFxuICAuLi5iYXNlMzIsXG4gIC4uLmJhc2UzNixcbiAgLi4uYmFzZTU4LFxuICAuLi5iYXNlNjRcbn07XG5jb25zdCBoYXNoZXMgPSB7XG4gIC4uLnNoYTIsXG4gIC4uLmlkZW50aXR5XG59O1xuY29uc3QgY29kZWNzID0ge1xuICByYXcsXG4gIGpzb25cbn07XG5leHBvcnQge1xuICBDSUQsXG4gIGhhc2hlcixcbiAgZGlnZXN0LFxuICB2YXJpbnQsXG4gIGJ5dGVzLFxuICBoYXNoZXMsXG4gIGJhc2VzLFxuICBjb2RlY3Ncbn07IiwiY29uc3QgZW1wdHkgPSBuZXcgVWludDhBcnJheSgwKTtcbmNvbnN0IHRvSGV4ID0gZCA9PiBkLnJlZHVjZSgoaGV4LCBieXRlKSA9PiBoZXggKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpLCAnJyk7XG5jb25zdCBmcm9tSGV4ID0gaGV4ID0+IHtcbiAgY29uc3QgaGV4ZXMgPSBoZXgubWF0Y2goLy4uL2cpO1xuICByZXR1cm4gaGV4ZXMgPyBuZXcgVWludDhBcnJheShoZXhlcy5tYXAoYiA9PiBwYXJzZUludChiLCAxNikpKSA6IGVtcHR5O1xufTtcbmNvbnN0IGVxdWFscyA9IChhYSwgYmIpID0+IHtcbiAgaWYgKGFhID09PSBiYilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGFhLmJ5dGVMZW5ndGggIT09IGJiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGFhLmJ5dGVMZW5ndGg7IGlpKyspIHtcbiAgICBpZiAoYWFbaWldICE9PSBiYltpaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgY29lcmNlID0gbyA9PiB7XG4gIGlmIChvIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBvLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JylcbiAgICByZXR1cm4gbztcbiAgaWYgKG8gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobyk7XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcobykpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoby5idWZmZXIsIG8uYnl0ZU9mZnNldCwgby5ieXRlTGVuZ3RoKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZScpO1xufTtcbmNvbnN0IGlzQmluYXJ5ID0gbyA9PiBvIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KG8pO1xuY29uc3QgZnJvbVN0cmluZyA9IHN0ciA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbmNvbnN0IHRvU3RyaW5nID0gYiA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYik7XG5leHBvcnQge1xuICBlcXVhbHMsXG4gIGNvZXJjZSxcbiAgaXNCaW5hcnksXG4gIGZyb21IZXgsXG4gIHRvSGV4LFxuICBmcm9tU3RyaW5nLFxuICB0b1N0cmluZyxcbiAgZW1wdHlcbn07IiwiaW1wb3J0ICogYXMgdmFyaW50IGZyb20gJy4vdmFyaW50LmpzJztcbmltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICcuL2hhc2hlcy9kaWdlc3QuanMnO1xuaW1wb3J0IHsgYmFzZTU4YnRjIH0gZnJvbSAnLi9iYXNlcy9iYXNlNTguanMnO1xuaW1wb3J0IHsgYmFzZTMyIH0gZnJvbSAnLi9iYXNlcy9iYXNlMzIuanMnO1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi9ieXRlcy5qcyc7XG5leHBvcnQgY2xhc3MgQ0lEIHtcbiAgY29uc3RydWN0b3IodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlcykge1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0aGlzLm11bHRpaGFzaCA9IG11bHRpaGFzaDtcbiAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgdGhpcy5ieXRlT2Zmc2V0ID0gYnl0ZXMuYnl0ZU9mZnNldDtcbiAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIHRoaXMuYXNDSUQgPSB0aGlzO1xuICAgIHRoaXMuX2Jhc2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBieXRlT2Zmc2V0OiBoaWRkZW4sXG4gICAgICBieXRlTGVuZ3RoOiBoaWRkZW4sXG4gICAgICBjb2RlOiByZWFkb25seSxcbiAgICAgIHZlcnNpb246IHJlYWRvbmx5LFxuICAgICAgbXVsdGloYXNoOiByZWFkb25seSxcbiAgICAgIGJ5dGVzOiByZWFkb25seSxcbiAgICAgIF9iYXNlQ2FjaGU6IGhpZGRlbixcbiAgICAgIGFzQ0lEOiBoaWRkZW5cbiAgICB9KTtcbiAgfVxuICB0b1YwKCkge1xuICAgIHN3aXRjaCAodGhpcy52ZXJzaW9uKSB7XG4gICAgY2FzZSAwOiB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3Qge2NvZGUsIG11bHRpaGFzaH0gPSB0aGlzO1xuICAgICAgICBpZiAoY29kZSAhPT0gREFHX1BCX0NPREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgbm9uIGRhZy1wYiBDSUQgdG8gQ0lEdjAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXVsdGloYXNoLmNvZGUgIT09IFNIQV8yNTZfQ09ERSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgbm9uIHNoYTItMjU2IG11bHRpaGFzaCBDSUQgdG8gQ0lEdjAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ0lELmNyZWF0ZVYwKG11bHRpaGFzaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRvVjEoKSB7XG4gICAgc3dpdGNoICh0aGlzLnZlcnNpb24pIHtcbiAgICBjYXNlIDA6IHtcbiAgICAgICAgY29uc3Qge2NvZGUsIGRpZ2VzdH0gPSB0aGlzLm11bHRpaGFzaDtcbiAgICAgICAgY29uc3QgbXVsdGloYXNoID0gRGlnZXN0LmNyZWF0ZShjb2RlLCBkaWdlc3QpO1xuICAgICAgICByZXR1cm4gQ0lELmNyZWF0ZVYxKHRoaXMuY29kZSwgbXVsdGloYXNoKTtcbiAgICAgIH1cbiAgICBjYXNlIDE6IHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBFcnJvcihgQ2FuIG5vdCBjb252ZXJ0IENJRCB2ZXJzaW9uICR7IHRoaXMudmVyc2lvbiB9IHRvIHZlcnNpb24gMC4gVGhpcyBpcyBhIGJ1ZyBwbGVhc2UgcmVwb3J0YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBvdGhlciAmJiB0aGlzLmNvZGUgPT09IG90aGVyLmNvZGUgJiYgdGhpcy52ZXJzaW9uID09PSBvdGhlci52ZXJzaW9uICYmIERpZ2VzdC5lcXVhbHModGhpcy5tdWx0aWhhc2gsIG90aGVyLm11bHRpaGFzaCk7XG4gIH1cbiAgdG9TdHJpbmcoYmFzZSkge1xuICAgIGNvbnN0IHtieXRlcywgdmVyc2lvbiwgX2Jhc2VDYWNoZX0gPSB0aGlzO1xuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB0b1N0cmluZ1YwKGJ5dGVzLCBfYmFzZUNhY2hlLCBiYXNlIHx8IGJhc2U1OGJ0Yy5lbmNvZGVyKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRvU3RyaW5nVjEoYnl0ZXMsIF9iYXNlQ2FjaGUsIGJhc2UgfHwgYmFzZTMyLmVuY29kZXIpO1xuICAgIH1cbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgIGhhc2g6IHRoaXMubXVsdGloYXNoLmJ5dGVzXG4gICAgfTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdDSUQnO1xuICB9XG4gIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICByZXR1cm4gJ0NJRCgnICsgdGhpcy50b1N0cmluZygpICsgJyknO1xuICB9XG4gIHN0YXRpYyBpc0NJRCh2YWx1ZSkge1xuICAgIGRlcHJlY2F0ZSgvXjBcXC4wLywgSVNfQ0lEX0RFUFJFQ0FUSU9OKTtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgKHZhbHVlW2NpZFN5bWJvbF0gfHwgdmFsdWUuYXNDSUQgPT09IHZhbHVlKSk7XG4gIH1cbiAgZ2V0IHRvQmFzZUVuY29kZWRTdHJpbmcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXByZWNhdGVkLCB1c2UgLnRvU3RyaW5nKCknKTtcbiAgfVxuICBnZXQgY29kZWMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVjXCIgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCwgdXNlIGludGVnZXIgXCJjb2RlXCIgcHJvcGVydHkgaW5zdGVhZCcpO1xuICB9XG4gIGdldCBidWZmZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXByZWNhdGVkIC5idWZmZXIgcHJvcGVydHksIHVzZSAuYnl0ZXMgdG8gZ2V0IFVpbnQ4QXJyYXkgaW5zdGVhZCcpO1xuICB9XG4gIGdldCBtdWx0aWJhc2VOYW1lKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJtdWx0aWJhc2VOYW1lXCIgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCcpO1xuICB9XG4gIGdldCBwcmVmaXgoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcInByZWZpeFwiIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQnKTtcbiAgfVxuICBzdGF0aWMgYXNDSUQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDSUQpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUuYXNDSUQgPT09IHZhbHVlKSB7XG4gICAgICBjb25zdCB7dmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlc30gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaCwgYnl0ZXMgfHwgZW5jb2RlQ0lEKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaC5ieXRlcykpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZVtjaWRTeW1ib2xdID09PSB0cnVlKSB7XG4gICAgICBjb25zdCB7dmVyc2lvbiwgbXVsdGloYXNoLCBjb2RlfSA9IHZhbHVlO1xuICAgICAgY29uc3QgZGlnZXN0ID0gRGlnZXN0LmRlY29kZShtdWx0aWhhc2gpO1xuICAgICAgcmV0dXJuIENJRC5jcmVhdGUodmVyc2lvbiwgY29kZSwgZGlnZXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGUodmVyc2lvbiwgY29kZSwgZGlnZXN0KSB7XG4gICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgY29kZWNzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgIGNhc2UgMDoge1xuICAgICAgICBpZiAoY29kZSAhPT0gREFHX1BCX0NPREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnNpb24gMCBDSUQgbXVzdCB1c2UgZGFnLXBiIChjb2RlOiAkeyBEQUdfUEJfQ09ERSB9KSBibG9jayBlbmNvZGluZ2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIGRpZ2VzdCwgZGlnZXN0LmJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNhc2UgMToge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuY29kZUNJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QuYnl0ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IENJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QsIGJ5dGVzKTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJzaW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGVWMChkaWdlc3QpIHtcbiAgICByZXR1cm4gQ0lELmNyZWF0ZSgwLCBEQUdfUEJfQ09ERSwgZGlnZXN0KTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlVjEoY29kZSwgZGlnZXN0KSB7XG4gICAgcmV0dXJuIENJRC5jcmVhdGUoMSwgY29kZSwgZGlnZXN0KTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlKGJ5dGVzKSB7XG4gICAgY29uc3QgW2NpZCwgcmVtYWluZGVyXSA9IENJRC5kZWNvZGVGaXJzdChieXRlcyk7XG4gICAgaWYgKHJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2lkO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVGaXJzdChieXRlcykge1xuICAgIGNvbnN0IHNwZWNzID0gQ0lELmluc3BlY3RCeXRlcyhieXRlcyk7XG4gICAgY29uc3QgcHJlZml4U2l6ZSA9IHNwZWNzLnNpemUgLSBzcGVjcy5tdWx0aWhhc2hTaXplO1xuICAgIGNvbnN0IG11bHRpaGFzaEJ5dGVzID0gY29lcmNlKGJ5dGVzLnN1YmFycmF5KHByZWZpeFNpemUsIHByZWZpeFNpemUgKyBzcGVjcy5tdWx0aWhhc2hTaXplKSk7XG4gICAgaWYgKG11bHRpaGFzaEJ5dGVzLmJ5dGVMZW5ndGggIT09IHNwZWNzLm11bHRpaGFzaFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICBjb25zdCBkaWdlc3RCeXRlcyA9IG11bHRpaGFzaEJ5dGVzLnN1YmFycmF5KHNwZWNzLm11bHRpaGFzaFNpemUgLSBzcGVjcy5kaWdlc3RTaXplKTtcbiAgICBjb25zdCBkaWdlc3QgPSBuZXcgRGlnZXN0LkRpZ2VzdChzcGVjcy5tdWx0aWhhc2hDb2RlLCBzcGVjcy5kaWdlc3RTaXplLCBkaWdlc3RCeXRlcywgbXVsdGloYXNoQnl0ZXMpO1xuICAgIGNvbnN0IGNpZCA9IHNwZWNzLnZlcnNpb24gPT09IDAgPyBDSUQuY3JlYXRlVjAoZGlnZXN0KSA6IENJRC5jcmVhdGVWMShzcGVjcy5jb2RlYywgZGlnZXN0KTtcbiAgICByZXR1cm4gW1xuICAgICAgY2lkLFxuICAgICAgYnl0ZXMuc3ViYXJyYXkoc3BlY3Muc2l6ZSlcbiAgICBdO1xuICB9XG4gIHN0YXRpYyBpbnNwZWN0Qnl0ZXMoaW5pdGlhbEJ5dGVzKSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IFtpLCBsZW5ndGhdID0gdmFyaW50LmRlY29kZShpbml0aWFsQnl0ZXMuc3ViYXJyYXkob2Zmc2V0KSk7XG4gICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcbiAgICBsZXQgdmVyc2lvbiA9IG5leHQoKTtcbiAgICBsZXQgY29kZWMgPSBEQUdfUEJfQ09ERTtcbiAgICBpZiAodmVyc2lvbiA9PT0gMTgpIHtcbiAgICAgIHZlcnNpb24gPSAwO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2UgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgIGNvZGVjID0gbmV4dCgpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiAhPT0gMCAmJiB2ZXJzaW9uICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBDSUQgdmVyc2lvbiAkeyB2ZXJzaW9uIH1gKTtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4U2l6ZSA9IG9mZnNldDtcbiAgICBjb25zdCBtdWx0aWhhc2hDb2RlID0gbmV4dCgpO1xuICAgIGNvbnN0IGRpZ2VzdFNpemUgPSBuZXh0KCk7XG4gICAgY29uc3Qgc2l6ZSA9IG9mZnNldCArIGRpZ2VzdFNpemU7XG4gICAgY29uc3QgbXVsdGloYXNoU2l6ZSA9IHNpemUgLSBwcmVmaXhTaXplO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uLFxuICAgICAgY29kZWMsXG4gICAgICBtdWx0aWhhc2hDb2RlLFxuICAgICAgZGlnZXN0U2l6ZSxcbiAgICAgIG11bHRpaGFzaFNpemUsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcGFyc2Uoc291cmNlLCBiYXNlKSB7XG4gICAgY29uc3QgW3ByZWZpeCwgYnl0ZXNdID0gcGFyc2VDSUR0b0J5dGVzKHNvdXJjZSwgYmFzZSk7XG4gICAgY29uc3QgY2lkID0gQ0lELmRlY29kZShieXRlcyk7XG4gICAgY2lkLl9iYXNlQ2FjaGUuc2V0KHByZWZpeCwgc291cmNlKTtcbiAgICByZXR1cm4gY2lkO1xuICB9XG59XG5jb25zdCBwYXJzZUNJRHRvQnl0ZXMgPSAoc291cmNlLCBiYXNlKSA9PiB7XG4gIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gIGNhc2UgJ1EnOiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gYmFzZSB8fCBiYXNlNThidGM7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYXNlNThidGMucHJlZml4LFxuICAgICAgICBkZWNvZGVyLmRlY29kZShgJHsgYmFzZTU4YnRjLnByZWZpeCB9JHsgc291cmNlIH1gKVxuICAgICAgXTtcbiAgICB9XG4gIGNhc2UgYmFzZTU4YnRjLnByZWZpeDoge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGJhc2UgfHwgYmFzZTU4YnRjO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYmFzZTU4YnRjLnByZWZpeCxcbiAgICAgICAgZGVjb2Rlci5kZWNvZGUoc291cmNlKVxuICAgICAgXTtcbiAgICB9XG4gIGNhc2UgYmFzZTMyLnByZWZpeDoge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGJhc2UgfHwgYmFzZTMyO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYmFzZTMyLnByZWZpeCxcbiAgICAgICAgZGVjb2Rlci5kZWNvZGUoc291cmNlKVxuICAgICAgXTtcbiAgICB9XG4gIGRlZmF1bHQ6IHtcbiAgICAgIGlmIChiYXNlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1RvIHBhcnNlIG5vbiBiYXNlMzIgb3IgYmFzZTU4YnRjIGVuY29kZWQgQ0lEIG11bHRpYmFzZSBkZWNvZGVyIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNvdXJjZVswXSxcbiAgICAgICAgYmFzZS5kZWNvZGUoc291cmNlKVxuICAgICAgXTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCB0b1N0cmluZ1YwID0gKGJ5dGVzLCBjYWNoZSwgYmFzZSkgPT4ge1xuICBjb25zdCB7cHJlZml4fSA9IGJhc2U7XG4gIGlmIChwcmVmaXggIT09IGJhc2U1OGJ0Yy5wcmVmaXgpIHtcbiAgICB0aHJvdyBFcnJvcihgQ2Fubm90IHN0cmluZyBlbmNvZGUgVjAgaW4gJHsgYmFzZS5uYW1lIH0gZW5jb2RpbmdgKTtcbiAgfVxuICBjb25zdCBjaWQgPSBjYWNoZS5nZXQocHJlZml4KTtcbiAgaWYgKGNpZCA9PSBudWxsKSB7XG4gICAgY29uc3QgY2lkID0gYmFzZS5lbmNvZGUoYnl0ZXMpLnNsaWNlKDEpO1xuICAgIGNhY2hlLnNldChwcmVmaXgsIGNpZCk7XG4gICAgcmV0dXJuIGNpZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2lkO1xuICB9XG59O1xuY29uc3QgdG9TdHJpbmdWMSA9IChieXRlcywgY2FjaGUsIGJhc2UpID0+IHtcbiAgY29uc3Qge3ByZWZpeH0gPSBiYXNlO1xuICBjb25zdCBjaWQgPSBjYWNoZS5nZXQocHJlZml4KTtcbiAgaWYgKGNpZCA9PSBudWxsKSB7XG4gICAgY29uc3QgY2lkID0gYmFzZS5lbmNvZGUoYnl0ZXMpO1xuICAgIGNhY2hlLnNldChwcmVmaXgsIGNpZCk7XG4gICAgcmV0dXJuIGNpZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2lkO1xuICB9XG59O1xuY29uc3QgREFHX1BCX0NPREUgPSAxMTI7XG5jb25zdCBTSEFfMjU2X0NPREUgPSAxODtcbmNvbnN0IGVuY29kZUNJRCA9ICh2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gpID0+IHtcbiAgY29uc3QgY29kZU9mZnNldCA9IHZhcmludC5lbmNvZGluZ0xlbmd0aCh2ZXJzaW9uKTtcbiAgY29uc3QgaGFzaE9mZnNldCA9IGNvZGVPZmZzZXQgKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoY29kZSk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaGFzaE9mZnNldCArIG11bHRpaGFzaC5ieXRlTGVuZ3RoKTtcbiAgdmFyaW50LmVuY29kZVRvKHZlcnNpb24sIGJ5dGVzLCAwKTtcbiAgdmFyaW50LmVuY29kZVRvKGNvZGUsIGJ5dGVzLCBjb2RlT2Zmc2V0KTtcbiAgYnl0ZXMuc2V0KG11bHRpaGFzaCwgaGFzaE9mZnNldCk7XG4gIHJldHVybiBieXRlcztcbn07XG5jb25zdCBjaWRTeW1ib2wgPSBTeW1ib2wuZm9yKCdAaXBsZC9qcy1jaWQvQ0lEJyk7XG5jb25zdCByZWFkb25seSA9IHtcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlXG59O1xuY29uc3QgaGlkZGVuID0ge1xuICB3cml0YWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59O1xuY29uc3QgdmVyc2lvbiA9ICcwLjAuMC1kZXYnO1xuY29uc3QgZGVwcmVjYXRlID0gKHJhbmdlLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChyYW5nZS50ZXN0KHZlcnNpb24pKSB7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcbmNvbnN0IElTX0NJRF9ERVBSRUNBVElPTiA9IGBDSUQuaXNDSUQodikgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5Gb2xsb3dpbmcgY29kZSBwYXR0ZXJuOlxuXG5pZiAoQ0lELmlzQ0lEKHZhbHVlKSkge1xuICBkb1NvbWV0aGluZ1dpdGhDSUQodmFsdWUpXG59XG5cbklzIHJlcGxhY2VkIHdpdGg6XG5cbmNvbnN0IGNpZCA9IENJRC5hc0NJRCh2YWx1ZSlcbmlmIChjaWQpIHtcbiAgLy8gTWFrZSBzdXJlIHRvIHVzZSBjaWQgaW5zdGVhZCBvZiB2YWx1ZVxuICBkb1NvbWV0aGluZ1dpdGhDSUQoY2lkKVxufVxuYDsiLCJjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmV4cG9ydCBjb25zdCBuYW1lID0gJ2pzb24nO1xuZXhwb3J0IGNvbnN0IGNvZGUgPSA1MTI7XG5leHBvcnQgY29uc3QgZW5jb2RlID0gbm9kZSA9PiB0ZXh0RW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkobm9kZSkpO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGRhdGEgPT4gSlNPTi5wYXJzZSh0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YSkpOyIsImltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJztcbmV4cG9ydCBjb25zdCBuYW1lID0gJ3Jhdyc7XG5leHBvcnQgY29uc3QgY29kZSA9IDg1O1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IG5vZGUgPT4gY29lcmNlKG5vZGUpO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGRhdGEgPT4gY29lcmNlKGRhdGEpOyIsImltcG9ydCB7XG4gIGNvZXJjZSxcbiAgZXF1YWxzIGFzIGVxdWFsQnl0ZXNcbn0gZnJvbSAnLi4vYnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgdmFyaW50IGZyb20gJy4uL3ZhcmludC5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlID0gKGNvZGUsIGRpZ2VzdCkgPT4ge1xuICBjb25zdCBzaXplID0gZGlnZXN0LmJ5dGVMZW5ndGg7XG4gIGNvbnN0IHNpemVPZmZzZXQgPSB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoY29kZSk7XG4gIGNvbnN0IGRpZ2VzdE9mZnNldCA9IHNpemVPZmZzZXQgKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoc2l6ZSk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGlnZXN0T2Zmc2V0ICsgc2l6ZSk7XG4gIHZhcmludC5lbmNvZGVUbyhjb2RlLCBieXRlcywgMCk7XG4gIHZhcmludC5lbmNvZGVUbyhzaXplLCBieXRlcywgc2l6ZU9mZnNldCk7XG4gIGJ5dGVzLnNldChkaWdlc3QsIGRpZ2VzdE9mZnNldCk7XG4gIHJldHVybiBuZXcgRGlnZXN0KGNvZGUsIHNpemUsIGRpZ2VzdCwgYnl0ZXMpO1xufTtcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSBtdWx0aWhhc2ggPT4ge1xuICBjb25zdCBieXRlcyA9IGNvZXJjZShtdWx0aWhhc2gpO1xuICBjb25zdCBbY29kZSwgc2l6ZU9mZnNldF0gPSB2YXJpbnQuZGVjb2RlKGJ5dGVzKTtcbiAgY29uc3QgW3NpemUsIGRpZ2VzdE9mZnNldF0gPSB2YXJpbnQuZGVjb2RlKGJ5dGVzLnN1YmFycmF5KHNpemVPZmZzZXQpKTtcbiAgY29uc3QgZGlnZXN0ID0gYnl0ZXMuc3ViYXJyYXkoc2l6ZU9mZnNldCArIGRpZ2VzdE9mZnNldCk7XG4gIGlmIChkaWdlc3QuYnl0ZUxlbmd0aCAhPT0gc2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpO1xuICB9XG4gIHJldHVybiBuZXcgRGlnZXN0KGNvZGUsIHNpemUsIGRpZ2VzdCwgYnl0ZXMpO1xufTtcbmV4cG9ydCBjb25zdCBlcXVhbHMgPSAoYSwgYikgPT4ge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhLmNvZGUgPT09IGIuY29kZSAmJiBhLnNpemUgPT09IGIuc2l6ZSAmJiBlcXVhbEJ5dGVzKGEuYnl0ZXMsIGIuYnl0ZXMpO1xuICB9XG59O1xuZXhwb3J0IGNsYXNzIERpZ2VzdCB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIHNpemUsIGRpZ2VzdCwgYnl0ZXMpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5kaWdlc3QgPSBkaWdlc3Q7XG4gICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICB9XG59IiwiaW1wb3J0ICogYXMgRGlnZXN0IGZyb20gJy4vZGlnZXN0LmpzJztcbmV4cG9ydCBjb25zdCBmcm9tID0gKHtuYW1lLCBjb2RlLCBlbmNvZGV9KSA9PiBuZXcgSGFzaGVyKG5hbWUsIGNvZGUsIGVuY29kZSk7XG5leHBvcnQgY2xhc3MgSGFzaGVyIHtcbiAgY29uc3RydWN0b3IobmFtZSwgY29kZSwgZW5jb2RlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuZW5jb2RlID0gZW5jb2RlO1xuICB9XG4gIGFzeW5jIGRpZ2VzdChpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGNvbnN0IGRpZ2VzdCA9IGF3YWl0IHRoaXMuZW5jb2RlKGlucHV0KTtcbiAgICAgIHJldHVybiBEaWdlc3QuY3JlYXRlKHRoaXMuY29kZSwgZGlnZXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZScpO1xuICAgIH1cbiAgfVxufSIsImltcG9ydCB7IGZyb20gfSBmcm9tICcuL2hhc2hlci5qcyc7XG5pbXBvcnQgeyBjb2VyY2UgfSBmcm9tICcuLi9ieXRlcy5qcyc7XG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSBmcm9tKHtcbiAgbmFtZTogJ2lkZW50aXR5JyxcbiAgY29kZTogMCxcbiAgZW5jb2RlOiBpbnB1dCA9PiBjb2VyY2UoaW5wdXQpXG59KTsiLCJpbXBvcnQgeyBmcm9tIH0gZnJvbSAnLi9oYXNoZXIuanMnO1xuY29uc3Qgc2hhID0gbmFtZSA9PiBhc3luYyBkYXRhID0+IG5ldyBVaW50OEFycmF5KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KG5hbWUsIGRhdGEpKTtcbmV4cG9ydCBjb25zdCBzaGEyNTYgPSBmcm9tKHtcbiAgbmFtZTogJ3NoYTItMjU2JyxcbiAgY29kZTogMTgsXG4gIGVuY29kZTogc2hhKCdTSEEtMjU2Jylcbn0pO1xuZXhwb3J0IGNvbnN0IHNoYTUxMiA9IGZyb20oe1xuICBuYW1lOiAnc2hhMi01MTInLFxuICBjb2RlOiAxOSxcbiAgZW5jb2RlOiBzaGEoJ1NIQS01MTInKVxufSk7IiwiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnLi9jaWQuanMnO1xuaW1wb3J0ICogYXMgdmFyaW50IGZyb20gJy4vdmFyaW50LmpzJztcbmltcG9ydCAqIGFzIGJ5dGVzIGZyb20gJy4vYnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgaGFzaGVyIGZyb20gJy4vaGFzaGVzL2hhc2hlci5qcyc7XG5pbXBvcnQgKiBhcyBkaWdlc3QgZnJvbSAnLi9oYXNoZXMvZGlnZXN0LmpzJztcbmV4cG9ydCB7XG4gIENJRCxcbiAgaGFzaGVyLFxuICBkaWdlc3QsXG4gIHZhcmludCxcbiAgYnl0ZXNcbn07IiwiaW1wb3J0IHZhcmludCBmcm9tICcuLi92ZW5kb3IvdmFyaW50LmpzJztcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSBkYXRhID0+IHtcbiAgY29uc3QgY29kZSA9IHZhcmludC5kZWNvZGUoZGF0YSk7XG4gIHJldHVybiBbXG4gICAgY29kZSxcbiAgICB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gIF07XG59O1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvID0gKGludCwgdGFyZ2V0LCBvZmZzZXQgPSAwKSA9PiB7XG4gIHZhcmludC5lbmNvZGUoaW50LCB0YXJnZXQsIG9mZnNldCk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuZXhwb3J0IGNvbnN0IGVuY29kaW5nTGVuZ3RoID0gaW50ID0+IHtcbiAgcmV0dXJuIHZhcmludC5lbmNvZGluZ0xlbmd0aChpbnQpO1xufTsiLCJmdW5jdGlvbiBiYXNlKEFMUEhBQkVULCBuYW1lKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKTtcbiAgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpO1xuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgYW1iaWd1b3VzJyk7XG4gICAgfVxuICAgIEJBU0VfTUFQW3hjXSA9IGk7XG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGg7XG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMCk7XG4gIHZhciBGQUNUT1IgPSBNYXRoLmxvZyhCQVNFKSAvIE1hdGgubG9nKDI1Nik7XG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpO1xuICBmdW5jdGlvbiBlbmNvZGUoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgc291cmNlLmJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBVaW50OEFycmF5LmZyb20oc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHplcm9lcyA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgdmFyIHBiZWdpbiA9IDA7XG4gICAgdmFyIHBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrO1xuICAgICAgemVyb2VzKys7XG4gICAgfVxuICAgIHZhciBzaXplID0gKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEgPj4+IDA7XG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiBpdDEgIT09IC0xOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IDI1NiAqIGI1OFtpdDFdID4+PiAwO1xuICAgICAgICBiNThbaXQxXSA9IGNhcnJ5ICUgQkFTRSA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSBjYXJyeSAvIEJBU0UgPj4+IDA7XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gaTtcbiAgICAgIHBiZWdpbisrO1xuICAgIH1cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aDtcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrKztcbiAgICB9XG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKTtcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHtcbiAgICAgIHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZShzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICAgIHZhciBwc3ogPSAwO1xuICAgIGlmIChzb3VyY2VbcHN6XSA9PT0gJyAnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHdoaWxlIChzb3VyY2VbcHN6XSA9PT0gTEVBREVSKSB7XG4gICAgICB6ZXJvZXMrKztcbiAgICAgIHBzeisrO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IChzb3VyY2UubGVuZ3RoIC0gcHN6KSAqIEZBQ1RPUiArIDEgPj4+IDA7XG4gICAgdmFyIGIyNTYgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildO1xuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiBpdDMgIT09IC0xOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IEJBU0UgKiBiMjU2W2l0M10gPj4+IDA7XG4gICAgICAgIGIyNTZbaXQzXSA9IGNhcnJ5ICUgMjU2ID4+PiAwO1xuICAgICAgICBjYXJyeSA9IGNhcnJ5IC8gMjU2ID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IGk7XG4gICAgICBwc3orKztcbiAgICB9XG4gICAgaWYgKHNvdXJjZVtwc3pdID09PSAnICcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrO1xuICAgIH1cbiAgICB2YXIgdmNoID0gbmV3IFVpbnQ4QXJyYXkoemVyb2VzICsgKHNpemUgLSBpdDQpKTtcbiAgICB2YXIgaiA9IHplcm9lcztcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdO1xuICAgIH1cbiAgICByZXR1cm4gdmNoO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZShzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZyk7XG4gICAgaWYgKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb24tJHsgbmFtZSB9IGNoYXJhY3RlcmApO1xuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfTtcbn1cbnZhciBzcmMgPSBiYXNlO1xudmFyIF9icnJwX19tdWx0aWZvcm1hdHNfc2NvcGVfYmFzZVggPSBzcmM7XG5leHBvcnQgZGVmYXVsdCBfYnJycF9fbXVsdGlmb3JtYXRzX3Njb3BlX2Jhc2VYOyIsInZhciBlbmNvZGVfMSA9IGVuY29kZTtcbnZhciBNU0IgPSAxMjgsIFJFU1QgPSAxMjcsIE1TQkFMTCA9IH5SRVNULCBJTlQgPSBNYXRoLnBvdygyLCAzMSk7XG5mdW5jdGlvbiBlbmNvZGUobnVtLCBvdXQsIG9mZnNldCkge1xuICBvdXQgPSBvdXQgfHwgW107XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0O1xuICB3aGlsZSAobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSBudW0gJiAyNTUgfCBNU0I7XG4gICAgbnVtIC89IDEyODtcbiAgfVxuICB3aGlsZSAobnVtICYgTVNCQUxMKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IG51bSAmIDI1NSB8IE1TQjtcbiAgICBudW0gPj4+PSA3O1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMDtcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMTtcbiAgcmV0dXJuIG91dDtcbn1cbnZhciBkZWNvZGUgPSByZWFkO1xudmFyIE1TQiQxID0gMTI4LCBSRVNUJDEgPSAxMjc7XG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgPSAwLCBvZmZzZXQgPSBvZmZzZXQgfHwgMCwgc2hpZnQgPSAwLCBjb3VudGVyID0gb2Zmc2V0LCBiLCBsID0gYnVmLmxlbmd0aDtcbiAgZG8ge1xuICAgIGlmIChjb3VudGVyID49IGwpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwO1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50Jyk7XG4gICAgfVxuICAgIGIgPSBidWZbY291bnRlcisrXTtcbiAgICByZXMgKz0gc2hpZnQgPCAyOCA/IChiICYgUkVTVCQxKSA8PCBzaGlmdCA6IChiICYgUkVTVCQxKSAqIE1hdGgucG93KDIsIHNoaWZ0KTtcbiAgICBzaGlmdCArPSA3O1xuICB9IHdoaWxlIChiID49IE1TQiQxKTtcbiAgcmVhZC5ieXRlcyA9IGNvdW50ZXIgLSBvZmZzZXQ7XG4gIHJldHVybiByZXM7XG59XG52YXIgTjEgPSBNYXRoLnBvdygyLCA3KTtcbnZhciBOMiA9IE1hdGgucG93KDIsIDE0KTtcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKTtcbnZhciBONCA9IE1hdGgucG93KDIsIDI4KTtcbnZhciBONSA9IE1hdGgucG93KDIsIDM1KTtcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKTtcbnZhciBONyA9IE1hdGgucG93KDIsIDQ5KTtcbnZhciBOOCA9IE1hdGgucG93KDIsIDU2KTtcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKTtcbnZhciBsZW5ndGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgTjEgPyAxIDogdmFsdWUgPCBOMiA/IDIgOiB2YWx1ZSA8IE4zID8gMyA6IHZhbHVlIDwgTjQgPyA0IDogdmFsdWUgPCBONSA/IDUgOiB2YWx1ZSA8IE42ID8gNiA6IHZhbHVlIDwgTjcgPyA3IDogdmFsdWUgPCBOOCA/IDggOiB2YWx1ZSA8IE45ID8gOSA6IDEwO1xufTtcbnZhciB2YXJpbnQgPSB7XG4gIGVuY29kZTogZW5jb2RlXzEsXG4gIGRlY29kZTogZGVjb2RlLFxuICBlbmNvZGluZ0xlbmd0aDogbGVuZ3RoXG59O1xudmFyIF9icnJwX3ZhcmludCA9IHZhcmludDtcbmV4cG9ydCBkZWZhdWx0IF9icnJwX3ZhcmludDsiLCJsZXQgZHVyYXRpb25SRSA9IC8oLT8oPzpcXGQrXFwuP1xcZCp8XFxkKlxcLj9cXGQrKSg/OmVbLStdP1xcZCspPylcXHMqKFtcXHB7TH1dKikvdWlnXHJcblxyXG5cclxuLyoqXHJcbiAqIGNvbnZlcnNpb24gcmF0aW9zXHJcbiAqL1xyXG5cclxucGFyc2UubmFub3NlY29uZCA9XHJcbnBhcnNlLm5zID0gMSAvIDFlNlxyXG5cclxucGFyc2VbJ8K1cyddID1cclxucGFyc2VbJ868cyddID1cclxucGFyc2UudXMgPVxyXG5wYXJzZS5taWNyb3NlY29uZCA9IDEgLyAxZTNcclxuXHJcbnBhcnNlLm1pbGxpc2Vjb25kID1cclxucGFyc2UubXMgPVxyXG5wYXJzZVsnJ10gPSAxXHJcblxyXG5wYXJzZS5zZWNvbmQgPVxyXG5wYXJzZS5zZWMgPVxyXG5wYXJzZS5zID0gcGFyc2UubXMgKiAxMDAwXHJcblxyXG5wYXJzZS5taW51dGUgPVxyXG5wYXJzZS5taW4gPVxyXG5wYXJzZS5tID0gcGFyc2UucyAqIDYwXHJcblxyXG5wYXJzZS5ob3VyID1cclxucGFyc2UuaHIgPVxyXG5wYXJzZS5oID0gcGFyc2UubSAqIDYwXHJcblxyXG5wYXJzZS5kYXkgPVxyXG5wYXJzZS5kID0gcGFyc2UuaCAqIDI0XHJcblxyXG5wYXJzZS53ZWVrID1cclxucGFyc2Uud2sgPVxyXG5wYXJzZS53ID0gcGFyc2UuZCAqIDdcclxuXHJcbnBhcnNlLm1vbnRoID1cclxucGFyc2UuYiA9XHJcbnBhcnNlLmQgKiAoMzY1LjI1IC8gMTIpXHJcblxyXG5wYXJzZS55ZWFyID1cclxucGFyc2UueXIgPVxyXG5wYXJzZS55ID0gcGFyc2UuZCAqIDM2NS4yNVxyXG5cclxuLyoqXHJcbiAqIGNvbnZlcnQgYHN0cmAgdG8gbXNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcblxyXG5mdW5jdGlvbiBwYXJzZShzdHI9JycsIGZvcm1hdD0nbXMnKXtcclxuICB2YXIgcmVzdWx0ID0gbnVsbFxyXG4gIC8vIGlnbm9yZSBjb21tYXMvcGxhY2Vob2xkZXJzXHJcbiAgc3RyID0gKHN0cisnJykucmVwbGFjZSgvKFxcZClbLF9dKFxcZCkvZywgJyQxJDInKVxyXG4gIHN0ci5yZXBsYWNlKGR1cmF0aW9uUkUsIGZ1bmN0aW9uKF8sIG4sIHVuaXRzKXtcclxuICAgIHVuaXRzID0gdW5pdFJhdGlvKHVuaXRzKVxyXG4gICAgaWYgKHVuaXRzKSByZXN1bHQgPSAocmVzdWx0IHx8IDApICsgcGFyc2VGbG9hdChuLCAxMCkgKiB1bml0c1xyXG4gIH0pXHJcblxyXG4gIHJldHVybiByZXN1bHQgJiYgKHJlc3VsdCAvICh1bml0UmF0aW8oZm9ybWF0KSB8fCAxKSlcclxufVxyXG5cclxuZnVuY3Rpb24gdW5pdFJhdGlvKHN0cikge1xyXG4gIHJldHVybiBwYXJzZVtzdHJdIHx8IHBhcnNlW3N0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL3MkLywgJycpXVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBwYXJzZVxyXG4iLCJleHBvcnQgZnVuY3Rpb24gY29uY2F0KGFycmF5cywgbGVuZ3RoKSB7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLmxlbmd0aCwgMCk7XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgYXJyIG9mIGFycmF5cykge1xuICAgIG91dHB1dC5zZXQoYXJyLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBhcnIubGVuZ3RoO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59IiwiZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0iLCJpbXBvcnQgYmFzZXMgZnJvbSAnLi91dGlsL2Jhc2VzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgY29uc3QgYmFzZSA9IGJhc2VzW2VuY29kaW5nXTtcbiAgaWYgKCFiYXNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7IGVuY29kaW5nIH1cImApO1xuICB9XG4gIHJldHVybiBiYXNlLmRlY29kZXIuZGVjb2RlKGAkeyBiYXNlLnByZWZpeCB9JHsgc3RyaW5nIH1gKTtcbn0iLCJpbXBvcnQgYmFzZXMgZnJvbSAnLi91dGlsL2Jhc2VzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhhcnJheSwgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgY29uc3QgYmFzZSA9IGJhc2VzW2VuY29kaW5nXTtcbiAgaWYgKCFiYXNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7IGVuY29kaW5nIH1cImApO1xuICB9XG4gIHJldHVybiBiYXNlLmVuY29kZXIuZW5jb2RlKGFycmF5KS5zdWJzdHJpbmcoMSk7XG59IiwiaW1wb3J0IHsgYmFzZXMgfSBmcm9tICdtdWx0aWZvcm1hdHMvYmFzaWNzJztcbmZ1bmN0aW9uIGNyZWF0ZUNvZGVjKG5hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHByZWZpeCxcbiAgICBlbmNvZGVyOiB7XG4gICAgICBuYW1lLFxuICAgICAgcHJlZml4LFxuICAgICAgZW5jb2RlXG4gICAgfSxcbiAgICBkZWNvZGVyOiB7IGRlY29kZSB9XG4gIH07XG59XG5jb25zdCBzdHJpbmcgPSBjcmVhdGVDb2RlYygndXRmOCcsICd1JywgYnVmID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuICByZXR1cm4gJ3UnICsgZGVjb2Rlci5kZWNvZGUoYnVmKTtcbn0sIHN0ciA9PiB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKHN0ci5zdWJzdHJpbmcoMSkpO1xufSk7XG5jb25zdCBhc2NpaSA9IGNyZWF0ZUNvZGVjKCdhc2NpaScsICdhJywgYnVmID0+IHtcbiAgbGV0IHN0cmluZyA9ICdhJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiBzdHJpbmc7XG59LCBzdHIgPT4ge1xuICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufSk7XG5jb25zdCBCQVNFUyA9IHtcbiAgdXRmODogc3RyaW5nLFxuICAndXRmLTgnOiBzdHJpbmcsXG4gIGhleDogYmFzZXMuYmFzZTE2LFxuICBsYXRpbjE6IGFzY2lpLFxuICBhc2NpaTogYXNjaWksXG4gIGJpbmFyeTogYXNjaWksXG4gIC4uLmJhc2VzXG59O1xuZXhwb3J0IGRlZmF1bHQgQkFTRVM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9